<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>字符串中最多的字符</title>
    <url>/2020/05/26/The-most-characters-in-a-string/</url>
    <content><![CDATA[<p>给定一段字符串, 查找查找其中做的字符和个数.</p>
<h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历所有的字符串, 记录每个字符出现的个数,然后取出最多的.</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>o(n)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>o(n)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'awfoeifaoifauwefa'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> out = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">of</span> str)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!out[i])&#123;</span><br><span class="line">    out[i] = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    out[i] += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> maxItem = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> out)&#123;</span><br><span class="line">  <span class="keyword">if</span>(out[i] &gt; maxNum)&#123;</span><br><span class="line">    maxItem = i</span><br><span class="line">    maxNum = out[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(maxItem, maxNum);</span><br></pre></td></tr></table></figure>
<h2 id="方法二-删除法"><a href="#方法二-删除法" class="headerlink" title="方法二 删除法"></a>方法二 删除法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h3><p>每次取出第一个元素, 然后删除全部相同的, 哪一次删除的最多, 就哪一个元素最多</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'awfoeifaoifauwefa'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> maxItem = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (str.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> s = str[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> originLen = str.length;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(s, <span class="string">'g'</span>)</span><br><span class="line">  str = str.replace(reg, <span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> rLen = str.length;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> diffLen = <span class="built_in">Math</span>.abs(originLen - rLen);</span><br><span class="line">  <span class="keyword">if</span> (diffLen &gt; maxNum) &#123;</span><br><span class="line">    maxItem = s;</span><br><span class="line">    maxNum = diffLen;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(maxItem, maxNum);</span><br></pre></td></tr></table></figure>
<h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三:"></a>方法三:</h2><h3 id="先排序-然后找出最多连续的"><a href="#先排序-然后找出最多连续的" class="headerlink" title="先排序, 然后找出最多连续的"></a>先排序, 然后找出最多连续的</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'awfoeifaoifauwefa'</span>;</span><br><span class="line"></span><br><span class="line">str = str.split(<span class="string">''</span>).sort();</span><br><span class="line"><span class="keyword">let</span> cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> maxNum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> maxItem = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; str.length <span class="number">-1</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (str[i+<span class="number">1</span>] === str[i]) &#123;</span><br><span class="line">    cnt++;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt; maxNum) &#123;</span><br><span class="line">      maxNum = cnt;</span><br><span class="line">      maxItem = str[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(maxItem, maxNum);</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>深入了解package.json</title>
    <url>/2020/05/21/deep-inside-package-json/</url>
    <content><![CDATA[<p>原文: <a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">https://docs.npmjs.com/files/package.json</a></p>
<p>描述<br>package.json文件是一个json文件,不是一个js对象字面量.</p>
<blockquote>
<p>下面是各个字段的介绍</p>
</blockquote>
<a id="more"></a>
<h2 id="name"><a href="#name" class="headerlink" title="name"></a>name</h2><p>如果想要发布包, 最重要的就是<code>name</code>和<code>version</code>字段,他们是必须的.<code>name</code>和<code>version</code>组合起来作为一个标识符, 必须是唯一的.改变包的内容需要改变包的版本号.如果不打算发布,那么名字和版本字段就是可选的.</p>
<h3 id="一些规则"><a href="#一些规则" class="headerlink" title="一些规则:"></a>一些规则:</h3><ul>
<li>名字必须少于或等于214个字符.包括了scoped package的scope. 例如@jd/xxx.</li>
<li>名字开头不能是点或者下划线</li>
<li>不能包含大写</li>
<li>名字可能会作为url的一部分,一个命令行的参数,或者以文件夹名字.所以名字不能包含非URL安全的字符.</li>
</ul>
<h3 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议:"></a>一些建议:</h3><ul>
<li>不要与node的核心模块的名字重复</li>
<li>不要加入node 或者 js. 因为写了package.json, 就已经认定是js. 另外可以使用<code>engine</code>字段指定执行的引擎</li>
<li>名字可以作为<code>require()</code>函数的参数,所以应该短一些,但要有合理的描述性</li>
<li>在用名字之前,最好先在<code>https://www.npmjs.com/</code>先检查一下</li>
</ul>
<h2 id="version"><a href="#version" class="headerlink" title="version"></a>version</h2><p>Version必须可以被 <a href="https://github.com/isaacs/node-semver" target="_blank" rel="noopener">node-semver</a>解析.</p>
<h2 id="decription-描述"><a href="#decription-描述" class="headerlink" title="decription 描述"></a>decription 描述</h2><p>一段描述性的字符串.可以帮助人们发现你的包,可以在<code>npm search</code>中展示</p>
<h2 id="keywords-关键词"><a href="#keywords-关键词" class="headerlink" title="keywords 关键词"></a>keywords 关键词</h2><p>一个字符串列表.也可以在<code>npm search</code>中展示</p>
<h2 id="homepage-主页"><a href="#homepage-主页" class="headerlink" title="homepage 主页"></a>homepage 主页</h2><p>项目的主页.例如<code>&quot;homepage&quot;: &quot;https://github.com/owner/project#readme&quot;</code></p>
<h2 id="bugs"><a href="#bugs" class="headerlink" title="bugs"></a>bugs</h2><p>项目中的issue的跟踪器(比如GitHub issue, jira, gitlab issue)或者一个email 地址, 可以用来报告issue.这对遇到问题的人很有帮助.<br>他看起来是这样的:<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  <span class="attr">"url"</span> : <span class="string">"https://github.com/owner/project/issues"</span>,</span><br><span class="line">  <span class="attr">"email"</span> : <span class="string">"project@hostname.com"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以指定一个或多个值.如果只提供一个url,那么可以把bugs的值设置为一个字符串.</p>
<p>如果设置了url,可以被<code>npm bugs</code>命令用到</p>
<h2 id="license-证书"><a href="#license-证书" class="headerlink" title="license 证书"></a>license 证书</h2><p>应该制定一个证书, 这样人们可以知道他们允许如何使用. 你可以把你的任何限制放到这里.</p>
<p>可以使用一个公开的证书比如MIT,比如<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"license"</span> : <span class="string">"BSD-3-Clause"</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不想给其他人使用私有的或者未发布的包,可以使用:<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"license"</span>: <span class="string">"UNLICENSED"</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以设置<code>&quot;private&quot;: true</code>来避免意外发布.</p>
<h2 id="与人相关的字段-author-contributors"><a href="#与人相关的字段-author-contributors" class="headerlink" title="与人相关的字段: author, contributors"></a>与人相关的字段: author, contributors</h2><p>作者是一个人,贡献者是人名列表.其中,一个<code>person</code>是一个对象,包含<code>name</code>字段.<code>url</code>和<code>email</code>字段是非必填.比如:<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"name"</span> : <span class="string">"Barney Rubble"</span></span><br><span class="line">, <span class="attr">"email"</span> : <span class="string">"b@rubble.com"</span></span><br><span class="line">, <span class="attr">"url"</span> : <span class="string">"http://barnyrubble.tumblr.com/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以把这个简化为一个字符串,npm会自动解析<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Barney Rubble &lt;b@rubble.com&gt; (http://barnyrubble.tumblr.com/)&quot;</span><br></pre></td></tr></table></figure></p>
<h2 id="files"><a href="#files" class="headerlink" title="files"></a>files</h2><p>文件字段是一个文件通配符的列表,当包作为一个依赖,可以描述包的入口文件. 文件通配符与 <code>.gitignore</code> 遵循类似的语法,但是有所保留: 当打包的时候可以包含一个文件,文件夹或者一个通配符文件.忽略这个字段将会默认为<code>[*]</code>, 意思是包含所有的文件.</p>
<p>有些特殊的文件和文件夹会包含或者剔除,无论他们是否存在于<code>file</code>字段.</p>
<p>也可以提供<code>.npmingore</code>文件在包的根目录,可以防止文件被包含进去.在包的根目录下,他不会覆盖<code>files</code>字段,但是在子目录中可以.<code>.npmignore</code>文件类似于<code>.gitignore</code></p>
<p>无论设置如何, 以下的文件始终被包含:</p>
<ul>
<li>package.json</li>
<li>README</li>
<li>CHANGES / CHANGELOG / HISTORY</li>
<li>LICENSE / LICENCE</li>
<li>NOTICE</li>
<li>在’main’字段中的文件</li>
</ul>
<p>相对的,以下的文件始终被忽略</p>
<ul>
<li>.git</li>
<li>CVS</li>
<li>.svn</li>
<li>.hg</li>
<li>.lock-wscript</li>
<li>.wafpickle-N</li>
<li>.*.swp</li>
<li>.DS_Store</li>
<li>._*</li>
<li>npm-debug.log</li>
<li>.npmrc</li>
<li>node_modules</li>
<li>config.gypi</li>
<li>*.orig</li>
<li>package-lock.json (use shrinkwrap instead)</li>
</ul>
<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>main字段是程序的主入口.如果一个包名字为<code>foo</code>,一个用户安装了他,然后<code>require(&#39;foo&#39;)</code>,那么将返回主模块输出对象</p>
<p>他应该是一个相对包文件夹的相对id</p>
<p>对大部分的模块,他最大的意义就是一个入口</p>
<h2 id="browser"><a href="#browser" class="headerlink" title="browser"></a>browser</h2><p>如果模块只在浏览器端使用,那么应该设置<code>browser</code>字段而不是<code>main</code>字段.这可以提示用户, 这个包用到一些nodejs没有的特性</p>
<h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><p>很多包有一个或多个可执行文件,他们想要安装在<code>PATH</code>中,npm让这个非常简单,</p>
<p>为了使用这个, 提供一个<code>bin</code>字段,映射命令的名字和本地文件的名字.当安装的时候, npm会链接文件到<code>prefix/bin</code>全局安装, 或者到<code>./node_modules/.bin</code>中作为本地使用.</p>
<p>例如:<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"bin"</span> : &#123; <span class="attr">"myapp"</span> : <span class="string">"./cli.js"</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果只有一个可执行文件,他的名字就是包的名字, 那么可以只提供一个字符串.</p>
<p>还要确认<code>bin</code>字段指定的文件是<code>#!/usr/bin/env node</code>, 否则脚本就不能使用node的执行环境</p>
<h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p>给<code>man</code>程序指定一个或多个文件.</p>
<h2 id="directories"><a href="#directories" class="headerlink" title="directories"></a>directories</h2><p>commonjs规范指明了使用 <code>directories</code>对象来判断包的结构. 如果你看着package.json我,你就会看到他有文档,类库,和说明文档的目录.</p>
<p>在将来,这个信息还可以在一些其他的创造性的方式.</p>
<h2 id="repository"><a href="#repository" class="headerlink" title="repository"></a>repository</h2><p>指定在线代码的位置.这对想贡献代码的人很有帮助.如果git仓库是github,那么<code>npm docs</code>命令可以帮你找到.</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"repository": &#123;</span><br><span class="line">  "type" : "git",</span><br><span class="line">  "url" : "https://github.com/npm/cli.git"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">"repository": &#123;</span><br><span class="line">  "type" : "svn",</span><br><span class="line">  "url" : "https://v8.googlecode.com/svn/trunk/"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果包不在根目录, 也可以指定在线代码的目录,比如这样:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"repository": &#123;</span><br><span class="line">  "type" : "git",</span><br><span class="line">  "url" : "https://github.com/facebook/react.git",</span><br><span class="line">  "directory": "packages/react-dom"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h2><p>这个属性指定在包的不同生命周期运行的脚本命令.key是命周期的事件,值是具体的命令.</p>
<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>配置对象是在脚本中一直使用的配置参数.比如<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"name"</span> : <span class="string">"foo"</span></span><br><span class="line">, <span class="attr">"config"</span> : &#123; <span class="attr">"port"</span> : <span class="string">"8080"</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p>
<p>如果之后<code>start</code>命令引用了<code>npm_package_config_port</code>环境变量,那么用户可以通过<code>npm config set foo:port 8001</code>覆盖.例如<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"npm-start"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start2"</span>:<span class="string">"npm config set 'npm-start':port 8001 &amp;&amp; node index.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">    <span class="attr">"port"</span>: <span class="string">"8080"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(process.env.npm_package_config_port);</span><br></pre></td></tr></table></figure>
<h2 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h2><p>依赖是一个简单的对象, 映射包的名字和版本范围.版本范围是一个字符串,有一个或多个用空格分开的描述符.依赖也可以是一个压缩文件或者一个git url.</p>
<p>不要把测试和中间文件放到依赖中, 可以放到 <code>devDependencies</code>中.</p>
<p><code>semver</code>中指定了版本的范围.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* version 精确匹配</span><br><span class="line">* &gt;version 大于当前版本</span><br><span class="line">* &gt;=version 大于等于当前版本</span><br><span class="line">* &lt;version</span><br><span class="line">* &lt;=version</span><br><span class="line">* ~version “Approximately equivalent to version” See semver</span><br><span class="line">* ^version “Compatible with version” See semver</span><br><span class="line">* 1.2.x 1.2.0, 1.2.1, etc., but not 1.3.0</span><br><span class="line">* http://... See ‘URLs as Dependencies’ below</span><br><span class="line">* * 任何版本</span><br><span class="line">* &quot;&quot; 空白字符串, 与*相同</span><br><span class="line">* version1 - version2 大于等于版本1, 小于等于版本2</span><br><span class="line">* range1 || range2 </span><br><span class="line">* git... </span><br><span class="line">* user/repo</span><br><span class="line">* tag 带有标签的版本</span><br><span class="line">* path/path/path 本地路径</span><br></pre></td></tr></table></figure>
<h3 id="url-作为依赖"><a href="#url-作为依赖" class="headerlink" title="url 作为依赖"></a>url 作为依赖</h3><p>可以指定一个压缩文件放到版本范围中.<br>压缩文件可以下载并且本地安装</p>
<h3 id="git-url-作为依赖"><a href="#git-url-作为依赖" class="headerlink" title="git url 作为依赖"></a>git url 作为依赖</h3><p>git url 如下形式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;protocol&gt;://[&lt;user&gt;[:&lt;password&gt;]@]&lt;hostname&gt;[:&lt;port&gt;][:][/]&lt;path&gt;[#&lt;commit-ish&gt; | #semver:&lt;semver&gt;]</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;protocol&gt;</code>是git, git+ssh, git+http, git+https, or git+file中的一个.</p>
<p>如果有<code>#&lt;commit-ish&gt;</code>,就可以精确克隆这个提交.</p>
<h3 id="github-url"><a href="#github-url" class="headerlink" title="github url"></a>github url</h3><p>可以使用<code>“foo”: “user/foo-project”</code>来指定github 链接</p>
<h3 id="本地路径"><a href="#本地路径" class="headerlink" title="本地路径"></a>本地路径</h3><p>如下形式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">../foo/bar</span><br><span class="line">~/foo/bar</span><br><span class="line">./foo/bar</span><br><span class="line">/foo/bar</span><br></pre></td></tr></table></figure></p>
<p>如果是相对路径,<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"baz"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"bar"</span>: <span class="string">"file:../foo/bar"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个特性可以帮助本地的离线开发者测试一些不想从外部服务器安装的包.但是在发布的公共库就不能这样使用了.</p>
<h2 id="devDependencies-开发依赖"><a href="#devDependencies-开发依赖" class="headerlink" title="devDependencies 开发依赖"></a>devDependencies 开发依赖</h2><p>如果有人计划在他们的程序中使用你的模块,那么他们可能不想或者不需要使用你的库中用到测试框架.</p>
<p>这时候, 最好把这些额外的配置放到<code>devDependencies</code>中. </p>
<p>这些东西在<code>npm link</code>和<code>npm install</code>的时候会安装, 可以想其他 npm 配置一样被管理.</p>
<p>如果不指定平台,构建,比如说把 coffeescritp 或者其他语言编译成 js,可以使用 <code>prepare</code>脚本完成这个.</p>
<p>比如说:<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"name"</span>: <span class="string">"ethopia-waza"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"a delightfully fruity coffee varietal"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.2.3"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"coffee-script"</span>: <span class="string">"~1.6.3"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"prepare"</span>: <span class="string">"coffee -o lib/ -c src/waza.coffee"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"lib/waza.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>prepare</code>脚本会在发布之前运行, 用户可以自动使用这个功能. 开发模式中,也会运行这个脚本,你可以很容易测试.(TODO:)</p>
<h2 id="peerDependencies"><a href="#peerDependencies" class="headerlink" title="peerDependencies"></a><a href="https://www.cnblogs.com/wonyun/p/9692476.html" target="_blank" rel="noopener">peerDependencies</a></h2><p>有些情况, 可能想要表达对宿主环境的兼容性. 你的模块可能暴露一个特定的接口,指定宿主环境的文档.例如<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"tea-latte"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.3.5"</span>,</span><br><span class="line">  <span class="attr">"peerDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"tea"</span>: <span class="string">"2.x"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这确保了你的包可以单独作为一个宿主环境的包安装.安装了<code>tea-latte</code>之后,可能会有这样的依赖图.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── tea-latte@1.3.5</span><br><span class="line">└── tea@2.2.0</span><br></pre></td></tr></table></figure></p>
<p>注意:在 npm1 和 npm2 会自动安装<code>peerDenpendenices</code>.在 npm3 之后,就不是这样的.使用的时候,可能会收到一个警告,<code>peerDenpendencies</code>没有安装.在 npm1 和<br>npm2 中的这种行为,可能会导致模块地狱.</p>
<p>当有依赖冲突的时候, 会报错.</p>
<h2 id="bundledDependencies"><a href="#bundledDependencies" class="headerlink" title="bundledDependencies"></a>bundledDependencies</h2><p>这里指定了一些包,如果发布, 就打包他们.</p>
<p>当你需要在本地保留包或者想要通过文件下载, 可以设置 peerDependencies 然后执行 npm pack</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"awesome-web-framework"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"bundledDependencies"</span>: [</span><br><span class="line">    <span class="string">"renderized"</span>, <span class="string">"super-streams"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以运行<code>npm pack</code>获得一个<code>awesome-web-framework-1.0.0.tgz</code>的文件.这个文件包含了<code>renderized and super-streams</code>这两个依赖.这里的包名不包含版本,相关的信息在 dependencies 中指定.</p>
<h2 id="optionalDependencies"><a href="#optionalDependencies" class="headerlink" title="optionalDependencies"></a>optionalDependencies</h2><p>当使用一个包的时候, 当无法找到或者安装失败, 你想要 npm 处理他,那么你需要把它放到<code>optionalDependencies</code>中.</p>
<h2 id="engines"><a href="#engines" class="headerlink" title="engines"></a>engines</h2><p>你可以指定使用的 node 版本.</p>
<p>与Dependencies类似, 如果不指定版本,那么所有的 node 版本都可以.</p>
<p>如果指定了 engine 字段,那么 npm 会在某些地方要求 node 版本.如果 engine 忽略了,npm 会默认是 node.</p>
<p>也可以指定哪个版本的 node 是可以的.比如:<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">"engines"</span> : &#123; <span class="attr">"npm"</span> : <span class="string">"~1.0.20"</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="engineStrict"><a href="#engineStrict" class="headerlink" title="engineStrict"></a>engineStrict</h2><p>从 npm3.0.0 就被移除啦.</p>
<h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><p>可能指定运行的操作系统.比如:<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"os" : [ "darwin", "linux" ]</span><br></pre></td></tr></table></figure></p>
<p>或者指定运行系统的黑名单.</p>
<p>主机的操作系统通过<code>process.platform</code>决定.</p>
<h2 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h2><p>如果你的代码只能在特定架构中运行,你可以指定</p>
<h2 id="preferGlobal"><a href="#preferGlobal" class="headerlink" title="preferGlobal"></a>preferGlobal</h2><p>废弃</p>
<h2 id="private"><a href="#private" class="headerlink" title="private"></a>private</h2><p>如果设置私人为 true,那么 npm 就不会发布他.</p>
<p>这是一个阻止意外发布的方式.如果只想在特定的 registry 发布,那么就用<code>publishConfig</code></p>
<h2 id="publishConfig"><a href="#publishConfig" class="headerlink" title="publishConfig"></a>publishConfig</h2><p>这是一组在发布时使用的配置.</p>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><ul>
<li><p><code>&quot;scripts&quot;: {&quot;start&quot;: &quot;node server.js&quot;}</code><br>如果在根目录中有一个 server.js, 那么会默认创建一个启动命令.</p>
</li>
<li><p><code>&quot;scripts&quot;:{&quot;install&quot;: &quot;node-gyp rebuild&quot;}</code><br>如果有一个<code>binding.gyp</code>, 而且也没有定义<code>install</code>和<code>preinstall</code>脚本.</p>
</li>
<li><p><code>&quot;contributors&quot;: [...]</code><br>如果有<code>AUTHOR</code>文件</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的bash命令</title>
    <url>/2020/04/29/bash-command-offen-used/</url>
    <content><![CDATA[<ul>
<li>查看文件夹的体积<br>  <code>du -h [target folder] | sort -h</code></li>
</ul>
]]></content>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>git-credentials中文文档</title>
    <url>/2019/10/10/git-credentials-doc-cn/</url>
    <content><![CDATA[<ul>
<li>原文：<a href="https://git-scm.com/docs/gitcredentials" target="_blank" rel="noopener">https://git-scm.com/docs/gitcredentials</a></li>
</ul>
<h2 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h2><p>gitcredentials - 向git提供用户名和密码</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config credential.https://example.com.username myusername</span><br><span class="line">git config credential.helper <span class="string">"<span class="variable">$helper</span> <span class="variable">$options</span>"</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>有时候git需要一些用户信息来完成一些操作，这些用户信息叫做凭证。比如说，可能需要用户名和密码来通过http来访问远程仓库。这份手册描述了git的获取用户凭证的机制，依赖这个机制也可以避免重复输入。</p>
<h2 id="获取凭证"><a href="#获取凭证" class="headerlink" title="获取凭证"></a>获取凭证</h2><p>当没有凭证的时候，git将会按照一下的策略向用户询问用户名和密码。</p>
<ol>
<li>如果设置了<code>GIT_ASKPASS</code>环境变量，就会调用变量指定的程序。在命令行中会适时的提示，并且从标准输出设备中读取输入。</li>
<li>如果配置了<code>core.askPass</code>，就按照上面的方式使用该变量。</li>
<li>如果配置了<code>SSH_ASKPASS</code>环境变量，按照上面的方式使用该变量。</li>
<li>在终端命令行中提示用户。</li>
</ol>
<h2 id="避免重复"><a href="#避免重复" class="headerlink" title="避免重复"></a>避免重复</h2><p>对于需要一次一次的重复输入相同的用户信息的情况。git提供了两种方法来避免这种烦恼。</p>
<ol>
<li>在当前对用户权限验证环境中，对用户名进行静态配置。</li>
<li>使用凭证助手缓存或者存储密码，或者与系统密码和密码链交互。</li>
</ol>
<p>第一种很简单，适用于不能安全存储密码的情况。这会在配置文件中增加如下的配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[credential &quot;https://example.com&quot;]</span><br><span class="line">	username = me</span><br></pre></td></tr></table></figure></p>
<p>另一种方式，凭证助手是一个额外的程序，git可以从中获取用户名和密码。这通常依赖系统或者其他程序提供的安全存储。</p>
<p>为了使用凭证助手，首先要选择一个使用。git当前包含了一下的凭证助手：</p>
<p><strong>cache</strong></p>
<p>在内存中缓存凭证供短期使用。查看<a href="https://git-scm.com/docs/git-credential-cache" target="_blank" rel="noopener"><code>git-credential-cache</code></a>获取更多细节。</p>
<p><strong>store</strong></p>
<p>在硬盘中长期存储凭证。查看<a href="https://git-scm.com/docs/git-credential-store" target="_blank" rel="noopener"><code>git-credential-store</code></a>获取更多细节。</p>
<p>有可能你已经装了第三方的助手，在<code>git help -a</code>中搜索<code>credential-*</code>，然后查阅每个助手的文档。一旦你选择了一个助手，你可以把他的名字放在<code>credential.helper</code>变量，告诉git来使用它。</p>
<ol>
<li><p>查找助手</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git help -a | grep credential-</span><br><span class="line">credential-foo</span><br></pre></td></tr></table></figure>
</li>
<li><p>阅读他的描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git help credential-foo</span><br></pre></td></tr></table></figure>
</li>
<li><p>告诉git使用他</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global credential.helper foo</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="用户鉴权的上下文环境"><a href="#用户鉴权的上下文环境" class="headerlink" title="用户鉴权的上下文环境"></a>用户鉴权的上下文环境</h2><p>git在url定义的用户权限验证上下文中使用。这个上下文用来查看与上下文相关的配置，并且传递给所有助手，可以用作安全存储的索引。</p>
<p>比如，我们访问了<code>https://example.com/foo.git</code>，当git查找配置文件确定这一部分是否匹配上下文的时候，如果上下文是配置文件更加详细的子集，他会认定两者匹配。例如，如果有这样的配置文件：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[credential &quot;https://example.com&quot;]</span><br><span class="line">	username = foo</span><br></pre></td></tr></table></figure></p>
<p>然后我们可以匹配到：两个协议相同，域名相同，url模式根本不关心路径模块。然而，这个上下文不会匹配：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[credential &quot;https://kernel.org&quot;]</span><br><span class="line">	username = foo</span><br></pre></td></tr></table></figure></p>
<p>因为域名不同。也不会匹配foo.example.com；git会精确比较域名，而考虑是否两个域名是相同的域。同样的，一个<a href="http://exmple.com也不会匹配，git会精确比较协议。" target="_blank" rel="noopener">http://exmple.com也不会匹配，git会精确比较协议。</a></p>
<p>如果模式url不包含路径组件，那么也必须精确比较:<code>https://example.com/bar/baz.git</code>的上下文会匹配<code>https://example.com/bar/baz.git</code>,但是不会匹配<code>https://example.com/bar</code>。</p>
<h2 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h2><p>凭证上下文的选项既可以在<code>credential.\*</code>，也可以在<code>credential.&lt;url&gt;.*</code>中配置。url符合上面提到的上下文。</p>
<p>以下的选择在两种都可以使用：</p>
<p>helper</p>
<p>凭证助手的名字，或者相关的选项。如果助手名字不是绝对路径，那么会在前面注入git credential- 的字符串。这个字符串会在shell中执行。比如设置为<code>foo --option=bar</code>实际会在shell中执行<code>git credential-foo --option=bar</code>.查看制定助手的手册来查看例子。</p>
<p>如果有多个<code>credential-helper</code>的配置变量的实例，那么 <code>git</code>会按照顺序依次尝试，可能需要用户名密码，或者什么都不用。一旦<code>git</code>获取了用户名和密码，就不会尝试其他都凭证助手。</p>
<p>如果配置了<code>credential.helper</code>为空字符串，这会把凭证助手重置为空。</p>
<p>用户名<br>  如果url中没有提供，就会作为默认的用户名</p>
<p><strong>useHttpPath</strong></p>
<p>默认情况，git不会考虑使用凭证助手匹配url的path。这意味着对<code>https://example.com/foo.git</code>凭证，也可以用于<code>https://example.com/bar.git</code>。如果想要区别这些情况，就把这个选项设置为true。</p>
<h2 id="自定义凭证助手"><a href="#自定义凭证助手" class="headerlink" title="自定义凭证助手"></a>自定义凭证助手</h2><p>你也可以实现自定义的凭证助手，来配合使用凭证的系统。阅读文档获得更多细节。</p>
<h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git的一部分。</p>
]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的npm命令</title>
    <url>/2019/08/13/npm-command-offen-used/</url>
    <content><![CDATA[<ul>
<li>查看npm全局包的位置<br>  <code>npm root -g</code></li>
</ul>
]]></content>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的git命令</title>
    <url>/2019/08/13/git-command-line-offen-used/</url>
    <content><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>记录日常开发常用的git命令<br><a id="more"></a></p>
<ul>
<li><p>从远程拉取分支</p>
<p>  <code>git chekcout -b dev origin/dev</code></p>
</li>
<li><p>rebase远程最新的dev代码</p>
<p>  <code>git rebase origin/dev</code></p>
</li>
<li><p>修改上一次commit，包括文件和commit message</p>
<p>  <code>git commit --amend</code>#之后会打开一个vim，修改信息即可</p>
</li>
<li><p>查看当前git的配置信息</p>
<p>  <code>git config user.email</code><br>  <code>git config user.name</code></p>
</li>
<li><p>修改信息</p>
<p>  <code>git config --global user.email [your email address here]</code></p>
</li>
<li><p>修改分支名字</p>
<p>  <code>git branch -m [old-name] new-name</code>#如果在当前就在旧分之，可以省略old-name</p>
</li>
<li><p>删除远程分支</p>
<p>  <code>git push origin --delete &lt;branch-name&gt;</code></p>
</li>
<li><p>设置本地分支的远程跟踪分支</p>
<p>  <code>git branch --set-upstream-to=[origin/&lt;branch-name&gt;]</code></p>
</li>
<li><p>删除<code>git add</code>后暂存文件</p>
<p>  <code>git reset /path/to/file</code></p>
</li>
<li><p>删除已经<code>git commit</code>之后的文件</p>
<p>  <code>git reset --soft HEAD~1</code><br>  <code>git reset /path/to/file</code><br>  <code>rm /path/to/file</code><br>  <code>git commit</code></p>
</li>
<li><p>在本地和远程分别建立代码库之后，添加远程库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin &lt;remote url&gt;</span><br><span class="line">git push -u origin master <span class="comment"># -u 表示当前将origin的master设置为本地分之的跟踪分支</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>git的密码更换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --system --<span class="built_in">unset</span> credential.helper <span class="comment"># 清除http的用户名和密码</span></span><br><span class="line">git fetch <span class="comment"># 随便一个与远程交互命令都可以</span></span><br><span class="line">git config credential.helper store <span class="comment"># 用户名密码明文存储在～/.git-crendential文件中。http://&lt;username&gt;:&lt;password&gt;@&lt;git的url&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除远程地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line"><span class="comment"># View current remotes</span></span><br><span class="line">&gt; origin  https://github.com/OWNER/REPOSITORY.git (fetch)</span><br><span class="line">&gt; origin  https://github.com/OWNER/REPOSITORY.git (push)</span><br><span class="line">&gt; destination  https://github.com/FORKER/REPOSITORY.git (fetch)</span><br><span class="line">&gt; destination  https://github.com/FORKER/REPOSITORY.git (push)</span><br><span class="line">git remote rm destination</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用docker构建统一的开发环境</title>
    <url>/2019/07/17/docker-for-dev-env/</url>
    <content><![CDATA[<h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><p>把要使用的软件通过dockerfile打包成一个镜像，托管到自己的registry中，这样就可以在任意别地方使用了。<br><a id="more"></a></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ul>
<li>安装docker</li>
<li><p>使用如下的dockerfile</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">18.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get  update &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get upgrade -y &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get -y install git &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get -y install vim &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get -y install curl &amp;&amp; \</span></span><br><span class="line"><span class="bash">    curl -sL https://deb.nodesource.com/setup_8.x | bash &amp;&amp; \</span></span><br><span class="line"><span class="bash">    apt-get -y install nodejs &amp;&amp; \</span></span><br><span class="line"><span class="bash">    npm install -g nrm</span></span><br><span class="line"><span class="bash">CMD git --version &amp;&amp; bash --version &amp;&amp; ssh -V &amp;&amp; npm -v &amp;&amp; node -v</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行构建命令。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker build -t tbswang-dev-<span class="keyword">env</span>:<span class="number">0.0</span>.<span class="number">1</span> . <span class="comment"># t表示镜像名称，版本号 .是指当前路径中的dockerfile</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="docker中常用命令"><a href="#docker中常用命令" class="headerlink" title="docker中常用命令"></a>docker中常用命令</h2><ul>
<li><p>拉取一个docker命令</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker pull 镜像名字</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建一个docker</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> -d -it --name my-ubuntu -v $(<span class="built_in">pwd</span>):/root ubuntu /bin/bash <span class="comment"># v后面是挂在路径，前面是主机路径，后面是docker容器内的路径</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="目前存在的问题"><a href="#目前存在的问题" class="headerlink" title="目前存在的问题"></a>目前存在的问题</h2><ol>
<li>打包出的镜像将近300m。比较大</li>
<li>run的时候执行</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>dockerfile参考<a href="https://www.cnblogs.com/ityouknow/p/8595384.html" target="_blank" rel="noopener">https://www.cnblogs.com/ityouknow/p/8595384.html</a></li>
<li>dockerfile参考 <a href="https://segmentfault.com/a/1190000007875949" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007875949</a></li>
<li>找不到npm的问题： <a href="https://askubuntu.com/questions/720784/how-to-install-latest-node-inside-a-docker-container" target="_blank" rel="noopener">https://askubuntu.com/questions/720784/how-to-install-latest-node-inside-a-docker-container</a></li>
<li>docker build命令解析：<a href="https://zhuanlan.zhihu.com/p/38144369" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/38144369</a></li>
<li>前端环境构建： <a href="https://juejin.im/post/5b127087e51d450686184183" target="_blank" rel="noopener">https://juejin.im/post/5b127087e51d450686184183</a></li>
</ol>
]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>compose-函数链式执行</title>
    <url>/2019/07/17/use-compose-chain-functions/</url>
    <content><![CDATA[<h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><p>使用Array.prototype.reduce，将一组函数链式执行。比如<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const chain = compose(a,b,c)</span><br><span class="line">chain();</span><br></pre></td></tr></table></figure></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><a id="more"></a>
<p>我们有一组函数a,b,c，要变成依次调用，只需要a(b(c()))就可以。</p>
<p>但是，如果有多个函数，总不能光明正大的写出来调用吧。在js中可以通过将函数作为一个参数传递，毕竟回调函数。我们能不能把这一组函数变成a(b())的形式。</p>
<h3 id="reduce的执行顺序"><a href="#reduce的执行顺序" class="headerlink" title="reduce的执行顺序"></a>reduce的执行顺序</h3><p>reduce函数，原意是用在数组中，将之前的返回的结果作为下次的运行的参数。以mdn的例子(<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#reduce(" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#reduce()_如何运行</a>_%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C))<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].reduce(<span class="function"><span class="keyword">function</span>(<span class="params">accumulator, currentValue, currentIndex, array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> accumulator + currentValue;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>调用顺序</p>
<table>
<thead>
<tr>
<th>callback</th>
<th>acc</th>
<th>cur value</th>
<th>cur index</th>
<th>array</th>
<th>return value</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<p>first call | 0 | 1 | 1 | [0, 1, 2, 3, 4] | 1 |<br>second call | 1 | 2 | 2 | [0, 1, 2, 3, 4] | 3 |<br>third call | 3 | 3 | 3 | [0, 1, 2, 3, 4] |6 |<br>fourth call | 6 | 4 | 4 | [0, 1, 2, 3, 4] | 10 |</p>
<p>reduce的执行是给定一个函数，将所有的元素传入这个函数，每次函数的执行结果作为下一次的执行参数。如果没有给定初始值，第一次传入的是第一个和第二个元素。</p>
<p>假设现在有a,b,c三个函数，<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'a'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'b'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// console.log(n)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'c'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最简单的使用</p>
<pre><code>[a,b,c].reduce((a,b)=&gt;a(b()));
</code></pre><p>是什么结果呢？<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">b</span><br><span class="line">a</span><br><span class="line">c </span><br><span class="line">TypeError: a is not a <span class="keyword">function</span></span><br><span class="line">    at chain.reduce (d:\workspace\learn\compose.js:12:39)</span><br><span class="line">    at Array.reduce (&lt;anonymous&gt;)</span><br><span class="line">    at Object.&lt;anonymous&gt; (d:\workspace\learn\compose.js:12:23)</span><br><span class="line">    at Module._compile (internal/modules/cjs/loader.js:773:14)</span><br><span class="line">    at Object.Module._extensions..js (internal/modules/cjs/loader.js:787:10)</span><br><span class="line">    at Module.load (internal/modules/cjs/loader.js:653:32)</span><br><span class="line">    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)</span><br><span class="line">    at Function.Module._load (internal/modules/cjs/loader.js:585:3)</span><br><span class="line">    at Function.Module.runMain (internal/modules/cjs/loader.js:829:12)</span><br><span class="line">    at startup (internal/bootstrap/node.js:283:19)</span><br></pre></td></tr></table></figure></p>
<p>这里出错了，是什么原因呢？</p>
<p>第一次循环，实际执行是a(b()),先执行b，在执行a。所以打印b, a。第二次循环，之前的返回是一个函数执行，b执行完之后的结果作为参数传入a，a执行完之后返回undefined，所以此时a就是undefined。所以实际执行就是undefined(c())。</p>
<p>可以看出是第一次没有返回值导致的错误。所以关键是在这个执行的函数中。</p>
<h3 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h3><p>上面的问题主要有</p>
<ol>
<li>我们不知道a是否返回，我们也不可能去修改a中的代码，所以就有调用undefined方法的情况。</li>
<li>上面的执行顺序也是不对的。</li>
</ol>
<p>解决办法其实就是在用一个函数包裹一下，作为返回值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const chain = [a,b,c,d].reduce((a,b)=&gt;()=&gt;a(b()))</span><br></pre></td></tr></table></figure></p>
<p>测试一下，非常完美。</p>
<ol>
<li>第一次执行，输入的是a,b。然后返回一个函数，()⇒(a(b())。我们把这个匿名函数叫做acc1。</li>
<li>第二次执行，输入的是acc1,c。然后返回一个函数()⇒(acc1(c())。</li>
<li><p>最后这个chain就是这个样子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> acc1(c());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后执行一次chain()就万事大吉。</p>
</li>
</ol>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>既然使用闭包，就会有内存泄露的风险。</p>
<p>在reduce中，其实是将a,b,c,d这些函数不断包裹在外层包裹闭包。所以对函数要有限制。</p>
<p>一般v8中的stack的大小为1M左右。根据每个函数的占用字节，就可以算出一共多少函数。</p>
<h2 id="reduce里面发生了啥"><a href="#reduce里面发生了啥" class="headerlink" title="reduce里面发生了啥"></a>reduce里面发生了啥</h2><p>reduce是一次函数遍历。我们可以通过他的pollyfill来大致了解一下<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Polyfill" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Polyfill</a><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> o) &#123;</span><br><span class="line">          value = callback(value, o[k], k, o);</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br></pre></td></tr></table></figure></p>
<p>比较关键的几行就是这里。将数组里面所有元素遍历，然后每次执行的结果记住，最后将结果返回。</p>
<h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>前文就是理清reduce中的执行过程。那么在实际使用中还要哪些呢？</p>
<ol>
<li>参数的传递</li>
</ol>
<p>实际中每个处理的函数需要接收参数,参照一下redux中设计 <a href="https://github.com/reduxjs/redux/blob/master/src/compose.js" target="_blank" rel="noopener">https://github.com/reduxjs/redux/blob/master/src/compose.js</a><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除此之外， mdn也有类似的实现<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> pipe = <span class="function">(<span class="params">...functions</span>) =&gt;</span> input =&gt; functions.reduce(</span><br><span class="line">    (acc, fn) =&gt; fn(acc),</span><br><span class="line">    input</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>具体使用都是一样的。</p>
]]></content>
  </entry>
  <entry>
    <title>github pages使用简介</title>
    <url>/2019/07/16/github-pages-introduction/</url>
    <content><![CDATA[<p>使用github托管代码，有时候需要展示一个简单的demo页面，如果专门为此维护一个demo网页，成本有点高，而且demo和代码分离，也不利于查阅。幸好github推出了一个github pages的服务。<br><a id="more"></a></p>
<h2 id="啥是github-pages"><a href="#啥是github-pages" class="headerlink" title="啥是github pages"></a>啥是github pages</h2><p>官方介绍中，GitHub pages是一个静态网页托管服务。说白了，就是github给我们分配一个域名，将我们代码库中的文件作为一个静态文件，我们就可以通过http访问。</p>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>使用非常简单。可以选择发布master分支或者gh-pages分支。</p>
<ol>
<li>在仓库中选择setting</li>
</ol>
<p><img src="./Untitled-431b3498-2d7a-41c5-b502-dd3f414375a0.png" alt=""></p>
<ol start="2">
<li>在github pages部分选择master或者gh-pages分支，之后页面中会提示可以访问的地址。除此之外，还可以选择master分支下的docs跟目录作为托管的目录。道理都是相通的。</li>
</ol>
<p><img src="./Untitled-c2e4692b-a9da-496e-8bc1-063295600b1b.png" alt=""></p>
<ol start="3">
<li>然后的浏览器中输入这个地址就可以了。一般来说是用户名+github.io+仓库名。默认打开页面是readme文件。当然也可以输入xxx.html来显示同级目录下的不同页面。</li>
</ol>
<h2 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h2><ol>
<li>这玩意可以做什么？</li>
</ol>
<ul>
<li>项目代码的示例</li>
<li>个人博客，jeklly, hexo, hugo都是在基于此玩的花活。</li>
</ul>
<p>参考资料：</p>
<p>官方文档：<a href="https://help.github.com/en/articles/configuring-a-publishing-source-for-github-pages#enabling-github-pages-to-publish-your-site-from-master-or-gh-pages" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
  </entry>
  <entry>
    <title>pip设置代理</title>
    <url>/2019/06/12/pip-proxy/</url>
    <content><![CDATA[<h2 id="pip代理"><a href="#pip代理" class="headerlink" title="pip代理"></a>pip代理</h2><p>pip是python的包管理工具.由于某些原因, 会导致下载的包过慢或者无法下载.</p>
<p>如何让pip走本地的代理进行下载呢, 下面给出两种情况.</p>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>在自己的电脑搭建了ss代理</p>
<h3 id="未使用sudo"><a href="#未使用sudo" class="headerlink" title="未使用sudo"></a>未使用sudo</h3><p>一般情况(没有sudo),使用ss+proxifier可以直接走代理,具体速度可以在proxifer中查看</p>
<h3 id="显示指定proxy"><a href="#显示指定proxy" class="headerlink" title="显示指定proxy"></a>显示指定proxy</h3><p>命令如此<code>pip3 --proxy 127.0.0.1:&lt;本地http代理的端口&gt; install &lt;包的名字&gt;</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.logcg.com/archives/1914.html" target="_blank" rel="noopener">https://www.logcg.com/archives/1914.html</a></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>svelte初探</title>
    <url>/2019/05/26/svelte%E5%88%9D%E6%8E%A2/</url>
    <content><![CDATA[<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>web前端轮子越来越多,最近发现一个好玩的,叫做svelte.本文主要介绍了svelte的特点,尝试解释其中的原理,与vue做了比较.<br><a id="more"></a><br><img src="svelte-title.png" alt=""></p>
<h1 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h1><p>web前端的技术迭代很快,各种轮子层出不穷.目前的处于统治地位的var(vue,react,angular),主要有使用组件化、虚拟dom等技术,在生产环境中会加载框架的运行时代码.而且,前端技术的发展,各种各样的轮子层出不穷,甚至有一个vanilla.js的框架出现,专门嘲讽目前的这种风气.</p>
<p>svelte也是一个轮子,他最吸引我的地方在于将自己定位为一个编译器,在编译阶段将代码转换为原生的js, 而且放弃了虚拟dom.在响应式方面, 自己做了更多的工作,我的感受是默认的变量都是响应式的.</p>
<h1 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h1><p>本部分主要来自官方的tutorial的总结.花了一天时间跑了所有的例子,有些感想一起放在下面.</p>
<h2 id="初感受"><a href="#初感受" class="headerlink" title="初感受"></a>初感受</h2><ul>
<li>{}绑定数据,包括html标签中的属性绑定<br>没有vue中引入的template和react的jsx的语法,一切与原生写法都很类似.数据默认就是响应式的,在html中直接使用{}就可以拿到js中定义的数据.当然数据的作用范围是在组件内.{}类似模版的语法,可以执行一些简单的js逻辑.这一部分还是比较符合现在的潮流.</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">let</span> name = <span class="string">'world'</span>;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;name.toUpperCase()&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><ul>
<li>默认响应式<br>默认的变量都是响应式的,通过{}获取的数值会自动更新</li>
<li>更简单的computed<br>使用$就可以<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$: if (count &gt;= 10) &#123;</span><br><span class="line">  alert(`count is dangerously high!`);</span><br><span class="line">  count = 9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>比如将上面看作在一个函数中,和vue就几乎没什么区别.(笑哭)</p>
<ul>
<li>只有赋值才会引起数据响应式<br>这是个比较蛋疼的地方.特别的对于数组或者对象,改变了其中一个元素或者属性,并不会引起数据的响应式变化.官方的例子中给出了<code>numbers = [...numbers, numbers.length + 1];</code>这样强行赋值的写法.但是不符合常理.搜索一圈git发现果然已经有人给出了方法的封装(<a href="https://github.com/dasmikko/svelte-array-helper)" target="_blank" rel="noopener">https://github.com/dasmikko/svelte-array-helper)</a>.<br>应该是svelte处于性能的考虑, 只对对象的引用(指针)做了比较.</li>
</ul>
<h2 id="子组件传值"><a href="#子组件传值" class="headerlink" title="子组件传值"></a>子组件传值</h2><p>这里是第一个不太适应的地方,在子组件中,通过export自己的属性名字,在父组件中拿到这个名字,然后传值.这样是将子组件暴露给父组件,这样貌似没有props传值更加让人舒服.</p>
<p>数据流向也是top-down.父组件修改后会引起子组件的重新渲染,反之不会.</p>
<h2 id="更加贴近模板的语法"><a href="#更加贴近模板的语法" class="headerlink" title="更加贴近模板的语法"></a>更加贴近模板的语法</h2><p>如果使用过html模板,对这一部分应该挺熟悉.比如下面:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;#if user.loggedIn&#125;</span><br><span class="line">	&lt;button on:click=&#123;toggle&#125;&gt;</span><br><span class="line">		Log out</span><br><span class="line">	&lt;/button&gt;</span><br><span class="line">&#123;/if&#125;</span><br></pre></td></tr></table></figure></p>
<p>简直就是v-if的翻版.只能说, 真香!</p>
<h2 id="事件和vue更像"><a href="#事件和vue更像" class="headerlink" title="事件和vue更像"></a>事件和vue更像</h2><p>只能说这种语法和许多框架大同小异.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button on:click|once=&#123;handleClick&#125;&gt;</span><br><span class="line">	Click me</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure></p>
<p>通过on绑定事件,然后添加once的限制.和vue中添加“.”的语法简直一模一样嘛.</p>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>有四个钩子函数,分别对应创建,销毁,更新前,更新后</p>
<h2 id="动画和样式"><a href="#动画和样式" class="headerlink" title="动画和样式"></a>动画和样式</h2><p>这个是svelte自己实现的一些语法糖.语法有点怪怪的.个人感觉还是原生的css写的更方便.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本来想写一个详细入门攻略, 结果变成一个tutorial的个人记录.</p>
<h1 id="之后"><a href="#之后" class="headerlink" title="之后"></a>之后</h1><p>svelte确实是一个与var思路不同的轮子.</p>
<p>对于他的生态,官方给出了一个sapper的框架,集合了路由的功能.对国内使用,还需要一个通用的组件库,类似antd和element.</p>
<p>用的人比较少,踩的坑比较少.</p>
<p>另外, 希望能够支持typescript.官方说了会支持, 但是不知道什么时候.</p>
<p>对于vue的底层原理了解不透彻,所以也无法从更深层次比较两个轮子.之后还会继续关注这个(又挖了一个坑…)</p>
<p>另外,svelte默认用rollup打包,本着折腾的思路,用rollup打包了vue的项目,比较一下打包之后的文件.这个留在之后再说.</p>
]]></content>
  </entry>
  <entry>
    <title>运行snabbdom的示例</title>
    <url>/2019/04/02/%E8%BF%90%E8%A1%8Csnabdom%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h2 id="1-Abstract"><a href="#1-Abstract" class="headerlink" title="1. Abstract"></a>1. Abstract</h2><p>本文介绍如何运行snabbdom的示例。<br><a id="more"></a></p>
<h2 id="2-Introduction"><a href="#2-Introduction" class="headerlink" title="2. Introduction"></a>2. Introduction</h2><p>vue的Virtual DOM是基于snabbdom。所以，要了解vue，先了解snabbdom也有必要。</p>
<h2 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3. 环境配置"></a>3. 环境配置</h2><p>这一部分其实是本文的重点。因为snabbdom的开发年代相距想在（2019.04）比较久远。而且snabbdom是用typescript开发的，比JavaScript的上手难度要大一点。</p>
<h3 id="3-1-配置babel"><a href="#3-1-配置babel" class="headerlink" title="3.1 配置babel"></a>3.1 配置babel</h3><p>babel是一个代码转换工具，不同的版本各有差异。如果直接使用现在的版本，编译之前的代码，会有莫名其妙的错误，所以考虑使用使用sanbbdom时代的babel<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-preset-es2015</span><br><span class="line">echo &apos;&#123; &quot;presets&quot;: [&quot;es2015&quot;] &#125;&apos; &gt; .babelrc //这俩不用纠结，直接安装</span><br><span class="line">npm install --save-dev babelify // 我当前的（2019-03-05）是babel10. 不能用</span><br><span class="line">npm uninstall babelify //卸载</span><br><span class="line">npm install babelify@8 // 按照提示</span><br><span class="line">npm install babel-core // 按照提示</span><br></pre></td></tr></table></figure></p>
<h2 id="4-编译代码"><a href="#4-编译代码" class="headerlink" title="4. 编译代码"></a>4. 编译代码</h2><p>研究一下package.json中的命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;compile&quot;: &quot;npm run compile-es &amp;&amp; npm run compile-commonjs&quot;,</span><br><span class="line">&quot;compile-es&quot;: &quot;tsc --outDir es --module es6 --moduleResolution node&quot;, // es6的模块语法</span><br><span class="line">&quot;compile-commonjs&quot;: &quot;tsc --outDir ./commonjs&quot;,  // 用于在浏览器中require引用</span><br><span class="line">&quot;prepublish&quot;: &quot;npm run compile&quot;,</span><br></pre></td></tr></table></figure></p>
<p>为了配合example中的require，使用<code>npm run compile-commonjs</code>。编译完之后，代码结构如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── commonjs //刚刚生成的文件</span><br><span class="line">├── dist </span><br><span class="line">├── es // 执行 npm run compile-es生成的文件</span><br><span class="line">├── examples</span><br><span class="line">├── package-lock.json</span><br><span class="line">├── package.json</span><br><span class="line">├── src</span><br></pre></td></tr></table></figure></p>
<h2 id="5-示例使用"><a href="#5-示例使用" class="headerlink" title="5. 示例使用"></a>5. 示例使用</h2><h3 id="5-1-新的示例"><a href="#5-1-新的示例" class="headerlink" title="5.1 新的示例"></a>5.1 新的示例</h3><p>以下是对示例代码稍作修改生成的示例：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> snabbdom = <span class="built_in">require</span>(<span class="string">'../../commonjs/snabbdom.js'</span>);</span><br><span class="line"><span class="keyword">var</span> patch = snabbdom.init([</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'../../commonjs/modules/class'</span>).default, <span class="comment">// makes it easy to toggle classes</span></span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'../../commonjs/modules/props'</span>).default, <span class="comment">// for setting properties on DOM elements</span></span><br><span class="line">]);</span><br><span class="line"><span class="keyword">var</span> h = <span class="built_in">require</span>(<span class="string">'../../commonjs/h'</span>).default; <span class="comment">// helper function for creating vnodes</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> container = <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> vnode = h(<span class="string">'div#container.two.classes'</span>,  [</span><br><span class="line">    h(<span class="string">'span'</span>, <span class="string">'This is bold '</span>),</span><br><span class="line">    <span class="string">' and this is just normal text'</span>,</span><br><span class="line">    h(<span class="string">'a'</span>,  <span class="string">"I'll take you places!"</span>)</span><br><span class="line">  ]);</span><br><span class="line">  <span class="comment">// Patch into empty DOM element – this modifies the DOM as a side effect</span></span><br><span class="line">  patch(container, vnode);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="5-2-示例编译"><a href="#5-2-示例编译" class="headerlink" title="5.2 示例编译"></a>5.2 示例编译</h3><p>利用babel将require的库文件编译为一个文件使用。找到一个这样的<a href="https://github.com/snabbdom/snabbdom/issues/263" target="_blank" rel="noopener">关于如何编译的github的issue</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">§ ./node_modules/.bin/browserify examples/carousel-svg/script.js -t babelify -o examples/carousel-svg/build.js //我的browserify没有全局安装</span><br></pre></td></tr></table></figure></p>
<p>之后在HTML文件中直接引入编译好的build.js文件就可以啦。</p>
<h2 id="6-summary"><a href="#6-summary" class="headerlink" title="6. summary"></a>6. summary</h2><p>主要记录了在学习snabbdom源码中遇到的babel版本及代码编译的问题。</p>
<h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><ol>
<li><a href="https://github.com/snabbdom/snabbdom/issues/263" target="_blank" rel="noopener">关于如何编译的github的issue</a></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>snabbdom</tag>
      </tags>
  </entry>
  <entry>
    <title>『构建之道』的读书报告</title>
    <url>/2019/02/24/%E3%80%8E%E6%9E%84%E5%BB%BA%E4%B9%8B%E9%81%93%E3%80%8F%E7%9A%84%E8%AF%BB%E4%B9%A6%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="本书的简单介绍"><a href="#本书的简单介绍" class="headerlink" title="本书的简单介绍"></a>本书的简单介绍</h1><p>最近十多年来，软件产业和互联网产业的迅猛发展，给众多计算机和软件专业的学生们提供了用武之地，同时也对大学软件工程的教育提出了很大的挑战。经典的软件工程理论和模式虽然仍有其价值，但是国外的教师和业界人士一直在探索新的理论和最佳实践。『构建之道』的作者是微软亚洲研究院的邹欣，在总结了自己的『做中学』的教学思想，在经过在清华，北航等学校的教学实践之后，总结出的这本书。</p>
<p>与学校里面一些传统的软件工程理论课程不同，这本书注重教学与实践的结合。并且特别注意和现在公司的工程实践结合。一本开始学习软件工程，可能是按照经典的瀑布模型，从需求分析，架构设计，系统实现，再到测试，以及最后的发布，和维护。这是一个正常的软件生命周期过程。但是在学生踏入职场的时候，最可能接触的并不是这些。可能先是维护一些现有的模块，修改小的bug，测试，重构，然后上线。然后逐渐接触大的模块，设计，实现，测试，上线。最后，等到一个学生，真正蜕变为一个合格的员工，才可能按照瀑布模型经历一次软件开发过程。这种从瀑布尽头一步一步上溯到源头，然后从源头流下去的模型，可以成为大马哈鱼模型。<br><a id="more"></a></p>
<h1 id="本书的主要内容"><a href="#本书的主要内容" class="headerlink" title="本书的主要内容"></a>本书的主要内容</h1><p>本书的目录结构编排非常有意思。从之前提到的大马哈鱼洄游模型可以看到，一开始接触到的软件开发，并不是一泻千里的瀑布模型，而是只有自己的。所以一上来，就是从一个软件开发者的角度切入：个人技术，软件工程师的成长。然后才是逐渐扩展，四五章将的就是从小范围与其他软件开发者交流，比如结对编程，代码复审，到整个团队的建设，结构。然后才是需求分析，软件的设计与实现，软件的质量保证，最后是发布。中间穿插了项目经理是什么，敏捷开发流程，与终端用户相关的用户体验，已经对整个IT行业的思考，最后则是作者在实际中碰到的，比如如何评估绩效，软件工程师的道德观念等实际存在，但是教科书中一般不会提及的内容。</p>
<p>这里主要记录我在阅读过程中遇到的比较有感触的地方。</p>
<h2 id="关于『1-1-软件-程序-软件工程』"><a href="#关于『1-1-软件-程序-软件工程』" class="headerlink" title="关于『1.1　软件=程序+软件工程』"></a>关于『1.1　软件=程序+软件工程』</h2><p>从数据结构的第一课，我们就听说『程序=数据结构+算法』，但是，我们自己在学校中写出的小小的代码，与公司中的产出代码非常不同。而且我们自己写的代码，也几乎没有信心放到生产环境中调试。这应该是一个软件专业学生和一个软件工程师很大的不同。</p>
<p>作者提出的这个观点，软件其实，按照软件工程的流程实现的代码。与自己在学校随心所欲的代码不同。这是符合工程化的代码。</p>
<p>另外，更大一步，商业模式决定了一个软件公司的成败，软件企业=软件+商业模式。</p>
<p>从我们底层的角度，微软的操作系统+贩卖授权的模式，成就了微软。qq，免费使用，但是一些更高级的功能，需要额外收费；一些开源软件，个人可以免费使用，但是公司使用需要授权，比如docker。所以，一个公司的成功，很大一方面和公司的商业模式有关系。</p>
<h2 id="关于『2-2效能分析工具』"><a href="#关于『2-2效能分析工具』" class="headerlink" title="关于『2.2效能分析工具』"></a>关于『2.2效能分析工具』</h2><p>作为一个以前端开发为生的程序猿，性能是一个羞于启齿，不愿谈论的话题。我觉得主要有这几个方面：</p>
<ul>
<li>js作为一个弱类型的、解释性的语言，就是慢。</li>
<li>js就是一个在浏览器中负责点击表单，显示对话框的脚本语言，不需要多么强的性能。</li>
<li>nodejs不是前端的吗？（by 后端同学）</li>
</ul>
<p>这一节的书中以一个词汇频率计数的代码为例子，使用抽样（Sampling）或者代码注入（Instrumentation）两种方式，分析程序的调用栈，计算每个函数的运行时间和调用次数。比如这个例子<img src="analize.png" alt=""></p>
<p>在Chrome的devTools中也有火焰图，可以实现类似的功能，查看函数的消耗时间比例。对于页面来说，还可以查看画面的帧数。</p>
<h2 id="关于『3-2软件工程师的职业发展』"><a href="#关于『3-2软件工程师的职业发展』" class="headerlink" title="关于『3.2软件工程师的职业发展』"></a>关于『3.2软件工程师的职业发展』</h2><p>很多对于软件工程师的职级评价，就前端而言，干过三年，就可以号称高级。我觉得这个表格是值得参考的。<br><img src="职级.png" alt=""></p>
<h1 id="个人感悟和总结"><a href="#个人感悟和总结" class="headerlink" title="个人感悟和总结"></a>个人感悟和总结</h1><p>作为一个开发软件的人，不能只是学会写代码，还要有一点世界的认知。对于软件工程的理解，这是随着不断的工作深入的。虽然是，软件工程没有『银弹』，但是总会有不断进步的技术出现，使得软件工程不断发展。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] <a href="http://www.cnblogs.com/xinz" target="_blank" rel="noopener">『构建之道』作者的博客</a></p>
]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/01/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br>测试页面!!!<br>刚刚从jekyll迁移过来, 需要继续修改</p>
]]></content>
  </entry>
  <entry>
    <title>google xss game 通关攻略</title>
    <url>/2019/01/12/google-xss-game/</url>
    <content><![CDATA[<!-- # google的xss游戏通关攻略 -->
<h2 id="『第一关』"><a href="#『第一关』" class="headerlink" title="『第一关』"></a><a href="https://xss-game.appspot.com/level1" target="_blank" rel="noopener">『第一关』</a></h2><p>第一关是个非常脆弱的反射性xss攻击。向url或者form表单中注入xss代码都可以实现攻击。把下面的俩例子粘贴到表单中，点击搜索按钮：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">"alert('xss')"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">"xss"</span>);</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>如果把上面的俩例子注入到url中，点击go按钮（这个按钮是这个假浏览器的一部分），攻击可以生效。唯一的限制就是，如果拼接到url后面代码中包含一个分号，是不会起作用的。上面的第二个例子中，也可以省略分号，因为这script脚本只有一行。</p>
<p>但是，如果把分号用url编码成<code>%3B</code>,然后注入到url中，也可以攻击生效。注意，还需要在攻击代码之前添加<code>?query=</code>。因此就是连接下面三个片段：</p>
<ol>
<li><code>https://xss-game.appspot.com/level1/frame</code></li>
<li><code>?query=</code></li>
<li><code>&lt;script&gt;alert(&quot;xss&quot;)%3B&lt;/script&gt;</code></li>
</ol>
<p>那么完整的url就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://xss-game.appspot.com/level1/frame?query=&lt;script&gt;alert(&quot;xss&quot;)%3B&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h2 id="『第二关』"><a href="#『第二关』" class="headerlink" title="『第二关』"></a><a href="https://xss-game.appspot.com/level2" target="_blank" rel="noopener">『第二关』</a></h2><p>第二关是一个关于存储型的xss攻击。这一关的做了一些过滤，防止你直接注入<code>script</code>标签。但是img标签是可以用的。而img标签允许可以添加一些监听函数（比如可以增加<code>onerror</code>），这里面是包含js代码的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;x&quot; onerror=&quot;alert(&apos;xss&apos;)&quot;&gt;</span><br></pre></td></tr></table></figure>
<p>一旦攻击代码通过表单提交，每次载入这个页面，我们的js代码就可以在用户的浏览器运行–或者任何人–只要他们访问了这个网页。这也是为什么存储型的xss比反射性的危害更大。</p>
<p>我没有找到一个直接向url中注入代码的方法。</p>
<h2 id="『第三关』"><a href="#『第三关』" class="headerlink" title="『第三关』"></a><a href="https://xss-game.appspot.com/level3" target="_blank" rel="noopener">『第三关』</a></h2><p>为了通过第三关，我只能使用Safari (10.0.3)，因为Firefox (51.0.1) and Chrome (55.0.2883.95)都阻止向url中注入一个空格，不管有没有进行url编码。我用下面的url在safari中成功通过第三关。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://xss-game.appspot.com/level3/frame&apos; onerror=&quot;alert(&apos;xss&apos;)&quot;</span><br></pre></td></tr></table></figure></p>
<p>但我还是想用firefox通过。所以我拷贝了safari中叫做level3的cookie。我做了一下的步骤：</p>
<ol>
<li>我设置safari使用Burp proxy。</li>
<li>我用上面的方法通过第一关和第二关。</li>
<li>我用上面的添加了攻击代码的url访问访问第三关。当alert()弹出的时候，游戏就会设置一个叫做level3的cookie。</li>
<li>我复制了这三个cookie <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">level1=f148716ef4ed1ba0f192cde4618f8dc5; level2=b5e530302374aa71cc3028c810b63641; level3=d5ce029d0680b3816a349da0d055fcfa;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>下面的代码是如何在火狐和chrome的开发者工具的console窗口设置新的cookie<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.cookie=&quot;level3=d5ce029d0680b3816a349da0d055fcfa&quot;;</span><br></pre></td></tr></table></figure></p>
<p>现在就可以在火狐或者Chrome中进入下一关。不像那个由这个游戏设置的cookie，我们自己手动设置的cookie在此次回话结束后就过期。所以，如果你现在关闭<code>xss- game.appspot.com</code>的标签页，再重新打开这个网页，就会发现无法到第四关。这是因为第三关的cookie在刚才回话结束后就失效了。因此，最好的办法是手动给cookie设置过期时间的<code>expire</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.cookie=&quot;level3=d5ce029d0680b3816a349da0d055fcfa;expires=&apos; Fri, 22 July 2022 5:34:56 GMT&apos;&quot;;</span><br></pre></td></tr></table></figure>
<p>也可以像这样设置cookie的其他属性，这里关于<code>document.cookie</code><a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie" target="_blank" rel="noopener">说明</a>非常详细。</p>
<p>组装img的代码， 如果我使用单引号提前截断，就可以注入<br><a href="https://xss-game.appspot.com/level3/frame#1&#39;" target="_blank" rel="noopener">https://xss-game.appspot.com/level3/frame#1&#39;</a> onerror=”alert(1)”/&gt;</p>
<h2 id="『第四关』"><a href="#『第四关』" class="headerlink" title="『第四关』"></a>『第四关』</h2><p>我没做出来。我谷歌了一些答案，但是并没有得到预期的结果。最终，我发现，在这三个浏览器中，如果你把下面的字符串输入到表单中，然后点击「create button」按钮，它是可以生效的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;);alert();var b=(&apos;</span><br></pre></td></tr></table></figure></p>
<p>但是，要想直接注入url中使攻击生效，你必须对攻击的字符串进行url编码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%27%29%3Balert%28%29%3Bvar+b%3D%28%27</span><br></pre></td></tr></table></figure></p>
<p>有很多网站可以替你做这些。但是他们有bug，不可信。最近，我开始使用一个在python2.7在默认包含的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> urllib</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = <span class="string">"');alert();var b=('"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>urllib.quote_plus(foo)</span><br><span class="line"><span class="string">'%27%29%3Balert%28%29%3Bvar+b%3D%28%27'</span></span><br></pre></td></tr></table></figure>
<p>记住，在变量的赋值中，用双引号包裹攻击字符串。也不要忘记，移除python在输出结果外边的单引号。在python3中有轻微的不同。我在StackExchange.com的一个<a href="http://stackoverflow.com/a/9345102" target="_blank" rel="noopener">答案</a>中学到了这个。</p>
<p>与第一关中的url拼接类似，我们需要向攻击的字符串中添加合适的变量名，以及在变量名之前添加<code>?</code>和变量名之后添加<code>=</code>。也就是说连接下面的几个部分:</p>
<ol>
<li><code>https://xss-game.appspot.com/level4/frame</code></li>
<li><code>?timer=</code></li>
<li><code>%27%29%3Balert%28%29%3Bvar+b%3D%28%27</code></li>
</ol>
<p>这样可以得到：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://xss-game.appspot.com/level4/frame?timer=%27%29%3Balert%28%29%3Bvar+b%3D%28%27</span><br></pre></td></tr></table></figure></p>
<p>然后点击这个假的浏览器中的『go』按钮。</p>
<h2 id="『第五关』"><a href="#『第五关』" class="headerlink" title="『第五关』"></a><a href="https://xss-game.appspot.com/level5" target="_blank" rel="noopener">『第五关』</a></h2><p><br>为了通过这一关，需要按照以下的步骤：</p>
<ol>
<li>点击『sign up』链接。</li>
<li><p>在下一页，url会变成这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://xss-game.appspot.com/level5/frame/signup?next=confirm</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   在url中把<code>next</code>的值从<code>confirm</code>变成<code>javascript:alert(1)</code>。</p>
<ol start="3">
<li><p>点击假浏览器中的『go』按钮。点击这个按钮可以改变『Next &gt;&gt;』的<code>href</code>连接的地址。在点击『go』按钮之前，如果把鼠标悬浮到『Next &gt;&gt;』上，目标地址是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://xss-game.appspot.com/level5/frame/confirm</span><br></pre></td></tr></table></figure>
<p>实际中，<code>href</code>的值相对路径连接，只是一个『confirm』。当把『confirm』变成<code>javascript:alert(1)</code>，url就被设置为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://xss-game.appspot.com/level5/frame/signup?next=javascript:alert(1)</span><br></pre></td></tr></table></figure>
<p>此时，点击『go』按钮，把鼠标悬浮到『Next &gt;&gt;』上，目标地址是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript:alert(1)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   用户手动编辑了url后，『href』的链接就变成用户的输入。</p>
<ol start="4">
<li>点击『Next &gt;&gt;』链接，会显示一个弹出框，这个游戏会设置一个新的cookie，显示一个信息框，提示说你可以进入下一关。</li>
</ol>
<p>我认为这个课程是说如果你不能注入标签，你也可以注入在真实的资源标识符前面添加<code>javascript:</code> 。我不得不点击所有四个提示，直到我按照提示4的连接<a href="https://tools.ietf.org/html/draft-hoehrmann-javascript-scheme-00" target="_blank" rel="noopener">this IETF draft</a></p>
<h2 id="『第六关』"><a href="#『第六关』" class="headerlink" title="『第六关』"></a><a href="https://xss-game.appspot.com/level6" target="_blank" rel="noopener">『第六关』</a></h2><p>对于第六关，我得好好找找答案。实际上，这是一个客户端自定义的正则表达式的匹配过滤，这个过滤大小写敏感，过滤掉<code>http</code> or <code>https</code>开头的url。所以，一下是一个成功的url：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://xss-game.appspot.com/level6/frame#HTTPS://xss.rocks/xss.js</span><br></pre></td></tr></table></figure>
<p>我用了一个<a href="http://xss.rocks/" target="_blank" rel="noopener">xss.rocks</a>无害的js文件</p>
<p>我没有猜答案。我查看了源代码，看到在接下来的函数中阻止我注入<code>http</code>或者<code>https</code>.我也没把正则表达式拿来测试。我在 w3scholl.com <a href="http://www.w3schools.com/jsref/tryit.asp?filename=tryjsref_match_regexp2" target="_blank" rel="noopener">“Try It” page</a>测试js<br>字符串的match()方法.</p>
<p>这个函数可以再源代码的57行看到：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This will totally prevent us from loading evil URLs!</span></span><br><span class="line"><span class="keyword">if</span> (url.match(<span class="regexp">/^https?:\/\//</span>)) &#123;</span><br><span class="line">  setInnerText(<span class="built_in">document</span>.getElementById(<span class="string">"log"</span>),</span><br><span class="line">    <span class="string">"Sorry, cannot load a URL containing \"http\"."</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中的正则<code>/^https?:\/\//</code>可以匹配<code>http</code>或者<code>https</code>。如果开发者增加了i标记，这个正则就可以匹配大写或者小写。大小写不敏感的正则是<code>/^https?:\/\//i</code>。</p>
<p>我猜这一关的课主要是告诉你，应该浏览所有的源代码，看看开发者是不是写了客户端过滤的代码，看看他们是不是也犯错误。</p>
]]></content>
      <tags>
        <tag>翻译</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title>jsonp的原理和简单实现</title>
    <url>/2018/12/02/jsonp%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>对于ajax等请求,浏览器有同源策略的限制,但是对于图片,scirpt等没有这个限制.利用这个特点, 把实际的请求放在一个<code>script</code>标签的src中,前端则需要事先定义这个回调函数,并且把回调函数的名字放在url中.; 服务端的api也需要有一点改动,不是直接返回数据,而是返回一个回调函数,包裹返回的数据.<br><a id="more"></a></p>
<h1 id="过程演示"><a href="#过程演示" class="headerlink" title="过程演示:"></a>过程演示:</h1><h2 id="服务端的api实现"><a href="#服务端的api实现" class="headerlink" title="服务端的api实现"></a>服务端的api实现</h2><p>  为了演示跨域, 在本地启动一个服务端api, 在本地的3000端口.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"><span class="keyword">const</span> port = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明: 前端实际发起的请求是 /jsonp/:id?callback=&#123;回调函数的名字&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">app.get(<span class="string">"/jsonp/:id"</span>,(req,res)=&gt;&#123; </span><br><span class="line">  <span class="keyword">const</span> callback = req.query.callback;<span class="comment">//获取url中回调函数的名字</span></span><br><span class="line">  <span class="keyword">const</span> id = req.params.id;</span><br><span class="line">  callback ? res.send(<span class="string">`<span class="subst">$&#123;callback&#125;</span>(<span class="subst">$&#123;id&#125;</span>)`</span>) : res.send(id); <span class="comment">// 返回一个回调函数的调用, 这个回调函数的名字是前端指定的.</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(port, ()=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'start at port:'</span>,port)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>  首先说明一下原理: 通过js构造一个script标签,把要请求的url放在script的src中.</p>
<p>  构造页面,点击jsonp标签发起请求.<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"get()"</span>&gt;</span>jsonp<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'id'</span> <span class="attr">style</span>=<span class="string">"border:1px solid red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>  js代码<br>  为了演示方便,定义一个id.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">idPlus</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 返回一个闭包</span></span><br><span class="line">  <span class="keyword">var</span> id = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> id = idPlus(); <span class="comment">// 为了演示方便增加一个自增的id</span></span><br></pre></td></tr></table></figure></p>
<p>创建一个函数,监听html中的事件.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  jsonp(<span class="string">'http://127.0.0.1:3000/jsonp/'</span>+id(), </span><br><span class="line">    <span class="string">'callback'</span>, </span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>].innerHTML = value;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就是实际封装的jsonp函数.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://127.0.0.1:3000/jsonp/'</span>+(id());</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url, jsonpCallback, success</span>)</span>&#123;</span><br><span class="line">  url = <span class="string">""</span>+url+<span class="string">"?callback="</span>+jsonpCallback; <span class="comment">// 对url进行处理,加上callback</span></span><br><span class="line">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">  script.src = url;</span><br><span class="line">  script.className=<span class="string">"jsonp-script"</span></span><br><span class="line">  <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123; <span class="comment">//将callback加入到window对象中</span></span><br><span class="line">    success &amp;&amp; success(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到此时可以正常访问.<br>当然这段代码还有一个缺点, 每次发起请求的script标签一直存在.可以再回调函数中将script标签删除:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByClassName(<span class="string">'jsonp-script'</span>)[<span class="number">0</span>].parentElement.removeChild(<span class="built_in">document</span>.getElementsByClassName(<span class="string">'jsonp-script'</span>)[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<p><img src="jsonp1.gif" alt=""></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于这些基础的概念, 虽然看文章可以看到,也知道大概的意思.但, 还是要经过代码的检验,才能彻底弄清楚.比如,一直知道前端组装一个script标签可以发起请求, 但是具体如何拿到数据,这个步骤一直没有弄清楚.所以, 纸上得来终觉浅,绝知此事要躬行.<br>另外,还有一些问题:</p>
<ul>
<li>为什么获取script标签只能用get请求?</li>
<li>获取标签的get请求与ajax的get请求有什么不同?</li>
<li>ajax与fetch有什么不同?</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li>主要代码来自这里: <a href="https://yuchengkai.cn/docs/zh/frontend/browser.html#jsonp" target="_blank" rel="noopener">https://yuchengkai.cn/docs/zh/frontend/browser.html#jsonp</a></li>
<li>这篇文章解开了我如何获取数据的疑惑: <a href="https://www.cnblogs.com/chiangchou/p/jsonp.html" target="_blank" rel="noopener">https://www.cnblogs.com/chiangchou/p/jsonp.html</a></li>
<li>本文源码: <a href="https://github.com/tbswang/resources/tree/master/blog/jsonp" target="_blank" rel="noopener">https://github.com/tbswang/resources/tree/master/blog/jsonp</a></li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>git的rebase和merge的区别</title>
    <url>/2018/11/08/git%E7%9A%84rebase%E5%92%8Cmerge%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>git中的merge和rebase的作用是将两个不同分支合并,最终合并得到的代码都是相同的.</p>
<p>区别就是merge是将开辟一个独立的新的commit,将两个分支进行合并到这个新的commit中;而rebase是在当前分支,将另一个分支的更改重做一次,生成一个新的commit.所以说,merge会比rebase多余的一个commit<br><a id="more"></a></p>
<h1 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h1><p>本文主要介绍<code>git merge</code>与<code>git rebase</code>两个命令的不同.</p>
<h1 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h1><h2 id="使用merge的效果"><a href="#使用merge的效果" class="headerlink" title="使用merge的效果"></a>使用merge的效果</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>从代码库获取项目代码:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> xxx.git</span><br></pre></td></tr></table></figure></p>
<p>做一些准备工作: 新建一个test-merge分支.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  test2 git:(master) gcb <span class="built_in">test</span>-merge <span class="comment">#新建一个用来merge分支</span></span><br><span class="line">Switched to a new branch <span class="string">'test-merge'</span></span><br><span class="line">➜  test2 git:(<span class="built_in">test</span>-merge) touch <span class="built_in">test</span>-merge.txt</span><br><span class="line">➜  test2 git:(<span class="built_in">test</span>-merge) ✗ gst</span><br><span class="line">On branch <span class="built_in">test</span>-merge</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">test</span>-merge.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br><span class="line">➜  test2 git:(<span class="built_in">test</span>-merge) ✗ ga .</span><br><span class="line">➜  test2 git:(<span class="built_in">test</span>-merge) ✗ gc -m <span class="string">'test merge'</span></span><br><span class="line">[<span class="built_in">test</span>-merge d4b2b11] <span class="built_in">test</span> merge</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 <span class="built_in">test</span>-merge.txt</span><br></pre></td></tr></table></figure></p>
<p>上图的代码中,在test-merge分支做了修改,提交了一个commit.<br><img src="1-add-test-merge.png" alt=""><br>同理,在master分支也做了相同的处理,修改文件,提交一个commit.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  test2 git:(test-merge) gcm</span><br><span class="line">Switched to branch &apos;master&apos;</span><br><span class="line">Your branch is up to date with &apos;origin/master&apos;.</span><br><span class="line">➜  test2 git:(master) touch master.txt</span><br><span class="line">➜  test2 git:(master) ✗ ga .</span><br><span class="line">➜  test2 git:(master) ✗ gc -m &apos;test master&apos;</span><br><span class="line">[master bddb051] test master</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 master.txt</span><br></pre></td></tr></table></figure></p>
<p>具体的效果如图所示, master分支和test-merge分支各自前进一个commit.<br><img src="2-add-test-master.png" alt=""></p>
<h3 id="使用merge合并的"><a href="#使用merge合并的" class="headerlink" title="使用merge合并的"></a>使用merge合并的</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  test2 git:(master) git merge <span class="built_in">test</span>-merge</span><br></pre></td></tr></table></figure>
<p>此时需要在vim编辑器中输入此次merge的commit信息<br><img src="3-vim-merge.png" alt=""><br>两个分支共同生成一个新的特殊的commit.这个commit记录了来个哪两个分支.具体来说就是<code>d35afed</code>这个commit,比其他的commit多了一个信息,说明是来自<code>bddb051</code>和<code>d4b2b11</code>这两个commit的merge<br><img src="4-merge-graph.png" alt=""></p>
<h2 id="使用rebase的效果"><a href="#使用rebase的效果" class="headerlink" title="使用rebase的效果"></a>使用rebase的效果</h2><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>现在将我们代码场景还原到merge之前.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  <span class="built_in">test</span> git:(master) git <span class="built_in">log</span> <span class="comment"># 查看所有的git commit-id(hash值)</span></span><br></pre></td></tr></table></figure></p>
<p>此时会打开一个vim编辑器<br><img src="5-git-log-merge.png" alt=""><br>找到所有操作之前的commit-id: <code>cd0d50b10406e0f8630aa213acd4b20baeee5919</code><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  test2 git:(master) git reset --hard cd0d50b10406e0f8630aa213acd4b20baeee5919</span><br><span class="line">HEAD is now at cd0d50b master</span><br></pre></td></tr></table></figure></p>
<p>此时,我们的master分支的代码已经回归到了这个commit.另外, 将这个merge分支删去,否则就太乱了.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  test2 git:(master) gb -d <span class="built_in">test</span>-merge </span><br><span class="line">error: The branch <span class="string">'test-merge'</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">'git branch -D test-merge'</span>.</span><br><span class="line">➜  test2 git:(master) gb -D <span class="built_in">test</span>-merge <span class="comment">#git还十分贴心的提醒我删去的这个分支没有merge,情怀~! 所以就是-D 强制删去咯</span></span><br><span class="line">Deleted branch <span class="built_in">test</span>-merge (was d4b2b11).</span><br></pre></td></tr></table></figure></p>
<p><img src="6-git-reset.png" alt=""></p>
<p>一切,又回到了, 最初的起点,呆呆的站在镜子前~, 额 , 跑题了.</p>
<p>之前的套路,<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  test2 git:(<span class="built_in">test</span>-rebase) touch <span class="built_in">test</span>-rebase.txt</span><br><span class="line">➜  test2 git:(<span class="built_in">test</span>-rebase) ✗ ga .</span><br><span class="line">➜  test2 git:(<span class="built_in">test</span>-rebase) ✗ gc -m <span class="string">'test-rebase'</span></span><br><span class="line">[<span class="built_in">test</span>-rebase 35a2896] <span class="built_in">test</span>-rebase</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 <span class="built_in">test</span>-rebase.txt</span><br><span class="line">➜  test2 git:(<span class="built_in">test</span>-rebase) gcm</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line">Your branch is up to date with <span class="string">'origin/master'</span>.</span><br><span class="line">➜  test2 git:(master) touch master.txt</span><br><span class="line">➜  test2 git:(master) ✗ ga .</span><br><span class="line">➜  test2 git:(master) ✗ gc -m <span class="string">'test master'</span></span><br><span class="line">[master cf94c09] <span class="built_in">test</span> master</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 master.txt</span><br></pre></td></tr></table></figure></p>
<p>此时为:<br><img src="7-rebase-prepair.png" alt=""></p>
<h3 id="使用rebase合并"><a href="#使用rebase合并" class="headerlink" title="使用rebase合并"></a>使用rebase合并</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">➜  test2 git:(master) git rebase <span class="built_in">test</span>-rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: <span class="built_in">test</span> master</span><br></pre></td></tr></table></figure>
<p><img src="8-git-rebase.png" alt=""></p>
<p>可以这么理解,在master分支上,将test-rebase分支做的改动重做一次,(感觉类似于数据库的日志重新执行一遍),<code>test-rebase</code>这个commit没有变, 但是原先master分支的<code>test master</code>这个commit对应的代码快照变了,相应的commit-id也不同.</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>这个结论不好写,merge和rebase都有自己的用武之地.</p>
<p>如果说,是在自己本地开发,可以将两个分支rebase到一起,然后push到远端服务器,这样对于后面维护就少了查看不不必要的分支.</p>
<p>如果是在远程合并代码,用merge比较好.可以完整的保留两个人的更改.</p>
<h1 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h1><ul>
<li><p>本文展示的过程中, 没有冲突, 而在实际代码中,解决冲突是经常的事情.对于merge,解决冲突后<code>git commit</code>就可以,而对于rebase,解决冲突后<code>git rebase --continue</code>就可以.</p>
</li>
<li><p>代码中出现的<code>gcm gcl gb</code> 等等是使用的zsh</p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA" target="_blank" rel="noopener">git-scm,讲的非常明白</a></li>
<li><a href="https://www.nowcoder.com/courses/2" target="_blank" rel="noopener">牛客翻译的视频</a></li>
</ul>
]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hyperledger-fabric-ca用户指南(1.0)</title>
    <url>/2018/06/05/hyperledger-fabric-ca%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97(1.0)/</url>
    <content><![CDATA[<h1 id="fabric-ca-的用户指南-1-0版"><a href="#fabric-ca-的用户指南-1-0版" class="headerlink" title="fabric ca 的用户指南(1.0版)"></a>fabric ca 的用户指南(1.0版)</h1><h2 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h2><p>这篇文章是翻译自<a href="https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/" target="_blank" rel="noopener">hyperledger farbric ca</a>的文档。记录了自己实践文档内容过程中，遇到一些问题以及解决办法。相关的内容在<code>注释</code>中</p>
<p>hyperledger fabric ca是一个对hyperledger fabric进行用户授权的组件.</p>
<p>他提供了以下的特性:</p>
<ul>
<li>身份注册,或者连接到ldap作为用户注册中心.</li>
<li>颁发登录证书(ECerts)</li>
<li>颁发交易证书(Tcerts), 当在Hyperledger fabric 区块链中交易的时候, 提供匿名和不可连接的连接.</li>
<li>证书更新和撤回</li>
</ul>
<p>Hyperledger fabric ca 包含服务端和一个客户端, 下文将会描述.</p>
<p>对于贡献Hyperledger fabric ca 的开发者, 可以查看 <a href="https://github.com/hyperledger/fabric-ca" target="_blank" rel="noopener">fabric ca 仓库</a>来查询更多信息.<br><a id="more"></a></p>
<h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p>下图展示了如何把hyperledger fabric ca 服务器放在hyperledger fabric 的整体架构中.</p>
<p><img src="./fabric-ca-arch.png" alt="img"> </p>
<p> 有两个方式与fabric ca服务器端交互:通过fabric ca的客户端或者sdk.所有的与服务端的交互都是通过rest api.可以查看<a href="https://github.com/hyperledger/fabric-ca/blob/release-1.1/swagger/swagger-fabric-ca.json" target="_blank" rel="noopener">fabric-ca/swagger/swagger-fabric-ca.json</a> 这份文档来查看文档化的REST API.</p>
<p> 客户端或者sdk可以连接一个ca服务器端的集群的某一台服务器.上图右上边说明的是这个部分. 客户端使用haproxy代理做负载均衡,连接到fabric ca server的集群中的一个.</p>
<p> 所有的ca服务端共用一个数据库, 来跟踪身份和证书.如果配置了LDAP,用户身份验证信息就会存放在ldap中, 而不是数据库.</p>
<p> 每个服务器可能包含多个ca.每个ca要么是根ca,要么是中间ca.每个中间ca的父节点要么是根ca,要么是一个中间ca.</p>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="预安装"><a href="#预安装" class="headerlink" title="预安装"></a>预安装</h2><ul>
<li>go.x 安装</li>
<li>正确设置环境变量 <code>GOPATH</code></li>
<li>安装libtool 和libtdhl-dev 安装包</li>
</ul>
<blockquote>
<p>注释:</p>
<ul>
<li>如何设置gopath:<a href="https://segmentfault.com/a/1190000003933557" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003933557</a></li>
<li>一般来说, GOPATH的路径是/users/{用户名}/go.里面存储了golang的依赖包和一些可执行命令.依赖包的路径是$GOPATH/src,使用go get命令下载的包, 也是默认存在这里.可执行命令的包一般是在$GOPATH/bin.mac推荐使用homebrew安装</li>
</ul>
</blockquote>
<p>以下的命令是在ubuntu 上安装libtool的依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install libtool libltdl-dev</span><br></pre></td></tr></table></figure>
<p>以下的命令是在macox安装libtool依赖:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install libtool</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明:<br>对于mac,如果使用homebrew安装了libtool, 就不需要再安装libtdl-dev</p>
</blockquote>
<p>关于libtool的信息, 可以查看: <a href="https://www.gnu.org/software/libtool" target="_blank" rel="noopener">https://www.gnu.org/software/libtool</a>.</p>
<p>关于libltdl-dev的信息, 可以查看:<br><a href="https://www.gnu.org/software/libtool/manual/html_node/Using-libltdl.html" target="_blank" rel="noopener">https://www.gnu.org/software/libtool/manual/html_node/Using-libltdl.html</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下面的命令会在会在$GOPATH/bin中安装fabric-ca-server和fabric-ca-client的二进制文件.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get -u github.com/hyperledger/fabric-ca/cmd/...</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注释:<br><code>go get -u</code>是u的意思是升级, 如果包已经在本地, 就不下载,如果没有才下载</p>
</blockquote>
<blockquote>
<p>说明: 如果你clone了fabric-ca 的仓库,在运行go get 命令之前 确保你在master 分支,否则你可能会看到这样的错误:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;gopath&gt;/src/github.com/hyperledger/fabric-ca; git pull --ff-only</span><br><span class="line">There is no tracking information <span class="keyword">for</span> the current branch.</span><br><span class="line">Please specify <span class="built_in">which</span> branch you want to merge with.</span><br><span class="line">See git-pull(1) <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to <span class="built_in">set</span> tracking information <span class="keyword">for</span> this branch you can <span class="keyword">do</span> so with:</span><br><span class="line"></span><br><span class="line">    git branch --<span class="built_in">set</span>-upstream-to=&lt;remote&gt;/&lt;branch&gt; tlsdoc</span><br><span class="line"></span><br><span class="line">package github.com/hyperledger/fabric-ca/cmd/fabric-ca-client: <span class="built_in">exit</span> status 1</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="启动原生的服务器"><a href="#启动原生的服务器" class="headerlink" title="启动原生的服务器"></a>启动原生的服务器</h2><p>这个命令使用默认配置,其中fabric-ca-server<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fabric-ca-server start -b admin:adminpw</span><br></pre></td></tr></table></figure></p>
<p>-b选项 是提供引导管理员用户(fabric中默认存在第一个用户)的登录id和密码.如果在关于ldap的配置中没有使用ldap.enabled设置, 这个选项就是必须的.</p>
<blockquote>
<p> 注释: ldap的作用是接管fabric-ca中用户注册的功能, 所有的fabric-ca的用户都是在ldap中,所以不需要提供引导用户.</p>
</blockquote>
<p>以上操作会创建一份叫做fabric-ca-server-config.yml的文件, 我们可以对这份文件进行定义.</p>
<blockquote>
<p> 注释: 创建的fabric-ca的配置文件一般会在/etc/hyperledger/fabric-ca-server</p>
</blockquote>
<h2 id="使用docker"><a href="#使用docker" class="headerlink" title="使用docker"></a>使用docker</h2><h3 id="docker-hub"><a href="#docker-hub" class="headerlink" title="docker hub"></a>docker hub</h3><p>在 <a href="https://hub.docker.com/r/hyperledger/fabric-ca/tags/" target="_blank" rel="noopener">https://hub.docker.com/r/hyperledger/fabric-ca/tags/</a> 这个网页找到合适的架构和版本的镜像</p>
<p>在$GOPATH/src/github.com/hyperledger/fabric-ca/docker/server 打开docker-compose.yml文件.</p>
<p>把这个配置里面的image选项换成之前相应的标记.下面的文件是给x86架构的beta版本</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">fabric-ca-server:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">hyperledger/fabric-ca:x86_64-1.0.0-beta</span></span><br><span class="line"><span class="attr">  container_name:</span> <span class="string">fabric-ca-server</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"7054:7054"</span></span><br><span class="line"><span class="attr">  environment:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">FABRIC_CA_HOME=/etc/hyperledger/fabric-ca-server</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"./fabric-ca-server:/etc/hyperledger/fabric-ca-server"</span></span><br><span class="line"><span class="attr">  command:</span> <span class="string">sh</span> <span class="bullet">-c</span> <span class="string">'fabric-ca-server start -b admin:adminpw'</span></span><br></pre></td></tr></table></figure>
<p>打开docker-compose.yml文件路径所在一个终端.执行下面的命令:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注释: docker-compose的命令常用的有两个, 一个是<code>docker-compose up</code>, 用户启动docker多容器, 另一个是<code>docker-composer down</code>, 用于关闭docker多容器</p>
</blockquote>
<p>如果指定的fabric-ca镜像不存在, 这会从docker拉取(pull)镜像, 然后开启一个fabric-ca 的服务器的实例.</p>
<h3 id="生成自己的docker镜像"><a href="#生成自己的docker镜像" class="headerlink" title="生成自己的docker镜像"></a>生成自己的docker镜像</h3><p>你可以使用下面的命令, 通过docker-compose 来启动服务器.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$GOPATH</span>/src/github.com/hyperledger/fabric-ca</span><br><span class="line">make docker</span><br><span class="line"><span class="built_in">cd</span> docker/server</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p>
<p>hyperledger/fabric-ca的docker镜像包含了fabric-ca-server和fabric-ca-client<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># cd $GOPATH/src/github.com/hyperledger/fabric-ca</span><br><span class="line"># FABRIC_CA_DYNAMIC_LINK=true make docker</span><br><span class="line"># cd docker/server</span><br><span class="line"># docker-compose up -d</span><br></pre></td></tr></table></figure></p>
<h2 id="浏览cli命令"><a href="#浏览cli命令" class="headerlink" title="浏览cli命令"></a>浏览cli命令</h2><p>这一部分只是简单说明fabric ca 服务端和客户端的使用信息.另外的使用信息在接下来的部分中.</p>
<blockquote>
<p>注释:<br>这部分内容请参考源文档:<a href="https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#explore-the-fabric-ca-cli" target="_blank" rel="noopener">https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#explore-the-fabric-ca-cli</a></p>
</blockquote>
<blockquote>
<p> 说明: 使用字符串分割的命令行选项可以使用逗号分隔符来指定多个命令, 或者多次指定这个选项,每个字符串值来组成一个列表.比如, 为了给csr.host指定host1和host2,你可以传递参数 –csr.host ‘host1,host2’ 或者 -csr.host host1 –csr.host host2. 当使用第一种的时候, 确保在逗号的前面和后面都没有空格.</p>
</blockquote>
<h1 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h1><h2 id="fabric-ca服务器端的配置文件的格式"><a href="#fabric-ca服务器端的配置文件的格式" class="headerlink" title="fabric ca服务器端的配置文件的格式"></a>fabric ca服务器端的配置文件的格式</h2><p>在fabric-ca启动的时候,会在服务端的主目录创建一份默认配置文件.</p>
<blockquote>
<p>注释: 这部分内容查看原文件<a href="https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#fabric-ca-server-s-configuration-file-format" target="_blank" rel="noopener">https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#fabric-ca-server-s-configuration-file-format</a></p>
</blockquote>
<h2 id="ca-客户端的配置文件的格式"><a href="#ca-客户端的配置文件的格式" class="headerlink" title="ca 客户端的配置文件的格式"></a>ca 客户端的配置文件的格式</h2><p>在client端的主目录会创建一份默认的配置文件</p>
<blockquote>
<p>注释: 这部分内容查看原文件<a href="https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#fabric-ca-server-s-configuration-file-format" target="_blank" rel="noopener">https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#fabric-ca-server-s-configuration-file-format</a></p>
</blockquote>
<h1 id="配置文件生效的优先级"><a href="#配置文件生效的优先级" class="headerlink" title="配置文件生效的优先级"></a>配置文件生效的优先级</h1><p>fabric ca提供三种方式来设置fabric ca 服务端和客户端.优先级如下:</p>
<ol>
<li>命令行里面的参数设置</li>
<li>环境变量</li>
<li>配置文件</li>
</ol>
<p>在这个文档后面部分中, 我们修改配置文件.但是,配置文件可能被环境变量和命令行参数覆盖.</p>
<p>比如说, 你有如下的客户端配置文件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tls:</span><br><span class="line">  # Enable TLS (default: false)</span><br><span class="line">  enabled: false</span><br><span class="line"></span><br><span class="line">  # TLS for the client&apos;s listenting port (default: false)</span><br><span class="line">  certfiles:</span><br><span class="line">  client:</span><br><span class="line">    certfile: cert.pem</span><br><span class="line">    keyfile:</span><br></pre></td></tr></table></figure>
<p>下面的环境变量可能会覆盖配置文件中的 cert.pem.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> FABRIC_CA_CLIENT_TLS_CLIENT_CERTFILE=cert2.pem</span><br></pre></td></tr></table></figure>
<p>如果你想覆盖环境变量和配置文件, 你可以使用命令行参数.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fabric-ca-client enroll --tls.client.certfile cert3.pem</span><br></pre></td></tr></table></figure>
<p>同样的方式也适用于fabric-ca-server,除了把环境变量前缀从<code>FABRIC_CA_CLIENT</code>改成<code>FARBIC_CA_SERVER</code>.</p>
<h1 id="关于文件路径的说明"><a href="#关于文件路径的说明" class="headerlink" title="关于文件路径的说明"></a>关于文件路径的说明</h1><p>所有在fabric ca 服务端和客户端的配置文件中关于文件名字的属性,都可以支持相对路径和绝对路径.相对路径是相对于配置文件所在的配置目录.例如, 如果配置文件是在 <code>~/config</code>中,, tls的设置下面所示,那么fabric ca 服务端和客户端会在<code>~/config</code>目录中查找root.pem, 在<code>~/config/certs</code> 这个目录中查找cert.pem, 使用绝对路径在<code>/abs/path</code>中查找key.pem</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tls:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  certfiles:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">root.pem</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    certfile:</span> <span class="string">certs/cert.pem</span></span><br><span class="line"><span class="attr">    keyfile:</span> <span class="string">/abs/path/key.pem</span></span><br></pre></td></tr></table></figure>
<h1 id="fabric-ca-服务器端"><a href="#fabric-ca-服务器端" class="headerlink" title="fabric ca 服务器端"></a>fabric ca 服务器端</h1><p>可以在启动fabric ca 服务器之前初始化,这样就可以在启动服务器之前生成一个服务器的默认配置文件,可以查看和修改.</p>
<p>ca的主文录由下面决定:</p>
<ul>
<li>FABRIC_CA_SERVER_HOME 的环境变量</li>
<li>FABRIC_CA_HOME 环境变量</li>
<li>CA_CFG_PATH 的环境变量</li>
<li>当前的目录</li>
</ul>
<p>下面假设设置的<code>FABRIC_CA_HOME</code>的环境变量的值为<code>$home/fabric-ca/server</code>.</p>
<p>下面的介绍中, 假设服务器端配置文件已经在服务器的主目录中存在.</p>
<h2 id="初始化服务器端"><a href="#初始化服务器端" class="headerlink" title="初始化服务器端"></a>初始化服务器端</h2><p>使用如下命令初始化fabric ca 服务器:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-server init -b admin:adminpw</span><br></pre></td></tr></table></figure></p>
<p>当不使用LDAP的时候, -b这个参数必须要有.为了启动一个fabric ca 服务器, 至少需要一个启动实体.-b 这个参数指定了一个启动的身份.这个用户就是server的管理者.</p>
<p>服务器的配置文件包含了可以配置的证书签名请求部分(csr).下面是一个csr的例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cn: fabric-ca-server</span><br><span class="line">names:</span><br><span class="line">   - C: US</span><br><span class="line">     ST: &quot;North Carolina&quot;</span><br><span class="line">     L:</span><br><span class="line">     O: Hyperledger</span><br><span class="line">     OU: Fabric</span><br><span class="line">hosts:</span><br><span class="line">  - host1.example.com</span><br><span class="line">  - localhost</span><br><span class="line">ca:</span><br><span class="line">   expiry: 131400h</span><br><span class="line">   pathlength: 1</span><br></pre></td></tr></table></figure>
<p>上面所有的部分都属于在x509标准,这个在执行<code>fabric-ca-server init</code>中产生.这些会相应存在于的在server的配置文件ca.certfile和ca.keyfile中.配置文件中的字段含义如下:</p>
<ul>
<li>cn: 公共的名字</li>
<li>O: 组织名称</li>
<li>OU: 组织单位</li>
<li>L:位置或者城市</li>
<li>ST: 状态</li>
<li>C: 国家</li>
</ul>
<p>如果需要自定义csr,需要自定义配置文件,先删除ca.certfile和ca-keyfile,然后再次运行 fabric-ca-server init -b admin:adminpw</p>
<blockquote>
<p>注释:<br>第一次执行fabric-ca-server inti 的时候, 使用默认的配置, 生成了一个ca.certfile和ca-keyfile. 这两个文件是由csr这部分参数生成的.所以, 如果用自己的cn, ou等,就要先把csr改成自己组织的信息, 然后重新生成.生成的证书文件是在<code>/etc/hyperledger/fabric-ca-server-config/org1.example.com-cert.pem</code>这个文件.<br>关键信息是Issuer发证机构和Subject(证书持有者)的cn(common name)<br><img src="server-init-cert.png" alt=""><br>暂时还没弄明白这个证书是用在哪里</p>
</blockquote>
<p>fabric-ca-server会产生一个自签名的ca证书,除非在指定了 -u <parent-fabric-ca-server-url>. 如果指定-u, 服务器的ca证书就会被父级fabric ca 服务器签名.为了收到来自父级的授权,指定的url必须是<code>&lt;scheme&gt;://&lt;enrollmentID&gt;:&lt;secret&gt;@&lt;host&gt;:&lt;port&gt;</code>这种格式.这里的enrollmentID和secret对应于一个用户, 这个用户的‘hf.IntermediateCA的属性值是true.fabric-ca-server init命令还会在server的home目录生成一个叫做fabric-ca-server.yaml的配置文件.</parent-fabric-ca-server-url></p>
<p>如果想要用自己的ca签名证书, 必须把你的文件放到相应的ca.certfile和ca.keyfile文件中.两个文件必须是PEM编码, 而且不能加密.而且, 这个ca证书文件必须又<code>-----BEGIN CERTIFICATE-----</code>开始,秘钥的内容必须<code>-----BEGIN PRIVATE KEY-----</code>开始, 而不能是 <code>-----BEGIN ENCRYPTED PRIVATE KEY-----</code></p>
<h3 id="算法和key的大小"><a href="#算法和key的大小" class="headerlink" title="算法和key的大小"></a>算法和key的大小</h3><p>csr部分可以自定义来生成x.509格式的椭圆曲线法生成的证书和秘钥(ECDSA).下面的设置是一个椭圆曲线法的实现的例子, 使用曲线 prime256v1和签名算法 ecdsa-with-SHA256:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key:</span><br><span class="line">   algo: ecdsa</span><br><span class="line">   size: 256</span><br></pre></td></tr></table></figure></p>
<p>算法和秘钥的选择取决于你的安全需求.<br>椭圆曲线法提供了如下的秘钥大小选项:</p>
<table>
<thead>
<tr>
<th style="text-align:center">大小</th>
<th style="text-align:center">ASN1 OID</th>
<th style="text-align:center">签名算法 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">256</td>
<td style="text-align:center">prime256v1</td>
<td style="text-align:center">ecdsa-with-SHA256</td>
</tr>
<tr>
<td style="text-align:center">384</td>
<td style="text-align:center">secp384r1</td>
<td style="text-align:center">ecdsa-with-SHA384</td>
</tr>
<tr>
<td style="text-align:center">521</td>
<td style="text-align:center">secp521r1</td>
<td style="text-align:center">ecdsa-with-SHA512</td>
</tr>
</tbody>
</table>
<h2 id="开启服务器"><a href="#开启服务器" class="headerlink" title="开启服务器"></a>开启服务器</h2><p>使用如下命令开启服务器:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fabric-ca-server start -b &lt;admin&gt;:&lt;adminpw&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果server之前没有初始化,他会在第一次启动的时候初始化.在初始化的时候,如果ca-pert.pem和ca-key.pem文件不存在, server会产生各自生成一份.如果默认的配置文件不存在,也会生成一份.</p>
<p>除非使用ldap,否则至少一个预先注册的实体来注册和登录其他用户.-b 选项指定了启动实体的名字和密码.</p>
<p>为了监听https而不是http,需要把tls.enable设置为true.</p>
<p>为了限制相同密码登录的次数,registry.maxenrollments设置为合适的数字.如果设置1, 只能登录一次,如果设置-1,可以无限制登录.默认值-1.设置为0,就会禁止任何实体的登录和注册.</p>
<p>fabric-ca-server监听在7054端口</p>
<h2 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h2><p>这一部分描述如何配置连接PostgreSQL or MySQL数据库.默认的数据库是sqlite,默认的数据库文件是fabric-server.db,在home文件夹.</p>
<p>如果不关心在集群中运行服务器,可以跳过这一部分.支持的数据库版本</p>
<ul>
<li>PostgreSQL:.5 或者之后</li>
<li>MySQL:.16 或者之后</li>
</ul>
<h3 id="postgresql"><a href="#postgresql" class="headerlink" title="postgresql"></a>postgresql</h3><p>在server的配置文件中,增加下面的部分,可以连接到postgresql中.确认好要把下面自定义的值合适.关于db名字的有字符的限制.参考这个文件<a href="https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS" target="_blank" rel="noopener">https://www.postgresql.org/docs/current/static/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db:</span><br><span class="line">  type: postgres</span><br><span class="line">  datasource: host=localhost port=5432 user=Username password=Password dbname=fabric_ca sslmode=verify-full</span><br></pre></td></tr></table></figure>
<p>通过sslmode来配置ssl验证的思路.sslmode的有效值是:</p>
<table>
<thead>
<tr>
<th>mode</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>disable</td>
<td>没有ssl</td>
</tr>
<tr>
<td>require</td>
<td>总是ssl(跳过验证)</td>
</tr>
<tr>
<td>verify-ca</td>
<td>总是ssl(验证当前服务器的证书由可信的ca签名)</td>
</tr>
<tr>
<td>verify-full</td>
<td>与verify-ca相同,验证当前的证书由可信的ca签名,并且server的hostname与其中一个证书一致</td>
</tr>
</tbody>
</table>
<p>如果你想使用tls, 必须在fabric ca server 配置文件中指定db.tls部分.如果ssl在postgresql服务器中enbaled, 那么客户端证书和秘钥文件需要在db.tls.client部分指定,下面是一个db.tls部分的例子:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db:</span><br><span class="line">  ...</span><br><span class="line">  tls:</span><br><span class="line">      enabled: true</span><br><span class="line">      certfiles:</span><br><span class="line">        - db-server-cert.pem</span><br><span class="line">      client:</span><br><span class="line">            certfile: db-client-cert.pem</span><br><span class="line">            keyfile: db-client-key.pem</span><br></pre></td></tr></table></figure></p>
<p>certfiles: 一系列经过pem编码的可信 的根证书文件<br>certfile和keyfile: 由pem编码的,由fabric ca 的服务器用来和postgresql服务器安全交流的</p>
<h4 id="postgresql的ssl配置"><a href="#postgresql的ssl配置" class="headerlink" title="postgresql的ssl配置"></a>postgresql的ssl配置</h4><h5 id="在postgresql服务器中配置ssl的基本介绍"><a href="#在postgresql服务器中配置ssl的基本介绍" class="headerlink" title="在postgresql服务器中配置ssl的基本介绍"></a>在postgresql服务器中配置ssl的基本介绍</h5><ol>
<li>在postgresql.conf中,取消注释ssl,设置为on(ssl=on)</li>
<li>把证书文件和秘钥文件放到postgresql的数据目录.</li>
</ol>
<p>生成自签名文件的介绍<a href="https://www.postgresql.org/docs/9.5/static/ssl-tcp.html" target="_blank" rel="noopener">https://www.postgresql.org/docs/9.5/static/ssl-tcp.html</a></p>
<blockquote>
<p>说明: 自签名的证书只能用来测试, 不能再生产环境中使用.</p>
</blockquote>
<h5 id="PostgreSQL的服务器-需要客户端的证书"><a href="#PostgreSQL的服务器-需要客户端的证书" class="headerlink" title="PostgreSQL的服务器-需要客户端的证书"></a>PostgreSQL的服务器-需要客户端的证书</h5><ol>
<li>把ca的证书放在放在PostgreSQL的数据目录的root.crt文件中</li>
<li>在PostgreSQL.conf中, 设置ssl_ca_file指向客户端的root证书</li>
<li>pg_hba.conf的文件中,把clientcert这个参数设置为1</li>
</ol>
<p>更多细节可以查看postgresql的文档:<a href="https://www.postgresql.org/docs/9.4/static/libpq-ssl.html" target="_blank" rel="noopener">https://www.postgresql.org/docs/9.4/static/libpq-ssl.html</a></p>
<h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>下面的例子可以加入到fabric ca server的配置文件中,用来连接db.确认好要把下面自定义的值合适.关于db名字的有字符的限制.使用这个文件 <a href="https://dev.mysql.com/doc/refman/5.7/en/identifiers.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/identifiers.html</a> 来查看更详细的描述.</p>
<p>在5.7.x中,某些模式决定 ‘0000-00-00’ 是否为一个合法的日期.需要允许这个使用.我们想允许server接收0 值的日期.</p>
<p>在my.cnf中,找到sql_mode,移除NO_ZERO_DATA值.然后重启mysql server</p>
<p>查阅mysql文档选择合适的设置.<a href="https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db:</span><br><span class="line">  type: mysql</span><br><span class="line">  datasource: root:rootpw@tcp(localhost:3306)/fabric_ca?parseTime=true&amp;tls=custom</span><br></pre></td></tr></table></figure>
<p>如果需要连接tls,就需要db.tls.client部分,可以在在上面postgresql查看相关的介绍.</p>
<blockquote>
<p>注释:<br>下面是在从配置中遇到一些问题:</p>
<ol>
<li>在docker-compose启动时, 从fabric-ca-server中的报错信息:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error occurred initializing database: Failed to create user registry for MySQL: Failed to connect to MySQL database: dial tcp 172.18.0.3:3306: getsockopt: connection refused</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<blockquote>
<p>或者是这样的信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ERROR] Error occurred initializing database: Failed to create user registry for MySQL: Failed to connect to MySQL database: Error 1045: Access denied for user &apos;root&apos;@&apos;172.18.0.4&apos; (using password: YES)</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>或者是<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Error: Error response from server was: Failed to initialize DB: Failed to create user registry <span class="keyword">for</span> MySQL: Failed to create MySQL tables: Error creating certificates table: Error 1067: Invalid default value <span class="keyword">for</span> <span class="string">'expiry'</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>这些问题主要有两个原因, 一个是fabric ca 服务端连接的参数不对,无法正常连接, 另一个就是MySQL在运行中出现问题,主动断开.<br>对于前者, 主要是这条命令:<code>FABRIC_CA_SERVER_DB_DATASOURCE=root:123456@tcp(mysql_ca:3306)/fabric_ca?parseTime=true</code>这里的这个配置是指用root用户,123456密码连接mysql,而mysql_ca是启动mysql的容器的名字,用这个名字作为hostname,fabric ca服务端就可以解析到myslq的ip地址.(在docker中默认有一个网关,172.18.0.1)</p>
</blockquote>
<blockquote>
<p>对于第二个原因, 在MySQL中有一个模式叫做no-zero-data.这个模式是禁止向mysql中添加日期值为0 的数值. 而fabric-ca 存储的数据到MySQL的时候,创建的certificates表中有一个revoked_at的字段, 存入的数值是0000-00-00 00:00:00.如果没有关闭这么模式, mysql也会断开连接.所以要把no-zero-data模式关闭,才可以正常使用.</p>
</blockquote>
<blockquote>
<p>对于mysql的配置, 也可以参考这里的介绍 <a href="https://dev.mysql.com/doc/refman/5.5/en/docker-mysql-more-topics.html#docker_var_mysql-root-host" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/docker-mysql-more-topics.html#docker_var_mysql-root-host</a> </p>
</blockquote>
<blockquote>
<p>总的来说, 对于mysql可以在两个地方配置.</p>
</blockquote>
<blockquote>
<p>一个是设置docker-compose.yaml文件,在mysql的service中添加如下内容:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line"><span class="attr">      MYSQL_ROOT_PASSWORD:</span> <span class="string">passw0rd</span></span><br><span class="line"><span class="attr">      MYSQL_ALLOW_EMPTY_PASSWORD:</span> <span class="string">"true"</span></span><br><span class="line"><span class="attr">      MYSQL_ROOT_HOST:</span> <span class="string">"%"</span></span><br><span class="line"><span class="attr">command:</span> <span class="string">mysqld</span> <span class="bullet">--sql_mode="ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION"</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>这条命令的意思是, docker-compose在逐个启动各个container(在docker-compose中, 各个container被定义为一个一个的service)的时候,会执行command的这个命令.这个mysqld是指mysql的服务进程.</p>
</blockquote>
<blockquote>
<p>另一个办法是设置mysql的配置文件,这个配置文件就是叫做my.cnf,一般来说路径是/etc/mysql.下面就是在my.cnf文件的相关的部分.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">sql-mode=&quot;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&quot;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>设置了这个配置文件之后, 要把这个在宿主机上的配置文件挂载到container中.可以使用docker-compose中的volumes属性.另外,把mysql的端口映射到宿主机,可以在宿主机登录查看<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"3306:3306"</span></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">      <span class="comment"># 把mysql的数据挂载到宿主机</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">主机目录:/var/lib/mysql</span></span><br><span class="line">      <span class="comment"># 把mysql服务器的配置挂载到宿主机</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">主机目录/my.cnf:/etc/mysql/my.cnf</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>顺便可以把mysql的整个数据目录一起映射的宿主机.省得单独导出了.</p>
</blockquote>
<blockquote>
<p>在mysql连接成功之后, 如何验证?只需要连接到docker中的mysql,就可以查看到.正常情况, fabric ca 服务端会在mysql中创建一个fabric-ca的数据库,这个数据库包含三张表,分别是 affiliations,certificates(用于记录已经颁发的证书),和users(用户记录已经认证的用户).</p>
</blockquote>
<blockquote>
<p>连接成功后在workdbench中可以看到如下的:</p>
</blockquote>
<blockquote>
<p><img src="./fabric-ca-tables.png" alt=""></p>
</blockquote>
<blockquote>
<p><img src="fabric-ca-tables-users.png" alt=""></p>
</blockquote>
<blockquote>
<p><img src="./fabric-ca-table-certicates.png" alt=""></p>
</blockquote>
<blockquote>
<p>在配置ldap之后,users表的功能就被ldap替代,所以users表空闲.</p>
</blockquote>
<h4 id="mysql的ssl设置"><a href="#mysql的ssl设置" class="headerlink" title="mysql的ssl设置."></a>mysql的ssl设置.</h4><p>基本介绍</p>
<ol>
<li>打开或者新建一个my.cnf在server中.在mysqld下面,增加或者解除注释.这应该指向了server的key或者证书,和根root证书.<br>创建客户端和服务端的证书的介绍:<a href="http://dev.mysql.com/doc/refman/5.7/en/creating-ssl-files-using-openssl.html" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/creating-ssl-files-using-openssl.html</a></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld] </span><br><span class="line">ssl-ca=ca-cert.pem </span><br><span class="line">ssl-cert=server-cert.pem </span><br><span class="line">ssl-key=server-key.pem</span><br></pre></td></tr></table></figure>
<p>运行下面的命令来确认已经启用了ssl连接:<br>mysql&gt; SHOW GLOBAL VARIABLES LIKE ‘have_%ssl’;</p>
<ol start="2">
<li>等服务端的ssl配置完成, 下一步是创建一个使用用户,可是使用ssl连接的特权.为此,登录进入mysql服务器,输入:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON . TO ‘ssluser’@’%’ IDENTIFIED BY ‘password’ REQUIRE SSL; mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>如果你特定ip可以访问, 把%改成你的ip</p>
<h4 id="mysql-服务端-需要客户端证书"><a href="#mysql-服务端-需要客户端证书" class="headerlink" title="mysql 服务端-需要客户端证书"></a>mysql 服务端-需要客户端证书</h4><p>安全连接的配置和其他服务端的配置类似.</p>
<ul>
<li>ssl-ca: 指明用户授权的证书.如果使用这个选项, 必须在fabric-ca服务端使用相同的证书.</li>
<li>ssl-cert: 指明mysql端的证书</li>
<li>ssl-key: 指明mysql服务端的私钥</li>
</ul>
<p>假设说,你想用一个没有加密的账户连接,或者说使用包含REQUIRE SSL选项的GRANT语句创建该帐户.作为推荐的安全连接选项,至少开启ssl-cert和ssl-key选项.然后设置db.tls.certfiles选项,再开启fabric ca 服务器.</p>
<p>要指定客户端证书, 使用REQUIRE X509 创建证书.然后客户端必须指定合适的client key和证书文件,否则, mysql会拒绝连接.为了指定client key和证书文件, 必须db.tls.client.certfile, and db.tls.client.keyfile</p>
<blockquote>
<p>下面是配置ssl中遇到问题: </p>
</blockquote>
<blockquote>
<p>首先是要对ssl连接要一定的了解.一下几个概念需要了解一下:</p>
</blockquote>
<blockquote>
<p>签名: 服务端用自己的私钥对内容的摘要加密, 把加密后的密文和原文发送客户端, 这就是签名.客户端收到之后, 可以用服务端的公钥对密文进行解密,解密之后的内容与收到的原文做摘要之后做比较, 如果相同,说明可以这个内容确实来自服务端(抗抵赖),而且,收到的内容也是完整的(完整性)</p>
</blockquote>
<blockquote>
<p>证书: 为了防止中间人攻击,确保客户端拿到的公钥确实是服务端的,需要对公钥做一些措施.所以,找了一个中间机构(发证机构),服务端把自己的公钥,自己机构的一些消息(就是上面的csr部分)和钱(自签名就交给自己吧orz), 交给发证机构.发证机构用自己的私钥对所有的这些信息进行加密(类似于签名的过程),把加密后的内容和服务器机构信息等放在一起,这就是一个证书.</p>
</blockquote>
<blockquote>
<p>ssl的简单过程:服务端把自己的证书发给客户端,客户端本地要实现安装了发证机构的证书,所以取得发证机构的公钥,解密证书,验证证书有效,这样客户端就获得了服务端的公钥.然后服务端发送一份带有签名的信息(交换对称加密的秘钥在这个过程),这样客户端就可以确定对方是服务端.至此,客户端和服务端就可以愉快的使用对称加密了.</p>
</blockquote>
<blockquote>
<p>更详细的描述可以查看这篇博客:<a href="http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html" target="_blank" rel="noopener">http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html</a></p>
</blockquote>
<blockquote>
<p>可以参考这篇文章 <a href="https://segmentfault.com/a/1190000007819751" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007819751</a> ,使用openssl工具生成一套ssl所需要的配置文件</p>
</blockquote>
<blockquote>
<p>需要注意的是在生成的时候要指定服务器的名字,也就是cn这个字段.<br>具体可以参考如下的设置.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 需要使用openssl工具</span></span><br><span class="line"><span class="comment"># 配置ssl连接的证书</span></span><br><span class="line"><span class="comment">#-subj /CN=mysql_ca 这个参数用来指定common name, 要与mysql container的name相同.</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span> </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">'$1 is null '</span></span><br><span class="line">        commonName=<span class="string">"mysql_ca"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">openssl genrsa 2048 &gt; ca-key.pem <span class="comment">#生成私钥</span></span><br><span class="line">openssl req -new -x509 -nodes -days 3600 \</span><br><span class="line">        -key ca-key.pem  -out ca.pem <span class="comment"># 在执行这条会要求输入csr消息,可以直接回车</span></span><br><span class="line">openssl req -newkey rsa:2048 -days 3600 \</span><br><span class="line">        -nodes -keyout server-key.pem -subj /CN=<span class="variable">$commonName</span> -out server-req.pem</span><br><span class="line">openssl rsa -<span class="keyword">in</span> server-key.pem -out server-key.pem</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> server-req.pem -days 3600 \</span><br><span class="line">        -CA ca.pem -CAkey ca-key.pem -set_serial 01 -out server-cert.pem</span><br><span class="line">openssl req -newkey rsa:2048 -days 3600 \</span><br><span class="line">        -nodes -keyout client-key.pem -subj /CN=<span class="variable">$commonName</span> -out client-req.pem</span><br><span class="line">openssl rsa -<span class="keyword">in</span> client-key.pem -out client-key.pem</span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> client-req.pem -days 3600 \</span><br><span class="line">        -CA ca.pem -CAkey ca-key.pem -set_serial 01 -out client-cert.pem</span><br><span class="line">openssl verify -CAfile ca.pem server-cert.pem client-cert.pem</span><br><span class="line">openssl x509 -text -<span class="keyword">in</span> ca.pem</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>上面的代码一共会生成8个文件:</p>
<ul>
<li>ca.pem: CA 证书, 用于生成服务器端/客户端的数字证书.</li>
<li>ca-key.pem: CA 私钥, 用于生成服务器端/客户端的数字证书.</li>
<li>server-key.pem: 服务器端的 RSA 私钥</li>
<li>server-req.pem: 服务器端的证书请求文件, 用于生成服务器端的数字证书.</li>
<li>server-cert.pem: 服务器端的数字证书.</li>
<li>client-key.pem: 客户端的 RSA 私钥</li>
<li>client-req.pem: 客户端的证书请求文件, 用于生成客户端的数字证书.</li>
<li>client-cert.pem: 客户端的数字证书.</li>
</ul>
</blockquote>
<blockquote>
<p>使用<code>openssl x509 -text -in [证书名字].pem</code>可以查看一个证书的内容:<br><img src="cert-sample.png" alt=""></p>
</blockquote>
<blockquote>
<p>在mysql端需要my.cnf中如下配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">general_log = 1</span><br><span class="line">ssl-ca=/etc/mysql/fabric_ca_ssl/ca.pem </span><br><span class="line">ssl-cert=/etc/mysql/fabric_ca_ssl/server-cert.pem </span><br><span class="line">ssl-key=/etc/mysql/fabric_ca_ssl/server-key.pem</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>此处<code>general_log = 1</code>值mysql日志的级别,通过这种方式可以查看是否使用ssl连接</p>
</blockquote>
<blockquote>
<p>把上面生成的ssl文件拷贝到相应的目录中,通过volumns挂在到mysql的容器中.可以参考下面的配置:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">./mysql2/fabric_ca_ssl:/etc/mysql/fabric_ca_ssl</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>对于fabric-ca端的配置,在环境变量中配置ssl的文件<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_DB_DATASOURCE=root:passw0rd@tcp(mysql_ca:3306)/fabric_ca?parseTime=true&amp;tls=custom</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">FABRIC_CA_SERVER_DB_TLS_ENABLED=true</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">FABRIC_CA_SERVER_DB_TLS_CERTFILES=/etc/hyperledger/fabric-ca-server-mysql-config/ca.pem</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">FABRIC_CA_SERVER_DB_TLS_CLIENT_CERTFILE=/etc/hyperledger/fabric-ca-server-mysql-config/client-cert.pem</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">FABRIC_CA_SERVER_DB_TLS_CLIENT_KEYFILE=/etc/hyperledger/fabric-ca-server-mysql-config/client-key.pem</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>需要注意的是必须加上<code>tls=custom</code>这一句,这是指定使用tls连接,<code>FABRIC_CA_SERVER_DB_TLS_CERTFILES</code>是指定发证机构的证书,<code>FABRIC_CA_SERVER_DB_TLS_CLIENT_CERTFILE</code>是指定客户端的证书,<code>FABRIC_CA_SERVER_DB_TLS_CLIENT_KEYFILE</code>是指定客户端的私钥</p>
</blockquote>
<blockquote>
<p>同样要记得把相应的文件导入到fabric-ca的容器中,可以参考如下的配置:<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">./mysql2/fabric_ca_ssl:/etc/hyperledger/fabric-ca-server-mysql-config</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><img src="./mysql-log.png" alt=""></p>
<blockquote>
<p>上图显示的172.18.0.2是fabric-ca分配的ip,下面的172.18.0.1是在宿主机中用workbench连接是,通过docker网关(172.18.0.1)进行连接.</p>
</blockquote>
<blockquote>
<p>可以使用如下命令查看某个容器的ip:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect [容器名字] | grep IPAddress</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="配置ldap"><a href="#配置ldap" class="headerlink" title="配置ldap"></a>配置ldap</h2><p>fabric ca服务端也可以配置为从ldap服务器读取.</p>
<p>特别是,fabric ca连接到ldap后做以下的事情:</p>
<ul>
<li>在注册之前验证身份</li>
<li>检索用于授权的身份的属性值</li>
</ul>
<p>修改Fabric CA服务器配置文件的LDAP部分，将服务器配置为连接到LDAP服务器。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldap:</span><br><span class="line">   # Enables or disables the LDAP client (default: false)</span><br><span class="line">   enabled: false</span><br><span class="line">   # The URL of the LDAP server</span><br><span class="line">   url: &lt;scheme&gt;://&lt;adminDN&gt;:&lt;adminPassword&gt;@&lt;host&gt;:&lt;port&gt;/&lt;base&gt;</span><br><span class="line">   userfilter: filter</span><br></pre></td></tr></table></figure></p>
<p>此处参数的含义:</p>
<ul>
<li>where: 其中一个ldap</li>
<li>adminDN: admin用户的独有的名字</li>
<li>pass: admin用户的密码</li>
<li>host:ldap服务器的hostname或者ip</li>
<li>port: 可选的,ldap默认389, ldaps默认636</li>
<li>base:用于搜索的LDAP树的可选根目录;</li>
<li>filter: 在搜索时, 把登录名字转换为一个独特的名字.例如: 一个uid=%的值是搜索的值是一个在登录时有uid属性的值.email=%s可能用来使用email地址登录.</li>
</ul>
<p>以下是一个openldap服务器的默认设置, docker镜像在<br><a href="https://github.com/osixia/docker-openldap" target="_blank" rel="noopener">https://github.com/osixia/docker-openldap</a>.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldap:</span><br><span class="line">   enabled: true</span><br><span class="line">   url: ldap://cn=admin,dc=example,dc=org:admin@localhost:10389/dc=example,dc=org</span><br><span class="line">   userfilter: (uid=%s)</span><br></pre></td></tr></table></figure>
<p>查看<code>FABRIC_CA/scripts/run-ldap-tests</code>这个脚本来开启openldap的docker镜像,配置, 运行,使用这个<code>FABRIC_CA/cli/server/ldap/ldap_test.go</code>测试, 并且停止openldap服务器.</p>
<p>当一个ldap配置后, enrollment的工作流是这样的:</p>
<ul>
<li>fabric ca client或者client 登录请求,在头部带有一个授权信息(就是enroll的时候用户名和密码).</li>
<li>fabric ca server 收到enroment请求,解码授权头部中的实体的名字,密码.使用’userfilter’查找与这个实体名字相关的distinguished name. 尝试使用这个密码进行ldap绑定.如果ldap绑定成功,那么, enrollment过程就被授权,和继续执行.</li>
</ul>
<p>当ldap配置后, 获取属性的工作流是这样的:</p>
<ul>
<li>一个客户端的sdk向fabric ca服务端发送一个请求来获取一些有一个或者多个属性的证书.</li>
<li>当fabric ca 服务端收到tcert的请求后的工作流:<ul>
<li>根据在授权头部中的token来提取enrollment id.(在验证了token之后)</li>
<li>向ldap服务器做一个ldap搜索和查询, 请求所有在tcert请求中的属性名.</li>
<li>属性值就会被放在tcert中.</li>
</ul>
</li>
</ul>
<blockquote>
<p>注释: 主要是两个地方的配置,一个是ca中开启ldap,<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_LDAP_ENABLED=true</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">FABRIC_CA_SERVER_LDAP_URL=ldap://cn=admin,dc=example,dc=org:adminpw@fabric_ca_openldap:389/dc=example,dc=org</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">FABRIC_CA_SERVER_LDAP_URL_USERFILTER=(uid=%s)</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>fabric-ca服务端已经实现了ldap的客户端, 另一个添加ldap服务到docker-compose中.为了方便查看,还可以安装ldapPhpAdmin来查看和管理ldap中的用户.<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ldap:</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">osixia/openldap:1.2.1</span></span><br><span class="line"><span class="attr">      container_name:</span> <span class="string">fabric_ca_openldap</span></span><br><span class="line"><span class="attr">      environment:</span></span><br><span class="line"><span class="attr">        LDAP_LOG_LEVEL:</span> <span class="string">"-1"</span> <span class="comment"># 	enable all debugging</span></span><br><span class="line"><span class="attr">        LDAP_ADMIN_PASSWORD:</span> <span class="string">"adminpw"</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line">        <span class="comment"># 数据文件</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">./openldap/ldap:/var/lib/ldap</span></span><br><span class="line">        <span class="comment"># 配置文件</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">./openldap/slapd.d:/etc/ldap/slapd.d</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">./openldap_data/add-user.ldif:/tmp/add-user.ldif</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"389:389"</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">"636:636"</span></span><br><span class="line"><span class="attr">      networks:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">basic</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  phpLDAPadmin:</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">osixia/phpldapadmin:0.7.1</span></span><br><span class="line"><span class="attr">    container_name:</span> <span class="string">fabric_phpLDAPadmin</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"8080:80"</span></span><br><span class="line"><span class="attr">    environment:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">PHPLDAPADMIN_LDAP_HOSTS=fabric_ca_openldap</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">PHPLDAPADMIN_HTTPS="false"</span></span><br><span class="line"><span class="attr">    depends_on:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ldap</span></span><br><span class="line"><span class="attr">    networks:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">basic</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>这里的<code>add-user.ldif</code>相当于mysql中的sql文件,可以执行这个命令向ldap中添加用户.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> fabric_ca_openldap ldapadd -cxD cn=admin,dc=example,dc=org -w adminpw -f /tmp/add-user.ldif</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> fabric_ca_openldap ldappasswd -xD cn=admin,dc=example,dc=org -w adminpw uid=jsmith,dc=example,dc=org -s jsmithpw</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>可以到浏览器访问<code>localhost:8080</code>,使用<code>cn=admin,dc=example,dc=org,adminpw</code>这个管理员的用户密码登录,就可以发现刚刚添加的用户.<br><img src="ldap-jsmith.png" alt=""></p>
</blockquote>
<blockquote>
<p>使用ldap之后, fabric-ca服务端的执行start的时候就不用-b选项了.</p>
</blockquote>
<blockquote>
<p>可以在fabric-ca服务端登录这个用户,可以看到jsmith这个用户已经拿到证书:<br><img src="jsmith-enroll.png" alt=""><br><img src="jsmith-cert.png" alt=""></p>
</blockquote>
<h2 id="配置集群"><a href="#配置集群" class="headerlink" title="配置集群"></a>配置集群</h2><p>你可能会用ip sprayer来对一个ca集群做负载均衡.本部分提供一个例子, 如何设置haproxy作为一个ca服务集群的路由.确定把hostname和端口设置到与ca服务器相符.</p>
<p>haproxy.conf的配置:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line">      maxconn 4096</span><br><span class="line">      daemon</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">      mode http</span><br><span class="line">      maxconn 2000</span><br><span class="line">      timeout connect 5000</span><br><span class="line">      timeout client 50000</span><br><span class="line">      timeout server 50000</span><br><span class="line"></span><br><span class="line">listen http-in</span><br><span class="line">      bind *:7054</span><br><span class="line">      balance roundrobin</span><br><span class="line">      server server1 hostname1:port</span><br><span class="line">      server server2 hostname2:port</span><br><span class="line">      server server3 hostname3:port</span><br></pre></td></tr></table></figure></p>
<p>注意, 如果使用tls, 要使用tcp模式.</p>
<blockquote>
<p>说明:<br>要完成这个需要启动一个haproxy服务<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">haproxy_ca:</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">haproxy</span></span><br><span class="line"><span class="attr">  container_name:</span> <span class="string">haproxy_ca</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"70:70"</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">./haproxy/haproxy.cfg:/usr/local/etc/haproxy/haproxy.cfg</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">./haproxy/log:/dev/log</span></span><br><span class="line"><span class="attr">  networks:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">basic</span></span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>而对于haproxy, 要做这样的配置:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">global</span><br><span class="line"># 支持的最大连接数</span><br><span class="line">      maxconn 4096 </span><br><span class="line">       # 以守护进程的方式运行</span><br><span class="line">      daemon</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line"># 代理模式有http和tcp两种, tls需要tcp模式.http是七层模式，tcp是四层模式，health是健康检测，返回OK</span><br><span class="line">      mode http</span><br><span class="line">      maxconn 2000</span><br><span class="line">      timeout connect 5000</span><br><span class="line">      timeout client 50000</span><br><span class="line">      timeout server 50000</span><br><span class="line"></span><br><span class="line">frontend balancer</span><br><span class="line">      bind *:7054</span><br><span class="line">      mode http</span><br><span class="line">      default_backend servers</span><br><span class="line"></span><br><span class="line">#  定义后端节点</span><br><span class="line"># listen http-in</span><br><span class="line"># 监听7054</span><br><span class="line">backend servers</span><br><span class="line"># 负载均衡的算法: roundrobin: 权重轮训, 动态, static-rr: 权重轮训, 静态</span><br><span class="line"># leastconn:到最少连接数, 动态, 长时间会话</span><br><span class="line"># source: 同一个ip始终到特定服务器.</span><br><span class="line"># uri: 同一uri始终到特定服务器</span><br><span class="line"># hdr:</span><br><span class="line">      balance roundrobin</span><br><span class="line">      server ca1 ca1.example.com:7054</span><br><span class="line">      server ca2 ca2.example.com:7054</span><br><span class="line">      server ca3 ca3.example.com:7054</span><br><span class="line"></span><br><span class="line">listen status</span><br><span class="line">      mode http</span><br><span class="line">      default_backend servers</span><br><span class="line">      bind 0.0.0.0:70</span><br><span class="line">      stats enable</span><br><span class="line">      stats hide-version</span><br><span class="line">      stats uri     /stats</span><br><span class="line">      stats auth    admin:password</span><br><span class="line">      stats admin if TRUE</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>而且,通过将70端口映射到宿主机访问<code>http://localhost:70/stats</code>, 用户名和密码在haproxy.cfg文件中, 可以查看haproxy的信息<br><img src="haproxy-stats.png" alt=""></p>
</blockquote>
<blockquote>
<p>分别登录三个ca1,ca2,ca3执行一次之后</p>
</blockquote>
<p><img src="haproxy-stats-after.png" alt=""></p>
<h2 id="设置多个ca"><a href="#设置多个ca" class="headerlink" title="设置多个ca"></a>设置多个ca</h2><p>每个ca服务器默认包含一个ca.然而, 可以使用cafiles或者cacount配置选项来向一个ca服务器中增加多个ca.每个增加的ca都有自己的主目录.</p>
<h3 id="cacout"><a href="#cacout" class="headerlink" title="cacout:"></a>cacout:</h3><p>cacout提供了一种快速x个ca的方案.他的主目录与服务器的主目录相关.当开启这个选项,目录结构如图:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--&lt;Server Home&gt;</span><br><span class="line">  |--ca</span><br><span class="line">    |--ca1</span><br><span class="line">    |--ca2</span><br></pre></td></tr></table></figure></p>
<p>每个额外的ca都在自己的主目录中生成一个默认的配置文件, 在这个目录文件中, 会包含一个唯一的ca名字.</p>
<p>例如, 如下的命令开启默认开启2个ca实例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-server start -b admin:adminpw --cacount 2</span><br></pre></td></tr></table></figure></p>
<h3 id="cafiles"><a href="#cafiles" class="headerlink" title="cafiles:"></a>cafiles:</h3><p>在使用cafile配置选项的时候, 没有提供绝对路径,那么ca的目录就是相对于服务器的目录.</p>
<p>为了使用这个选项,必须事先生成ca的配置文件,并且每个将要开启的ca配置好.每个配置文件必须有一个唯一的ca名字和一个common name, 否则就会开启失败, 因为名字必须唯一.ca的配置文件会覆盖所有的ca默认配置文件, 任何在ca配置文件中缺失的选项将会使用ca 的默认值来替换.</p>
<p>优先级如下所示:</p>
<ol>
<li>ca 配置文件</li>
<li>默认的的cli命令</li>
<li>默认的ca环境变量</li>
<li>默认的配置文件</li>
</ol>
<p>一个ca的配置文件必须要有一下几个:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ca:</span><br><span class="line"># Name of this CA</span><br><span class="line">name: &lt;CANAME&gt;</span><br><span class="line"></span><br><span class="line">csr:</span><br><span class="line">  cn: &lt;COMMONNAME&gt;</span><br></pre></td></tr></table></figure></p>
<p>你可以如下配置目录结构:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--&lt;Server Home&gt;</span><br><span class="line">  |--ca</span><br><span class="line">    |--ca1</span><br><span class="line">      |-- fabric-ca-config.yaml</span><br><span class="line">    |--ca2</span><br><span class="line">      |-- fabric-ca-config.yaml</span><br></pre></td></tr></table></figure></p>
<p>例如: 下面的命令会开启两个自定义的ca实例.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-server start -b admin:adminpw --cafiles ca/ca1/fabric-ca-config.yaml --cafiles   ca/ca2/fabric-ca-config.yaml</span><br></pre></td></tr></table></figure></p>
<h2 id="登录一个中间ca"><a href="#登录一个中间ca" class="headerlink" title="登录一个中间ca"></a>登录一个中间ca</h2><p>为了给一个中间ca创建一个签名证书,这个中间ca必须向一个父级ca登录,与一个fabric-ca 客户端登录的方式相同.这个可以类似下面展示的方式, 使用-u选项来指定父级的ca的URL,登录的id和密码.这个登录id的用户必须有一个名为”hr.IntermediateCA”的属性,它的值是<code>true</code>.颁发的证书的CN(common name)设置为登录id.如果一个中间ca指定名字, 会发生错误.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fabric-ca-server start -b admin:adminpw -u http://&lt;enrollmentID&gt;:&lt;secret&gt;@&lt;parentserver&gt;:&lt;parentport&gt;</span><br></pre></td></tr></table></figure>
<p>更多关于中间ca的标记可以查看<a href="https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#fabric-ca-server-s-configuration-file-format" target="_blank" rel="noopener">https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#fabric-ca-server-s-configuration-file-format</a></p>
<h1 id="fabric-ca-客户端"><a href="#fabric-ca-客户端" class="headerlink" title="fabric ca 客户端"></a>fabric ca 客户端</h1><p>这一部分描述如何使用fabric-ca客户端命令.</p>
<p>fabric-ca的客户端的主目录有以下的顺序决定:</p>
<ul>
<li>如果设置了<code>FABRIC_CA_CLIENT_HOME</code>环境变量,就用这个</li>
<li>如果设置了<code>FABRIC_CA_HOME</code>环境变量,就用这个</li>
<li>如果设置了<code>CA_CFG_PATH</code>环境变量,就用这个</li>
<li>如果设置了<code>$HOME/.fabric-ca-client</code>环境变量,就用这个</li>
</ul>
<p>下面的介绍假定客户端的配置文件存在于客户端的主目录中.</p>
<h2 id="登录启动实体"><a href="#登录启动实体" class="headerlink" title="登录启动实体"></a>登录启动实体</h2><p>首先, 如果需要, 要在client的配置文件中, 自定义csr部分.注意: csr.cn部分必须是启动实体的id.以下是默认的csr值:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">csr:</span><br><span class="line">  cn: &lt;&lt;enrollment ID&gt;&gt;</span><br><span class="line">  key:</span><br><span class="line">    algo: ecdsa</span><br><span class="line">    size: 256</span><br><span class="line">  names:</span><br><span class="line">    - C: US</span><br><span class="line">      ST: North Carolina</span><br><span class="line">      L:</span><br><span class="line">      O: Hyperledger Fabric</span><br><span class="line">      OU: Fabric CA</span><br><span class="line">  hosts:</span><br><span class="line">   - &lt;&lt;hostname of the fabric-ca-client&gt;&gt;</span><br><span class="line">  ca:</span><br><span class="line">    pathlen:</span><br><span class="line">    pathlenzero:</span><br><span class="line">    expiry:</span><br></pre></td></tr></table></figure></p>
<p>可以查看csr部分详细描述.<a href="https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#csr-fields" target="_blank" rel="noopener">https://hyperledger-fabric-ca.readthedocs.io/en/release-1.0/users-guide.html#csr-fields</a></p>
<p>然后运行<code>fabric-ca-client enroll</code>来登录实体.比如,以下命令,调用运行在locahost:7054的fabric ca 服务,登录一个实体,id是admin,密码是adminpw.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> FABRIC_CA_CLIENT_HOME=<span class="variable">$HOME</span>/fabric-ca/clients/admin</span><br><span class="line">fabric-ca-client enroll -u http://admin:adminpw@localhost:7054</span><br></pre></td></tr></table></figure></p>
<p>这个登录命令将一个登录证书ecert,相应的私钥,和ca证书存储到fabric ca客户端msp目录.你会看到pem在哪里存储的信息.</p>
<blockquote>
<p> 注释:<br>执行的结果:<br>在fabric-ca中:<br><img src="client-enroll.png" alt=""></p>
</blockquote>
<blockquote>
<p>在user表中:<br><img src="user-table-enroll.png" alt=""></p>
</blockquote>
<blockquote>
<p>在certificate表中:<br><img src="cert-tabel-enroll.png" alt=""></p>
</blockquote>
<blockquote>
<p>登录一个用户的过程是这样的: client端生成一份私钥,存在<code>$FABRIC_CA_CLIENT_HOME/msp/keystore</code>.比方说amin登录就需要指定为amin的值.当然这个值也可以按照上面的规则用环境变量或者命令行参数覆盖.接着,向服务端发起请求.服务端的返回发证机构的一个证书,放在文件夹<code>$FABRIC_CA_CLIENT_HOME/msp/cacerts</code>中,命名为上面请求的<code>{hostname}-{port}.pem</code>,这个证书实际上就是fabric-ca服务端的发证机构的证书,也就是服务端的<code>/etc/hyperledger/fabric-ca-server-config/org1.example.com-cert.pem</code>这个文件.还有一个是fabric-ca服务端给客户端的证书<code>$FABRIC_CA_CLIENT_HOME/msp/signcerts/cert.pem</code>,会存放在这个证书是在issure是fabric-ca服务端,subject(证书持有者)是admin用户.<br><img src="ca-client-admin-cert.png" alt=""></p>
</blockquote>
<h2 id="注册一个新的用户"><a href="#注册一个新的用户" class="headerlink" title="注册一个新的用户"></a>注册一个新的用户</h2><p>执行注册的身份必须已经登录,也必须要有相应的权限来注册这种类型的用户.</p>
<p>通常, 在fabric ca server注册期间会实行两个授权检查:</p>
<ol>
<li>登录的身份必须要有hf.Registrar.Roles属性,可以用逗号分隔,其中一个值是正在注册的值.例如, 调用身份的hf.Registrar.Roles属性值是peer,app,user”,那么只能注册这其中的一个, 不能是order</li>
<li>调用者身份的隶属关系必须等于被登记身份的隶属关系的前缀.例如, ，具有“a.b”属性的调用者可以注册与“a.b.c”属性相同的身份，但不可以注册属于“a.c”属性的身份。</li>
</ol>
<p>例如, 下面的命令用admin证书,注册一个新的用户,enrollment id 是admin2, 类型user, 丛书关系 org1.department, 属性名字hr.Revoker为true,还有一个属性foo,值是bar<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FABRIC_CA_CLIENT_HOME=$HOME/fabric-ca/clients/admin</span><br><span class="line">fabric-ca-client register --id.name admin2 --id.type user --id.affiliation org1.department1 --id.attrs &apos;hf.Revoker=true,foo=bar&apos;</span><br></pre></td></tr></table></figure></p>
<p>密码, 或者登陆凭证, 会被打印.这个密码可以用来注册.这可以让管理员注册身份并把enrollment ID和密码给别人注册.</p>
<blockquote>
<p> 注释:<br>fabric-ca的输出:<br><img src="admin2-reg.png" alt=""></p>
</blockquote>
<blockquote>
<p>user表的内容:<br><img src="user-table-admin2-reg.png" alt=""></p>
</blockquote>
<p>certficate表没有变化</p>
<p>多个属性可以用id.attrs flag的一部分, 并且用分号分隔.对于包含逗号的属性, 要用双引号<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-client register -d --id.name admin2 --id.type user --id.affiliation org1.department1 --id.attrs &apos;&quot;hf.Registrar.Roles=peer,user&quot;,hf.Revoker=true&apos;</span><br></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-client register -d --id.name admin2 --id.type user --id.affiliation org1.department1 --id.attrs &apos;&quot;hf.Registrar.Roles=peer,user&quot;&apos; --id.attrs hf.Revoker=true</span><br></pre></td></tr></table></figure></p>
<p>可以在客户端配置文件中设置默认值,如下是一个支持的配置文件格式<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">id:</span></span><br><span class="line"><span class="attr">  name:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">user</span></span><br><span class="line"><span class="attr">  affiliation:</span> <span class="string">org1.department1</span></span><br><span class="line"><span class="attr">  maxenrollments:</span> <span class="bullet">-1</span></span><br><span class="line"><span class="attr">  attributes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">hf.Revoker</span></span><br><span class="line"><span class="attr">      value:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">anotherAttrName</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">anotherAttrValue</span></span><br></pre></td></tr></table></figure></p>
<p>一下命令会注册一个新的用户,注册id时admin3,有cli指定,从配置文件读取其余的参数.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FABRIC_CA_CLIENT_HOME=$HOME/fabric-ca/clients/admin</span><br><span class="line">fabric-ca-client register --id.name admin3</span><br></pre></td></tr></table></figure></p>
<p>要注册具有多个属性的标识，需要在配置文件中指定所有属性名称和值，如上所示.</p>
<p>将maxenrollments设置为0或将其从配置中删除将导致身份被注册为使用CA的最大注册值。此外，注册身份的最大注册值不能超过CA的最大注册值。例如，如果CA的最大注册值为5.任何新身份的值必须小于或等于5，也不能将其设置为-1（无限注册）。</p>
<p>接下来，让我们注册一个peer身份，这将用于在以下部分注册用户。以下的命令注册了peer1.注意, 我们自己指定密码而不是让服务器生成.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> FABRIC_CA_CLIENT_HOME=<span class="variable">$HOME</span>/fabric-ca/clients/admin</span><br><span class="line">fabric-ca-client register --id.name peer1 --id.type peer --id.affiliation org1.department1 --id.secret peer1pw</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>说明<br>在fabric-ca中输出:</p>
</blockquote>
<p><img src="peer-reg.png" alt=""></p>
<blockquote>
<p>在user表中:</p>
</blockquote>
<p><img src="user-table-peer-reg.png" alt=""></p>
<h2 id="注册peer用户"><a href="#注册peer用户" class="headerlink" title="注册peer用户"></a>注册peer用户</h2><p>既然已经注册peer用户, 可以使用给定的enrollment ID和密码enroll.这个与enroll启动身份很相似,除了我们演示的用-m 选项来指定hyperledger fabric msp部分的目录结构.</p>
<p>以下的命令enroll peer1.确认要把-m中的目录指定到自己的peer 的msp目录中, msp路径在peer的core.yaml文件中.你也可以设置FABRIC_CA_CLIENT_HOME.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FABRIC_CA_CLIENT_HOME=$HOME/fabric-ca/clients/peer1</span><br><span class="line">fabric-ca-client enroll -u http://peer1:peer1pw@localhost:7054 -M $FABRIC_CA_CLIENT_HOME/msp</span><br></pre></td></tr></table></figure></p>
<p>登录一个order也是类似的,除了在order.yaml中指定LocalMSPDir的不同.</p>
<blockquote>
<p>注释:<br> 注册用户的过程是这样的: peer1用户借助admin用户来注册.先前amdin用户登录之后, 在本地就存了一份admin用户的证书.如果没有证书,会提示重新登录<br><img src="not-enroll.png" alt=""><br> 一份默认的配置文件,就是<code>/root/fabric-ca/clients/peer1/fabric-ca-client-config.yaml</code>,通过读取配置中<code>csr.cn</code>的值,指定登录的身份,当然,在这里只能为admin,而不能是其他用户,因为只有admin的属性中带有了注册其他角色的权限(可以查看user表中的attribute字段).服务端返回的响应是给peer1用户的一个证书.可以看出发证机构是<code>ca.org1.example.com</code>,而证书的持有者就是<code>peer1</code><br><img src="peer1-cert.png" alt=""></p>
</blockquote>
<h2 id="从另一个ca服务器获得一个ca证书"><a href="#从另一个ca服务器获得一个ca证书" class="headerlink" title="从另一个ca服务器获得一个ca证书"></a>从另一个ca服务器获得一个ca证书</h2><p>通常，MSP目录的cacerts目录必须包含其他证书颁发机构的证书颁发机构链，代表所有peer节点的所有信任根。</p>
<p><code>fabric-ca-client getcacerts</code>这个命令可以获取从其他fabric-ca服务器的证书链.</p>
<p>例如, 以下会在locahost启动第二个ca服务器在端口7055,名为CA2..这表示一个完全独立的信任根，并由区块链上的其他成员管理。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FABRIC_CA_SERVER_HOME=$HOME/ca2</span><br><span class="line">fabric-ca-server start -b admin:ca2pw -p 7055 -n CA2</span><br></pre></td></tr></table></figure></p>
<p>以下命令将CA2的证书链安装到peer1的MSP目录中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FABRIC_CA_CLIENT_HOME=$HOME/fabric-ca/clients/peer1</span><br><span class="line">fabric-ca-client getcacert -u http://localhost:7055 -M $FABRIC_CA_CLIENT_HOME/msp</span><br></pre></td></tr></table></figure></p>
<h2 id="重新enroll一个实体"><a href="#重新enroll一个实体" class="headerlink" title="重新enroll一个实体"></a>重新enroll一个实体</h2><p>假如你的证书要过期或者撤销,可以使用下面的命令更新证书.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FABRIC_CA_CLIENT_HOME=$HOME/fabric-ca/clients/peer1</span><br><span class="line">fabric-ca-client reenroll</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结果如图所示:<br><img src="reenroll.png" alt=""></p>
</blockquote>
<h2 id="撤销一个证书"><a href="#撤销一个证书" class="headerlink" title="撤销一个证书"></a>撤销一个证书</h2><p>一个实体或者证书都是可以撤销的.撤销一个实体会撤销这个实体所拥有的所有证书,并且会阻止这个实体获取新的证书.撤销证书只是让证书失效</p>
<p>为了撤销证书, 实体必须要有hrRevoke属性.撤销身份只能撤销证书或身份，其身份与撤销身份的隶属关系相同或以前缀为准。例如,具有隶属关系orgs.org1的撤销者可以撤销与orgs.org1或orgs.org1.department1相关联的身份，但不能撤销与orgs.org2相关的身份。<br>以下的命令会撤销一个实体并且撤销与此实体相关的所有证书.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-client revoke -e &lt;enrollment_id&gt; -r &lt;reason&gt;</span><br></pre></td></tr></table></figure></p>
<p>以下是-r 标记可以使用的原因:</p>
<ol>
<li>unspecified : 未指明</li>
<li>keycompromise : 秘钥无效</li>
<li>cacompromise : ca 无效</li>
<li>affiliationchange : 改变隶属关系</li>
<li>superseded :被替代</li>
<li>cessationofoperation : 操作终止</li>
<li>certificatehold </li>
<li>removefromcrl</li>
<li>privilegewithdrawn</li>
<li>aacompromise</li>
</ol>
<p>例如,与从属关系树相关的启动admin可以撤销peer1的身份.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export FABRIC_CA_CLIENT_HOME=$HOME/fabric-ca/clients/admin</span><br><span class="line">fabric-ca-client revoke -e peer1</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><img src="revoke.png" alt=""><br><img src="revoke-mysql.png" alt=""></p>
</blockquote>
<p>通过指定其AKI（授权密钥标识符）和序列号，可以撤销属于某个身份的注册证书，如下所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-client revoke -a xxx -s yyy -r &lt;reason&gt;</span><br></pre></td></tr></table></figure></p>
<p>例如，您可以使用openssl命令获取AKI和证书的序列号，并将它们传递给revoke命令以撤消该证书，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serial=$(openssl x509 -in userecert.pem -serial -noout | cut -d &quot;=&quot; -f 2)</span><br><span class="line">aki=$(openssl x509 -in userecert.pem -text | awk &apos;/keyid/ &#123;gsub(/ *keyid:|:/,&quot;&quot;,$1);print tolower($0)&#125;&apos;)</span><br><span class="line">fabric-ca-client revoke -s $serial -a $aki -r affiliationchange</span><br></pre></td></tr></table></figure>
<h2 id="使用tls"><a href="#使用tls" class="headerlink" title="使用tls"></a>使用tls</h2><p>以下可以在 fabric-ca-client-config.yaml 中配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tls:</span><br><span class="line">  # Enable TLS (default: false)</span><br><span class="line">  enabled: true</span><br><span class="line">  certfiles:</span><br><span class="line">    - root.pem</span><br><span class="line">  client:</span><br><span class="line">    certfile: tls_client-cert.pem</span><br><span class="line">    keyfile: tls_client-key.pem</span><br></pre></td></tr></table></figure></p>
<p>这个证书选项就是一系列被client信任的root证书.这通常只是在ca-cert.pem文件中的服务器主目录中找到的根结构CA服务器的证书。</p>
<p>只有服务端配置了tls, 才需要在客户端配置</p>
<h2 id="联系指定的ca实例"><a href="#联系指定的ca实例" class="headerlink" title="联系指定的ca实例"></a>联系指定的ca实例</h2><p>等运行在一个服务器上多个ca,可以指定ca.默认,如果ca的名字没有在客户端的请求中指定,就会请求fabric-ca服务端的默认ca.一个ca 的名字可以客户端的命令行中指定<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fabric-ca-client enroll -u http://admin:adminpw@localhost:7054 --caname &lt;caname&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h1><ol>
<li><p>在2018-7, fabric更新到了1.2.<a href="https://hyperledger-fabric-ca.readthedocs.io/en/release-1.2/users-guide.html" target="_blank" rel="noopener">文档</a>也更加丰富,更加人性化.建议先去看一下.</p>
</li>
<li><p>之前的中文翻译文档:<a href="https://hyperledgercn.github.io/hyperledgerDocs/" target="_blank" rel="noopener">https://hyperledgercn.github.io/hyperledgerDocs/</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>hyperledger</category>
        <category>fabric</category>
      </categories>
      <tags>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>rsa的公钥加密私钥解密过程</title>
    <url>/2018/04/20/rsa/</url>
    <content><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>从一个初学者的角度,了解rsa的实现过程.在王里冲产出公钥和私钥.私钥自己保留,公钥传送给潘兴.潘兴把使用公钥加密后信息传给王里冲,王里冲可以使用私钥解开加密.获得信息.</p>
<a id="more"></a>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="名词解析"><a href="#名词解析" class="headerlink" title="名词解析"></a>名词解析</h3><ul>
<li>王里冲：秘钥的生成方， 生成公钥和私钥</li>
<li>潘兴： 当然就是另一方喽</li>
<li>公钥,私钥 :公钥和私钥实际就分别是两个数对(n,e), (n,d), 其中(n,e)是公钥,(n,d)是私钥.n是两个质数的积.[<a href="http://blog.51cto.com/dayewo/1117309" target="_blank" rel="noopener">1</a>]</li>
<li>密钥长度: n用二进制表示的时候占用的位数,就是所说的密钥长度.[<a href="http://blog.51cto.com/dayewo/1117309" target="_blank" rel="noopener">1</a>]</li>
<li>素数: 就是质数.除了1和该数自身外，无法被其他自然数整除的数.(小时候学的数学课本忘记怎么说的.查了一下wiki.(orz))</li>
</ul>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>故事的背景,王里冲(男一)和潘兴(男二)想要做一个私密的py交易,事先需要沟通信息.这个信息不能别人知道.他们使用rsa.</p>
<h3 id="潘兴向王里冲传递信息-公钥加密-私钥解密"><a href="#潘兴向王里冲传递信息-公钥加密-私钥解密" class="headerlink" title="潘兴向王里冲传递信息.(公钥加密, 私钥解密)"></a>潘兴向王里冲传递信息.(公钥加密, 私钥解密)</h3><p>潘兴想要发送一段文字: I LOVE YOU!(此处不讨论中文字符).为了完成这个, 主要有三个步骤:</p>
<ol>
<li><p>王里冲在自己本地生成公钥和私钥.<br> 王里冲自己随机选择两个素数 p=23,q=47.可以得到$n=p*q=53*59=3127$</p>
<p> 根据欧拉函数:<br> $$r=\phi(n)=(p-1)*(q-1)=52*58=3106$$<br> 然后,选择一个数字e=3, e的选择标准是: e是1和r之间的一个质数,1&lt; e&lt; r.e和r当然也是相互是质数.这里的n和e也是将来分发的公钥.</p>
<p> 接下来产生私钥,从数学上来讲,就是计算e相对的r的”模反元素”.使用这个公式:</p>
<p> $$ed ≡ 1 (mod (r))$$</p>
<p> 这个公式的意思是r对ed取余数是1.<br> 等价于:</p>
<p> $$ed+k*r=1$$</p>
<p> 也等价于:</p>
<p> $$ed-1 = k*\phi(n)$$</p>
<p> 带入数据就是:</p>
<p> $$3<em>d -1 = k </em> 3106$$</p>
<p> 其中k是一个常数.这个方程可以用”<a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">扩展欧几里得算法(辗转相除法)</a>“求解.</p>
<p> 最后可以得到 d=2011.具体的计算过程放在附录1中.</p>
<p> 所以公钥(n,e)就是(3127,3),私钥是(n,d)即(3127,2011);</p>
</li>
<li><p>王里冲公开发布公钥,所有人都可以得到公钥.当然潘兴也可以获得.这个地方rsa的特性保证了只用公钥不能或者说很难猜出私钥</p>
</li>
<li><p>潘兴用这个公钥,加密了自己的信息.通过公网传出给王里冲.</p>
<p> 此处,潘兴获得的公钥(n,e),(3127,3)</p>
<p> 由于rsa只能加密数字, 所以只能把要加密的信息按照一定的规则转化为数字.即将明文信息数字化.可以使用Unicode码的序号来表示这串数字.在英文范围内,Unicode与ASCII序号相同.把上面的”I LOVE YOU”转为数字就是<br> [ 73, 32, 76, 79, 86, 69, 32, 89, 79, 85 ]</p>
<p> js代码实现</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//getCodePoint :: string -&gt; [a]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCodePoint</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.split(<span class="string">''</span>).map(<span class="function">(<span class="params">e</span>) =&gt;</span> e.charCodeAt(<span class="number">0</span>))</span><br><span class="line">    <span class="comment">// console.log(codePoint);</span></span><br><span class="line">&#125;</span><br><span class="line">out = getCodePoint(<span class="string">'I LOVE YOU'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(out);<span class="comment">//[ 73, 32, 76, 79, 86, 69, 32, 89, 79, 85 ]</span></span><br></pre></td></tr></table></figure>
<p> 设待加密的信息m,加密后的信息是c, 然后加密的过程就是 m^e = c(mod n) (应该是一个三横线的等号), 等价于 m^e mod n = c.</p>
<p> 在这里还会遇到一个问题就是如果m和e数字比较大的时候, 直接乘方会有数据溢出的风险.所以, 这里有一些专门的算法.可以参考<a href="http://haoyuanliu.github.io/2016/04/04/get-mod/" target="_blank" rel="noopener">附录2的算法</a>.详细的信息可以搜索”高次幂函数取模算法”</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> out = [ <span class="number">73</span>, <span class="number">32</span>, <span class="number">76</span>, <span class="number">79</span>, <span class="number">86</span>, <span class="number">69</span>, <span class="number">32</span>, <span class="number">89</span>, <span class="number">79</span>, <span class="number">85</span> ];</span><br><span class="line"><span class="keyword">const</span> n = <span class="number">3127</span>;</span><br><span class="line"><span class="keyword">const</span> e = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">let</span> c = out.map(<span class="function"><span class="params">ele</span> =&gt;</span> ele ** e % <span class="number">3127</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c);<span class="comment">//[ 1269, 1498, 1196, 2100, 1275, 174, 1498, 1394, 2100, 1233 ]</span></span><br></pre></td></tr></table></figure>
<p> 至此, 潘兴小哥把自己的信息加密好了, 然后通过公网传给王里冲</p>
</li>
<li><p>王里冲获得信息,用自己在私钥解密.同样,rsa的特性保证只有私钥才能解密出公钥加密的信息.</p>
<p> 王总现在取得了潘兴的加密信息,只需要解密就可以看到了.</p>
<p> 解密的过程和加密及其类似:c^d=m(mod n)((应该是一个三横线的等号))<br> ,等价于 c^d mod n = m;</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> m = c.map(<span class="function"><span class="params">ele</span> =&gt;</span> getMod(ele, d, n));</span><br><span class="line"><span class="built_in">console</span>.log(m);<span class="comment">//[ 73, 32, 76, 79, 86, 69, 32, 89, 79, 85 ]</span></span><br><span class="line">out = <span class="built_in">String</span>.fromCodePoint(...m);</span><br><span class="line"><span class="built_in">console</span>.log(out);<span class="comment">//I LOVE YOU</span></span><br></pre></td></tr></table></figure>
<p> 最后, 潘兴终于获得了王里冲发给自己信息.</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到目前为止，完成了从公钥加密，私钥解密的过程。 接下来，还有一部分从私钥加密，公钥验证（挖坑），以及数字证书的签名问题(挖坑)。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.51cto.com/dayewo/1117309" target="_blank" rel="noopener">http://blog.51cto.com/dayewo/1117309</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">扩展欧几里得算法(辗转相除法)</a></li>
<li><a href="http://haoyuanliu.github.io/2016/04/04/get-mod/" target="_blank" rel="noopener">http://haoyuanliu.github.io/2016/04/04/get-mod/</a></li>
</ol>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol>
<li>17<em>d -1 = k </em> 3106的求解.d和k取整数</li>
</ol>
<p>把等式右边移到左边, 可以得到 17*d + k*3106 = 1.</p>
<blockquote>
<p>注意这里k的变成了原来-k,但是对于最终的结果没有影响,因为我们只是想找符合的参数</p>
</blockquote>
<p>有两种方法:</p>
<ul>
<li><p>方法一:辗转相除法</p>
<p>  已知:3120y+17x = 1</p>
<ul>
<li>3120 = 17*183+9</li>
<li>17 = 9*1 +8</li>
<li>9 = 8*1 + 1<br>改写成余数的形式:</li>
<li>9 = 3120<em>1 + 17\</em>(-183)</li>
<li>8 = 17<em>1 + 9\</em>(-1)</li>
<li><p>1 = 9<em>1 + 8\</em>(-1)</p>
<p>从最后一个式子开始, “倒回去” , 把上面式子的结果带入</p>
<p>1 = 9*1 + 8*(-1) =  9*1 + [17*1+9*9(-1)]<br>= 17*(-1)+9<em>2 = 17\</em>(-1) + (3120*1+17*(-183))=<br>3120*2+17*(-367).</p>
<p>所以可以得到x=-367 , y=2;<br>计算出这个结果之后, 并没有结束,按照wiki的解释, <a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0" target="_blank" rel="noopener">模逆元</a>, 一般x取最小的正数, x = x+ kn = -367+k*3120 = 2753.所以y = 15;</p>
</li>
</ul>
</li>
<li><p>方法二: </p>
<p>  受wiki上一个<a href="https://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">矩阵解法</a>的启发, 专门去搜了一下, 本质也是辗转相除法, 不过只是用矩阵表示出来.暂时先做记录, 以后可以优化(给自己挖坑)</p>
<p>  求解过程的来自这里: <a href="http://www.mast.queensu.ca/~math418/m418oh/m418oh13.pdf" target="_blank" rel="noopener">http://www.mast.queensu.ca/~math418/m418oh/m418oh13.pdf</a></p>
<p>  r_-1 = m = 3120, r_0 = n = 17</p>
<p>  3120/17 =183…9, r_1 = 9, q_1= 183</p>
<p>  17/9 = 1…8, r_2 = 8, q_2=1</p>
<p>  9/8=1…1, r_3=1, q_3=1</p>
<p>  8/1=8…0, r_4=0,q_4=8</p>
<p>  构造如下的矩阵<br>  每一次经过一个初等行变换</p>
<p>  $$<br>  \left(\begin{array}{cc}<br>  1 &amp; 0 &amp; 3120\<br>  0&amp; 1 &amp; 17<br>  \end{array}\right)<br>  $$ </p>
<p>  $$<br>  \left(\begin{array}{cc}<br>  0 &amp; 1 &amp; 17\<br>  1&amp; -183 &amp; 9<br>  \end{array}\right)<br>  $$ </p>
<p>  $$<br>  \left(\begin{array}{cc}<br>  1&amp; -183 &amp; 9\<br>  -1&amp; 184 &amp; 8<br>  \end{array}\right)<br>  $$ </p>
<p>  $$<br>  \left(\begin{array}{cc}<br>  -1&amp; 184 &amp; 8\<br>  2&amp; -367 &amp; 1<br>  \end{array}\right)<br>  $$ </p>
<p>  $$<br>  \left(\begin{array}{cc}<br>  -1&amp; 184 &amp; 8\<br>  2&amp; -367 &amp; 1<br>  \end{array}\right)<br>  $$ </p>
<p>  $$<br>  \left(\begin{array}{cc}<br>  2&amp; -367 &amp; 1\<br>  -17&amp; 3120 &amp; 0<br>  \end{array}\right)<br>  $$ </p>
<p>  2.暴力方法</p>
<p>  数学原理:TODO</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//a^b mod c</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMod</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b--) &#123;</span><br><span class="line">        result = result * a % c;<span class="comment">//这个算法的核心就是在迭代运算过程中进行取模运算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>mathjax中书写公式: <a href="https://www.zybuluo.com/Cesar/note/228458" target="_blank" rel="noopener">https://www.zybuluo.com/Cesar/note/228458</a></li>
</ul>
]]></content>
      <categories>
        <category>密码学</category>
      </categories>
  </entry>
  <entry>
    <title>nodejs使用mocha输出测试结果和使用istanbul输出覆盖率</title>
    <url>/2017/12/03/mocha-istanbul/</url>
    <content><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>本文介绍软件测试中经典问题nextdate的延伸–nextNDate, 以及记录使用nodejs引入mocha单元测试模块, 并且使用istanbul输出测试用例的覆盖率.其中测试用例又excel表格给出.</p>
<a id="more"></a>
<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul>
<li>软件测试理论</li>
<li>js基础语法</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="nextNdate问题"><a href="#nextNdate问题" class="headerlink" title="nextNdate问题"></a>nextNdate问题</h3><p>nextdate问题是指,给出一个日期date, 可以得到第二天的日期. 而nextNDate是指给出一个date, 获得n天之后的日期.核心思路是将nextdate循环n次就可以得到nextNdate的日期.</p>
<p>但是,在1582年10月5-14,这十天是没有的;少了十天,特别的, 英国此时没少, 在1752.9.2- 14,少了11天<a href="https://www.zhihu.com/question/54650391" target="_blank" rel="noopener">[1]</a>; 而且, 对于公元前的闰年的计算方法, 也有不同的方法.这里采用维基百科的计算方法.公元之前的闰年, 要用年份值减去1, 在去除以4.<a href="https://zh.wikipedia.org/wiki/%E9%97%B0%E5%B9%B4" target="_blank" rel="noopener">[2]</a>此外, 在公历中是没有公元0年的概念, 公元1年的前一年是公元前1年.从数学上理解是没有整数0.<a href="https://zhidao.baidu.com/question/14299912.html" target="_blank" rel="noopener">[3]</a></p>
<p>另外, 在javascript中可以使用内置的date类型来实现加减天数, 只需要在date中加减24*60*60*1000就可以.<a href="http://yuanliyin.iteye.com/blog/653456" target="_blank" rel="noopener">[4]</a>但是date类型数据没有对1582的时间进行处理.</p>
<p>实现的思路是, 根据N的正负, 分别调用afterNDate和beforeNDate. 对于afterNDate, 再去调用afterDate. 在afterDate里面, 将输入的date的与这个月的天数进行比较, 来判断是不是要把月份进位或者年份进位;这个月的天数无外乎31, 30, 28, 29这几种情况, 使用一个分支语句就可以简单的得到.对于beforeNDate同样的处理. 详细可以看代码.<a href="https://github.com/gt2017/nextNDate" target="_blank" rel="noopener">[5]</a>和下面的流程图.<br><img src="flow_chart.png" alt="img"></p>
<h3 id="使用mocha进行单元测试"><a href="#使用mocha进行单元测试" class="headerlink" title="使用mocha进行单元测试"></a>使用mocha进行单元测试</h3><p>mocha使用的很简单, 读一下阮大大的博客<a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="noopener">[6]</a>,把里面的demo实现一下就可以.</p>
<h3 id="使用istanbul显示测试用例的覆盖率"><a href="#使用istanbul显示测试用例的覆盖率" class="headerlink" title="使用istanbul显示测试用例的覆盖率."></a>使用istanbul显示测试用例的覆盖率.</h3><p>同样, 也是阮大大的博客<a href="http://www.ruanyifeng.com/blog/2015/06/istanbul.html" target="_blank" rel="noopener">[7]</a></p>
<p>需要注意是在windos系统使用:</p>
<p>在window系统上因为路径的原因，不能使用 <figure class="highlight plain"><figcaption><span>cover _mocha  ```命令，而要使用```  istanbul cover node_modules/mocha/bin/_mocha  ```, 官方说明上 usage on windows 部分也提到了这一点。</span></figcaption><table><tr><td class="code"><pre><span class="line">此外, 由于在个例子中的有部分测试用例(比方说,N到了十万或者百万)耗时比较长,这可能是js的性能问题, 旁边java的同学马上就可以结果.orz. </span><br><span class="line"></span><br><span class="line">如果一个用例时间太长, mocha就认为这个测试失败, mocha的默认时间是2000ms, 可以在通过添加调用参数来修改: </span><br><span class="line"></span><br><span class="line">``` istanbul cover node_modules/mocha/bin/_mocha -- -t 100000 ./test/nextNDate.test.js</span><br></pre></td></tr></table></figure></p>
<h3 id="测试用例的设计"><a href="#测试用例的设计" class="headerlink" title="测试用例的设计"></a>测试用例的设计</h3><p>对于单元测试, 分为白盒测试和黑盒测试. 所谓黑盒测试, 就是把代码看做一个黑盒, 在外部进行输入, 比较输出是否和预期相同.这属于动态测试. 而对于白盒测试, 分为静态测试, 比如代码走查,和动态测试.</p>
<p>用例要有非法的输入, 比如日期选择在1582/10/10,这一天在代码中应该是不存在的一天; 而N 的输入可以是非数字的.还有一个情况, 输入的日期中, 有字符串格式, 比如”2010/“20/20”,类似于sql注入的情况.</p>
<p>如果N的值太大, 导致超出时间测试失败, 可以参考3.3的设计测试的时间.</p>
<h3 id="使用js-xlsx读取存放在表格中的测试用例"><a href="#使用js-xlsx读取存放在表格中的测试用例" class="headerlink" title="使用js-xlsx读取存放在表格中的测试用例"></a>使用js-xlsx读取存放在表格中的测试用例</h3><p>excel表格存放测试用例确实不是一个好方法. 表格中的日期格式在微软的excel会自动处理成日期格式. 这样会导致js-xlsx读取出来的数据和看到的数据不一致, 这个问题在mac的表格也会出现. 解决办法可以在excel中使用text函数,把日期格式转换为文本格式, 注意转换的时候确定好’yyyy/mm/dd’格式还是’yyyy/m/d’格式, 前面的格式有0, 后面的没有0.比如前者显示2001/01/01, 后面显示2001/1/1.</p>
<p>js-xlsx的使用, 直接参照官方文档<a href="https://github.com/SheetJS/js-xlsx" target="_blank" rel="noopener">[8]</a>, 使用非常简单.其中sheet_to_json这个方法可以把表格数据导出为json格式, 非常适合js.</p>
<h3 id="使用node-xlsx将测试结果输出到表格中"><a href="#使用node-xlsx将测试结果输出到表格中" class="headerlink" title="使用node-xlsx将测试结果输出到表格中."></a>使用node-xlsx将测试结果输出到表格中.</h3><p>使用输出重定向,把默认在控制台中打印信息写入到log文件中, 从log文件中使用正则匹配取得测试的覆盖率结果, 写入到excel表格中.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这是上完测试课之后大作业. 用到的测试的原理比较简单, 无非是设计出尽量全面的用例.主要的精力用在如何用js实现代码.以及选择合适的代码库.</p>
<p>留下的教训:</p>
<ol>
<li>团队合作, 一定要有相互之间交流的通用的标准.比方说前后台交互数据使用统一的json格式. 这里是excel表格单元格样式都设置为日期样式或者文本样式, 这样才不会改来改去.</li>
</ol>
<h2 id="后续学习"><a href="#后续学习" class="headerlink" title="后续学习"></a>后续学习</h2><ol>
<li>在写代码的过程中, 对js的全局变量和局部变量的使用不熟练, 应该继续看书.顺便可以把闭包研究一下.</li>
<li>关于测试的理论, 继续看教材学习</li>
<li>在3.4中”2010/“20/20”这种情况还没想到好办法.</li>
<li>BDD和TDD两种开发方式如何选择. 至少需要有经验的人来了解一下.</li>
<li>nodejs关于文件和流, 忘干净了.</li>
</ol>
<h2 id="参考文献和说明"><a href="#参考文献和说明" class="headerlink" title="参考文献和说明"></a>参考文献和说明</h2><ol>
<li><a href="https://www.zhihu.com/question/54650391" target="_blank" rel="noopener">https://www.zhihu.com/question/54650391</a> ;</li>
<li><a href="https://zh.wikipedia.org/wiki/%E9%97%B0%E5%B9%B4" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E9%97%B0%E5%B9%B4</a></li>
<li><a href="https://zhidao.baidu.com/question/14299912.html" target="_blank" rel="noopener">https://zhidao.baidu.com/question/14299912.html</a></li>
<li><a href="http://yuanliyin.iteye.com/blog/653456" target="_blank" rel="noopener">http://yuanliyin.iteye.com/blog/653456</a></li>
<li><a href="https://github.com/gt2017/nextNDate" target="_blank" rel="noopener">https://github.com/gt2017/nextNDate</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/06/istanbul.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/06/istanbul.html</a></li>
<li><a href="https://github.com/SheetJS/js-xlsx" target="_blank" rel="noopener">https://github.com/SheetJS/js-xlsx</a></li>
</ol>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
  </entry>
</search>
